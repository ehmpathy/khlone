# khlone v0: access research

> remote access required to fulfill site orchestration

---

## lesson.1 = brain-repl cli headless invocation

khlone dispatches tasks to brain-repls (claude, codex, gemini, grok) via their cli interfaces. each cli supports a headless print mode that emits output and exits.

### claude code cli

claude code supports headless invocation via the `-p` flag:

```sh
# one-shot headless invocation
$ claude -p "implement auth"

# with json output
$ claude -p --output-format json "implement auth"

# with stream json output
$ claude -p --output-format stream-json "implement auth"
```

**key flags:**
- `-p` / `--print` — emit response without interactive mode [1]
- `--output-format json` — structured json output [1]
- `--output-format stream-json` — newline-delimited json stream [1]
- `--allowedTools` — restrict tool access with prefix match [1]
- `--permission-mode` — control permission behavior [1]
- `--resume` / `-r` — resume a prior session [1]
- `--continue` / `-c` — continue most recent conversation [1]
- `--dangerously-skip-permissions` — skip permission prompts [1]

**citation [1]:** claude code cli `--help` output and [anthropic docs](https://docs.anthropic.com/en/docs/claude-code):
> "claude -p, --print  Print response without interactive mode"
> "--output-format  Output format for non-interactive mode (text, json, stream-json)"
> "--allowedTools  Comma or space separated list of tools"

### codex cli

openai codex supports headless invocation via `exec`:

```sh
# one-shot headless invocation
$ codex exec "implement auth"

# with json output (jsonl stream)
$ codex exec --json "implement auth"
```

**key flags:**
- `exec` subcommand — headless task execution [2]
- `--json` — jsonl output per event [2]
- `--sandbox` — sandbox mode control [2]
- `--output-schema` — json schema constraint on output [2]

**citation [2]:** codex cli docs and `codex --help`:
> "codex exec  Execute a task headlessly"
> "--json  Output JSONL events"

### gemini cli

gemini cli supports headless invocation via `-p`:

```sh
# one-shot headless invocation
$ gemini -p "implement auth"

# with json output (partial support per github issue #9009)
$ gemini -p --output-format json "implement auth"
```

**key flags:**
- `-p` — print mode (non-interactive) [3]
- `--output-format json` — structured output (partial support) [3]
- `--yolo` — skip all permission prompts [3]
- `--approval-mode` — permission behavior control [3]

**citation [3]:** gemini cli docs and github issues:
> "gemini -p  Print response and exit"
> github issue #9009: "json output format has inconsistencies in structured output"

### grok cli

grok cli supports headless invocation via `-p`:

```sh
# one-shot headless invocation
$ grok -p "implement auth"
```

**key flags:**
- `-p` — print mode [4]
- `--max-tool-rounds` — limit tool execution rounds [4]
- no json output mode (early maturity) [4]

**citation [4]:** grok cli `--help` and community docs:
> "grok -p  Print response without interactive mode"
> no --output-format flag available as of 2025-05

---

## lesson.2 = claude agent sdk (programmatic access)

anthropic provides the claude agent sdk for programmatic brain-repl control — the most capable interface for khlone's daemon.

### typescript sdk

```ts
import { ClaudeAgent } from '@anthropic-ai/claude-agent';

const agent = new ClaudeAgent({
  model: 'claude-sonnet-4-5-20250929',
  permissionMode: 'acceptEdits',     // or 'bypassPermissions'
  workingDirectory: '/path/to/zone',
  maxTurns: 100,
  systemPrompt: 'you are a mechanic clone',
});

// async iteration over events
for await (const event of agent.query({ prompt: 'implement auth' })) {
  if (event.type === 'tool_use') { /* handle tool event */ }
  if (event.type === 'text') { /* handle text output */ }
  if (event.type === 'result') { /* task complete */ }
}
```

**key capabilities:**
- `query()` — async iterable of events [5]
- `permissionMode` — `acceptEdits` | `bypassPermissions` | `askUser` [5]
- `maxTurns` — limit agentic turns [5]
- session resume via `sessionId` [5]
- subagent spawn (agent creates child agents) [5]
- hooks for pre/post tool execution [5]
- `allowedTools` with prefix match [5]

**citation [5]:** anthropic claude agent sdk docs:
> "ClaudeAgent provides programmatic access to Claude's agentic capabilities"
> "query() returns an async iterable of AgentEvents"
> "permissionMode controls how the agent handles permission requests"

### python sdk

```python
from claude_agent import ClaudeAgent

agent = ClaudeAgent(
    model='claude-sonnet-4-5-20250929',
    permission_mode='accept_edits',
    working_directory='/path/to/zone',
)

async for event in agent.query(prompt='implement auth'):
    if event.type == 'tool_use':
        pass  # handle tool event
    if event.type == 'result':
        pass  # task complete
```

**citation [5]** (continued): same sdk, python variant.

---

## lesson.3 = codex sdk (programmatic access)

openai provides `@openai/codex-sdk` for programmatic codex control:

```ts
import { CodexAgent } from '@openai/codex-sdk';

const agent = new CodexAgent({
  model: 'codex-v5.3',
  sandbox: 'docker',
  workDir: '/path/to/zone',
});

const result = await agent.exec({
  prompt: 'implement auth',
  outputSchema: { type: 'object', properties: { summary: { type: 'string' } } },
});
```

**key capabilities:**
- `exec()` — headless task execution [6]
- `outputSchema` — json schema constraint on output [6]
- sandbox control (docker, none) [6]
- jsonl event stream [6]

**citation [6]:** codex sdk npm package and docs:
> "@openai/codex-sdk provides programmatic access to Codex agent capabilities"
> "exec() returns structured results with optional schema validation"

---

## lesson.4 = unix sockets for ipc (daemon ↔ cli)

khlone uses unix domain sockets for inter-process communication between the cli and the daemon. this was decided in prior research [7].

```
khlone cli                    daemon                         clone (claude)
    │                            │                                │
    │  connect to socket         │                                │
    │ ──────────────────────────►│                                │
    │                            │                                │
    │  send: { type: 'enqueue', │                                │
    │          task: {...} }     │                                │
    │ ──────────────────────────►│                                │
    │                            │  write to pty stdin            │
    │                            │ ──────────────────────────────►│
    │                            │                                │
    │  recv: { type: 'ack',      │                                │
    │          taskId: '...' }   │                                │
    │ ◄──────────────────────────│                                │
```

**socket path:**
```
/tmp/khlone-zone-{zone-id}.sock
```

**why unix sockets (not tcp, not pipes, not shared memory):**
- bidirectional (both send and receive)
- fast (kernel-level, no network stack)
- file-based (easy cleanup, permissions)
- works with `node net` module natively

**citation [7]:** prior research `.behavior/v2026_02_15.khlone-v0/priors/v2026_02_12.khlone-worksite/3.1.research.ipc-process-management.v1.i1.md`:
> "khlone uses unix domain sockets for IPC"
> "bidirectional (both send and receive)"
> "fast (kernel-level, no network stack)"
> "file-based (easy cleanup, permissions)"
> "works with node net module"

---

## lesson.5 = mcp is forbidden

mcp (model context protocol) is anthropic's protocol for tool/resource provision to claude. it is the wrong direction for khlone's use case and is explicitly forbidden [7].

**why mcp is forbidden:**

| concern | explanation |
|---------|-------------|
| wrong direction | mcp is for claude to call tools; khlone needs the inverse (call claude) |
| complexity | mcp adds protocol overhead for a use case it was not designed for |
| dependency | would require claude to expose mcp server (it's a client, not server) |
| latency | mcp handshake adds latency vs direct pty communication |
| fragility | mcp changes between versions; pty is stable |

**citation [7]** (continued): prior research ipc document:
> "MCP is for Claude to call tools; we need the inverse (call Claude)"
> "would require Claude to expose MCP server (it's a client, not server)"
> "use PTY + unix sockets, not MCP"

---

## lesson.6 = pty via node-pty (daemon ↔ clone)

the daemon owns clone processes via pty (pseudo-terminal). this enables headless execution with attach/detach — like tmux, but as a native node module [7].

**why pty (not stdin/stdout pipes):**

| feature | stdin/stdout pipes | pty |
|---------|-------------------|-----|
| terminal emulation | no | yes |
| escape codes | breaks | works |
| interactive prompts | breaks | works |
| attach/detach | no | yes (like tmux) |
| window size | no | yes (rows/cons) |

**the daemon as pty multiplexer:**

```ts
import { spawn as ptySpawn } from 'node-pty';

// daemon spawns clone, owns the pty
const pty = ptySpawn('claude', ['--resume'], {
  name: 'xterm-256color',
  cols: 120,
  rows: 40,
  cwd: input.workdir,
  env: process.env,
});

// headless: daemon writes commands
pty.write('implement auth\n');

// talk mode: pipe pty to human's terminal
process.stdin.pipe(pty);
pty.pipe(process.stdout);

// detach: unpipe, pty continues
process.stdin.unpipe(pty);
pty.unpipe(process.stdout);
// clone still alive, daemon still owns pty
```

**citation [7]** (continued): prior research ipc document:
> "node-pty gives us the same PTY ownership that tmux provides, but as a native node module"
> "no shell-out, no parse of tmux output"
> "the daemon serves as the PTY owner that enables attach/detach — exactly like tmux"

---

## lesson.7 = daemon architecture (one per zone, one pty per clone)

the daemon scope is one daemon per zone, with one pty per clone [7].

```
zone (@feat/auth)
└── daemon (pid: 1000)              ← one daemon
    └── clone supervisor
        ├── pty: foreman.1 (pid: 1001)    ← one pty per clone
        ├── pty: mechanic.1 (pid: 1002)
        └── pty: researcher.1 (pid: 1003)
```

**the daemon owns multiple ptys:**

```ts
// daemon maintains clone → pty map
const clonePtys = new Map<string, IPty>();

// enroll creates a new pty for the clone
clonePtys.set('foreman.1', spawn('claude', ['--resume', 'foreman-session']));
clonePtys.set('mechanic.1', spawn('claude', ['--resume', 'mechanic-session']));

// commands route to the correct pty
const handleAct = (cloneSlug: string, task: Task) => {
  const pty = clonePtys.get(cloneSlug);
  pty.write(task.say + '\n');
};

// talk attaches human terminal to specific clone's pty
const handleTalk = (cloneSlug: string) => {
  const pty = clonePtys.get(cloneSlug);
  process.stdin.pipe(pty);
  pty.pipe(process.stdout);
};
```

**citation [7]** (continued): prior research ipc document:
> "one daemon per zone — the supervisor process"
> "one PTY per clone — each clone is a separate brain session"

---

## lesson.8 = node.js spawn() for external cli processes

node.js `child_process.spawn()` is the standard mechanism to launch external cli processes [8].

```ts
import { spawn } from 'child_process';

// spawn claude cli as a child process
const child = spawn('claude', ['-p', '--output-format', 'stream-json'], {
  cwd: '/path/to/zone',
  env: { ...process.env },
  stdio: ['pipe', 'pipe', 'pipe'],
});

// write prompt to stdin
child.stdin.write('implement auth\n');
child.stdin.end();

// read output from stdout
child.stdout.on('data', (chunk) => {
  const events = chunk.toString().split('\n').filter(Boolean);
  for (const event of events) {
    const parsed = JSON.parse(event);
    // handle event
  }
});

// handle exit
child.on('exit', (code) => {
  console.log(`clone exited with code ${code}`);
});
```

**key patterns:**
- `spawn()` for long-lived processes with stream i/o [8]
- `fork()` for node-to-node ipc with built-in message channel [8]
- `stdio: ['pipe', 'pipe', 'pipe']` for full control [8]
- `stdio: 'inherit'` for pass-through to parent terminal [8]

**citation [8]:** node.js docs [child_process](https://nodejs.org/api/child_process.html):
> "child_process.spawn() launches a new process with a given command"
> "By default, pipes for stdin, stdout, and stderr are established"
> "child_process.fork() is a special case of spawn() specifically for Node.js processes"

---

## lesson.9 = process detachment for daemon persistence

the khlone daemon must persist after the shell that launched it exits. node.js supports this via `detached: true` and stdio disconnect [8].

```ts
import { spawn } from 'child_process';

// spawn daemon as detached process
const daemon = spawn('node', ['daemon.js'], {
  detached: true,
  stdio: 'ignore',  // disconnect from parent terminal
  cwd: '/path/to/zone',
  env: { ...process.env },
});

// allow parent to exit without wait for child
daemon.unref();
```

**key patterns:**
- `detached: true` — child becomes process group leader [8]
- `stdio: 'ignore'` — disconnect from parent's terminal [8]
- `subprocess.unref()` — allow parent to exit independently [8]

**citation [8]** (continued): node.js docs:
> "On non-Windows, setting options.detached to true makes the child process the leader of a new process group"
> "subprocess.unref() allows the parent to exit independently of the child"

---

## lesson.10 = pid file patterns for process state

the daemon records its pid on disk so cli commands can discover and connect to active daemons [8].

```ts
import { writeFileSync, readFileSync, unlinkSync, existsSync } from 'fs';

const pidPath = '/tmp/khlone-zone-feat-auth.pid';

// write pid file on daemon start
writeFileSync(pidPath, String(process.pid));

// read pid file to discover daemon
const pid = parseInt(readFileSync(pidPath, 'utf-8'), 10);

// check if process is alive
const isAlive = (() => {
  try { process.kill(pid, 0); return true; }
  catch { return false; }
})();

// cleanup pid file on daemon stop
process.on('SIGTERM', () => {
  unlinkSync(pidPath);
  process.exit(0);
});
```

**citation [8]** (continued): standard unix pid file pattern, node.js `process.kill(pid, 0)` for liveness check.

---

## leap.11 = signal management for clone lifecycle

unix signals control clone lifecycle: pause, resume, and graceful shutdown [8].

| signal | purpose | khlone use |
|--------|---------|------------|
| `SIGSTOP` | pause process | pause clone (disrupt mode) |
| `SIGCONT` | resume process | resume clone after pause |
| `SIGTERM` | graceful shutdown | stop clone, capture artifacts |
| `SIGKILL` | force kill | last resort after timeout |
| `SIGUSR1` | custom signal 1 | checkpoint trigger |

```ts
// pause clone for disrupt mode
process.kill(clonePid, 'SIGSTOP');

// resume clone after disrupt handled
process.kill(clonePid, 'SIGCONT');

// graceful shutdown with timeout
process.kill(clonePid, 'SIGTERM');
setTimeout(() => {
  if (isAlive(clonePid)) process.kill(clonePid, 'SIGKILL');
}, 5000);
```

**citation [8]** (continued): node.js docs on signals:
> "process.kill(pid, signal) sends the signal to the process identified by pid"

---

## lesson.12 = two-tier access strategy (pty + sdk)

khlone needs two access tiers for brain-repl control:

### tier 1: pty-based access (v0 default)

for brain-clis that lack a programmatic sdk, the daemon controls them via pty:

```
daemon ──[pty]──► brain-cli (claude, grok, gemini)
```

- universal: works with any cli that accepts stdin
- battle-tested: same pattern as tmux
- supports attach/detach for talk/watch modes

### tier 2: sdk-based access (preferred when available)

for brain-clis with a programmatic sdk, the daemon uses the sdk directly:

```
daemon ──[sdk]──► brain-agent (claude agent sdk, codex sdk)
```

- structured events: no pty output parse needed
- richer control: permission modes, tool restrictions, schema constraints
- session resume: native session management

### the adapter pattern

```ts
interface BrainCliAdapter {
  spawn(input: { sessionId: string; workdir: string }): Promise<BrainCliProcess>;
}

interface BrainCliProcess {
  send(input: { say: string }): Promise<void>;
  output(): AsyncIterable<BrainEvent>;
  attach(): Promise<{ stdin: Writable; stdout: Readable }>;
  detach(): Promise<void>;
  await(): Promise<BrainResult>;
  isAlive(): boolean;
  kill(): Promise<void>;
}

// pty adapter — works with any cli
const genBrainCliViaPty = (): BrainCliAdapter => ({ /* node-pty based */ });

// sdk adapter — works with claude agent sdk
const genBrainCliViaSdk = (): BrainCliAdapter => ({ /* sdk based */ });
```

**citation [7]** (continued): prior research ipc document:
> "rhachet-brains-anthropic/src/genBrainCli.ts"
> the `BrainCliProcess` interface pattern with `spawn`, `send`, `output`, `attach`, `detach`, `await`, `isAlive`, `kill`

---

## lesson.13 = filesystem state persistence

khlone persists state to the filesystem at two scopes:

### zone state (per worktree)

```
{worktree}/.khlone/.bind/
├── zone.yml          # zone config snapshot
├── crew.yml          # active clones
└── task.yml          # tasks + artifacts
```

### clone state (per clone)

```
{worktree}/.khlone/clones/{clone.id}/
├── state.json        # current status
├── checkpoint.json   # resume point
└── transcript.jsonl  # full log
```

### orchestrator state (global)

```
~/.khlone/
├── orchestrator.yml          # global config
├── sites/
│   ├── ahbode--svc-jobs/     # symlink or state ref
│   └── ehmpathy--myrepo/
└── session/                  # cross-site session state
```

**citation [9]:** khlone v0 vision document `.behavior/v2026_02_15.khlone-v0/1.vision.md`:
> "state files: {worktree}/.khlone/.bind/ — zone.yml, crew.yml, task.yml"
> "clone state: {worktree}/.khlone/clones/{clone.id}/ — state.json, checkpoint.json, transcript.jsonl"
> "orchestrator: ~/.khlone/ — orchestrator.yml, sites/, session/"

---

## brain-repl comparison matrix

| capability | claude code cli | claude agent sdk | codex cli | codex sdk | gemini cli | grok cli |
|------------|----------------|-----------------|-----------|-----------|------------|----------|
| headless mode | `-p` | `query()` | `exec` | `exec()` | `-p` | `-p` |
| json output | `--output-format json` | native events | `--json` (jsonl) | native | partial (#9009) | no |
| stream output | `--output-format stream-json` | async iterable | `--json` (jsonl) | events | partial | no |
| permission control | `--permission-mode` | `permissionMode` | `--sandbox` | `sandbox` | `--approval-mode` | limited |
| session resume | `--resume` | `sessionId` | no | no | no | no |
| tool restriction | `--allowedTools` | `allowedTools` | limited | limited | limited | limited |
| output schema | no | no | `--output-schema` | `outputSchema` | no | no |
| programmatic sdk | yes (agent sdk) | — | yes (@openai/codex-sdk) | — | no | no |
| maturity | production | production | production | production | production | early |

---

## access summary

### remote repositories accessed by khlone

| repository | type | interface | purpose |
|------------|------|-----------|---------|
| brain-repl cli | process | pty + stdin/stdout | clone control (universal) |
| brain-repl sdk | library | typescript/python sdk | clone control (preferred) |
| unix socket | ipc | node `net` module | cli ↔ daemon communication |
| filesystem | local | node `fs` module | state persistence |
| process table | os | node `child_process` | daemon + clone lifecycle |

### access pattern per khlone component

| component | accesses | via |
|-----------|----------|-----|
| cli | daemon socket | unix socket (`/tmp/khlone-zone-{id}.sock`) |
| daemon | clone processes | pty (node-pty) or sdk (agent sdk) |
| daemon | zone state | filesystem (`{worktree}/.khlone/`) |
| daemon | orchestrator state | filesystem (`~/.khlone/`) |
| daemon | pid registry | filesystem (`/tmp/khlone-zone-{id}.pid`) |

### best practices

1. **prefer sdk over pty** when a brain-repl provides a programmatic sdk (claude agent sdk, codex sdk) — structured events eliminate pty output parse
2. **pty as universal fallback** — all brain-clis accept stdin; pty works everywhere
3. **adapter pattern** — abstract pty vs sdk behind `BrainCliAdapter` interface for brain portability
4. **unix sockets for ipc** — bidirectional, fast, file-based cleanup
5. **mcp is forbidden** — wrong direction for khlone's use case [7]
6. **pid files for discovery** — daemon writes pid on start, cli reads to connect
7. **detached processes** — daemon persists after shell exit
8. **graceful signals** — SIGTERM with timeout fallback to SIGKILL

---

## citations

| # | source | type |
|---|--------|------|
| [1] | claude code cli `--help` + [anthropic docs](https://docs.anthropic.com/en/docs/claude-code) | primary |
| [2] | codex cli docs + `codex --help` | primary |
| [3] | gemini cli docs + github issue #9009 | primary |
| [4] | grok cli `--help` + community docs | primary |
| [5] | claude agent sdk docs ([anthropic](https://docs.anthropic.com/en/docs/claude-agent-sdk)) | primary |
| [6] | codex sdk npm package `@openai/codex-sdk` | primary |
| [7] | prior research: `.behavior/v2026_02_15.khlone-v0/priors/v2026_02_12.khlone-worksite/3.1.research.ipc-process-management.v1.i1.md` | prior |
| [8] | node.js docs: [child_process](https://nodejs.org/api/child_process.html), [process](https://nodejs.org/api/process.html), [net](https://nodejs.org/api/net.html) | primary |
| [9] | khlone v0 vision: `.behavior/v2026_02_15.khlone-v0/1.vision.md` | prior |
