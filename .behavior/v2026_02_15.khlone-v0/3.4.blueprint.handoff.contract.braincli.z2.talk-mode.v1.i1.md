# khlone v0: zoomin — talk mode terminal mechanics

> how tmux attaches terminals, how docker attach works, and why khlone's daemon should own the byte relay

---

## the question

the handoff contract assumes khlone can switch a clone between headless dispatch (`ask`/`act`) and interact talk mode. the z1 zoomin showed that no CLI supports live mode-switch on a process — but `executor.boot` hides this behind the BrainCli handle.

but **how does the user's terminal actually connect to the brain CLI in talk mode?** the daemon owns the headless process. when the user types `khlone talk`, what happens at the PTY level?

two options:
1. **byte relay** — the daemon relays bytes between the khlone CLI (thin client) and the brain CLI PTY
2. **direct connect** — the khlone CLI spawns the brain CLI itself with `stdio: 'inherit'`

the requirement is clear: **the khlone CLI must be a thin executor.** all brain CLI process ownership goes through the daemon. the daemon IS a terminal multiplexer — and that's intentional.

### why the daemon must own the relay

three architectural reasons demand daemon-owned byte relay:

1. **the khlone CLI is an ultra-thin compiled binary.** it sends IPC messages, relays bytes, and renders output. zero process management. this enables khlone CLI to be compiled (bun, deno, or native) for instant cold start — no node.js boot penalty.

2. **the daemon controls the full exit lifecycle.** any brain CLI exit, any CLI disconnect, any crash — the daemon detects it and boots to dispatch. no "signal back to the CLI so it can tell the daemon" round-trip. the daemon is the authority on process state.

3. **remote zones require the daemon as SSH proxy.** when zones run on cloud hosts, the daemon will proxy the byte relay over SSH. the same IPC protocol that works locally (unix socket) extends to remote (SSH tunnel to remote unix socket). if the CLI owned the process, remote zones would require the CLI to manage SSH — which violates the thin CLI requirement.

### latency analysis: the relay overhead is negligible

the byte relay adds one unix socket hop per keystroke. how much latency does that add?

**local daemon relay (unix domain socket):**

| metric | latency | source |
|---|---|---|
| unix socket round-trip | ~2-3 microseconds | kernel IPC benchmarks |
| node.js unix socket IPC | ~130 microseconds (~0.13ms) | node.js IPC benchmarks |
| human perceptible keystroke delay | ~100ms | Nielsen's instantaneous threshold [^nielsen] |
| brain CLI response latency | 100-5000ms | LLM inference (time to first token) |

**the relay adds ~0.13ms per keystroke — 770x below Nielsen's 100ms perception threshold [^nielsen].** docker attach uses the same unix socket relay model and nobody notices.

**remote daemon relay (SSH tunnel to cloud zone):**

| metric | latency | notes |
|---|---|---|
| SSH hop (same region) | 1-5ms | AWS/GCP same-region |
| SSH hop (cross-continent) | 30-50ms | US-to-EU |
| plus unix socket at each end | ~0.13ms | same as local |
| brain CLI response latency | 100-5000ms | LLM inference |

**same-region remote: well under perceptible threshold.** cross-continent may feel slightly laggy for rapid keystroke input, but brain CLI inference latency (seconds per response) dwarfs the relay overhead by 100-1000x. tmux over SSH has the same cross-continent characteristics and is standard practice.

**docker does not document "attach latency" as a performance concern** — the unix socket relay is so fast it's not measurable by end users. docker's known latency issues are about inter-container network, not the attach/detach byte relay path.

---

## tmux architecture: how terminal attach works

### the server-client model

tmux uses a server-client architecture over a unix socket:

```
terminal A (user)                tmux server (daemon)
  |-- tmux client -------------- /tmp/tmux-1000/default (unix socket)
  |   (thin PTY relay)            |-- session 0
  |                               |   +-- window 0
  |                               |       +-- pane 0 -> PTY master -> bash (pid 1234)
  |                               |
terminal B (user)                 |
  |-- tmux client -------------- |  (same socket)
  |   (thin PTY relay)            |
```

**key mechanism:** the tmux server owns all PTY masters. the tmux client is a thin relay — it reads the user's terminal, forwards bytes to the server via unix socket, and receives output bytes back. the server writes to the PTY master (which goes to the shell/program), and reads PTY master output (which comes from the shell/program).

### how tmux attach works

when you run `tmux attach -t 0`:

1. tmux client opens a connection to the tmux server unix socket
2. client sends an "attach to session 0" message
3. server begins to relay PTY master output -> socket -> client -> user terminal
4. client begins to relay user terminal input -> socket -> server -> PTY master
5. server sends the current terminal size to the PTY (SIGWINCH)

**the critical detail:** tmux uses `SCM_RIGHTS` (unix ancillary data) to pass file descriptors between the client and server process. this lets the server access the client's terminal FD directly — not just bytes, but the actual file descriptor. this enables proper terminal size negotiation, signal delivery, and raw mode management.

### why tmux works this way

tmux must support **multiple clients on one session** — two terminals can watch the same pane simultaneously. this requires a central server that multiplexes output to all attached clients and arbitrates input from any of them.

tmux also must support **detach and re-attach** — the server persists after all clients disconnect. the program in the pane (e.g., bash) never notices the detach — it keeps its PTY master alive via the server.

---

## docker attach: the byte proxy model

docker uses a simpler model — no fd pass, just byte relay:

```
user terminal -> docker client -> docker daemon (REST/socket) -> container stdin
container stdout -> docker daemon -> docker client -> user terminal
```

**how docker attach works:**

1. `docker attach <container>` connects to the docker daemon via REST API or unix socket
2. daemon opens a bidirectional byte stream to the container's stdio
3. client relays: user terminal input -> daemon -> container stdin
4. client relays: container stdout -> daemon -> user terminal
5. client sets the user's terminal to raw mode (no local echo, no line buffer)

**no fd pass needed** because docker has only one client per attach (unlike tmux's multi-client). the byte relay is simpler but sufficient.

**detach sequence:** the user presses the detach key combo (default `ctrl-p ctrl-q`). the client intercepts this locally, sends a detach signal to the daemon, and exits. the container continues to run — the daemon owns the container process.

---

## what khlone needs vs what tmux/docker solve

| concern | tmux | docker | khlone |
|---|---|---|---|
| server owns process | yes (PTY master) | yes (container) | yes (daemon owns brainCli in all modes) |
| client is a thin relay | yes | yes | yes (khlone CLI is thin) |
| multiple clients at once | yes (SCM_RIGHTS) | no (one attach) | no (one user per talk) |
| detach/re-attach | yes | yes (ctrl-p ctrl-q) | yes (any exit or disconnect) |
| raw terminal mode | yes | yes | yes (for talk mode) |

khlone's talk mode needs:
1. the user's terminal connects to the brain CLI **via the daemon**
2. keystrokes reach the brain CLI through the IPC relay
3. brain CLI output reaches the user's terminal through the IPC relay
4. any brain CLI exit triggers boot to dispatch mode
5. any CLI disconnect (ctrl+c, terminal close) triggers boot to dispatch mode
6. the daemon owns the brain CLI process at all times — talk mode and dispatch mode alike

### the docker-style model fits khlone

khlone's architecture mirrors docker's:
- **daemon** = docker daemon — owns the process, relays bytes
- **khlone CLI** = docker client — thin relay, sets raw mode, forwards bytes
- **brain CLI** = container — the actual process the user talks to

the key insight from docker: **the daemon should own the process in all modes.** the client is disposable — it can crash, disconnect, or be replaced without affect to the brain CLI. the daemon is the durable supervisor.

### why byte relay, not direct connect

| concern | byte relay (daemon-owned) | direct connect (CLI-owned) |
|---|---|---|
| process ownership | daemon always owns brain CLI | CLI owns interact, daemon owns dispatch |
| CLI crash resilience | brain CLI survives CLI crash | brain CLI dies with CLI |
| daemon crash resilience | brain CLI dies (daemon is parent) | brain CLI survives (CLI is parent) |
| watch + talk symmetry | same IPC stream, just add input | separate mechanisms |
| CLI complexity | thin: relay bytes, set raw mode | must spawn, manage, signal back |
| daemon complexity | higher: byte relay + raw mode proxy | lower: idle while talk active |
| SIGWINCH | daemon proxies terminal size | inherited — just works |
| terminal features | must relay faithfully | native |

**byte relay is the clear winner.** the ~0.13ms relay overhead is 770x below Nielsen's 100ms perception threshold. tmux and docker both use byte relay for interactive sessions — it's the proven model. the daemon handles SIGWINCH proxy, exit lifecycle, and (future) SSH tunnels. the CLI stays thin.

---

## the byte relay protocol

### step by step

```
1. user types: khlone talk

2. khlone CLI -> daemon (IPC): { type: 'talk', cloneSlug: 'foreman.1' }
   daemon:
     a. call brainCli.executor.boot({ mode: 'interact' })
        - supplier kills headless process
        - supplier spawns interact process (e.g., claude --resume <series>)
        - handle stays the same, pid updated, onData/onExit re-wired
     b. return { type: 'talk-ready' }

3. khlone CLI receives talk-ready
   khlone CLI:
     a. set terminal to raw mode (no local echo, no line buffer)
     b. begin relay loop:
        - process.stdin -> IPC { type: 'input', data } -> daemon -> brainCli.terminal.write(data)
        - brainCli.terminal.onData -> daemon -> IPC { type: 'output', data } -> khlone CLI -> process.stdout

4. user is now in the brain CLI's TUI/REPL
   - keystrokes: user terminal -> khlone CLI -> IPC -> daemon -> brainCli.terminal.write
   - output: brainCli.terminal.onData -> daemon -> IPC -> khlone CLI -> user terminal
   - khlone CLI is a thin pipe — it does zero interpretation

5. talk mode ends (any of these triggers):
   a. brain CLI exits (crash, /exit, normal end)
      -> brainCli.terminal.onExit fires in daemon
      -> daemon boots to dispatch: brainCli.executor.boot({ mode: 'dispatch' })
      -> daemon sends { type: 'talk-end', reason: 'brain-exit', code } to CLI
      -> khlone CLI restores terminal, informs user

   b. khlone CLI disconnects (ctrl+c, terminal close, IPC drop)
      -> daemon detects IPC client gone
      -> daemon boots to dispatch: brainCli.executor.boot({ mode: 'dispatch' })
      -> no CLI to notify — it's already gone

   c. user sends detach signal (e.g., khlone-specific escape sequence)
      -> khlone CLI sends { type: 'detach' } to daemon
      -> daemon boots to dispatch: brainCli.executor.boot({ mode: 'dispatch' })
      -> daemon sends { type: 'talk-end', reason: 'detach' } to CLI
      -> khlone CLI restores terminal, returns to shell
```

### the daemon's role in talk mode

the daemon is active — it is the byte relay:

```
before talk (dispatch mode):
  daemon --- brainCli (headless, pid 1001)

talk mode (byte relay):
  daemon --- brainCli (interact, pid 1002)
    |
    +-- IPC socket -- khlone CLI -- user terminal

after talk (back to dispatch):
  daemon --- brainCli (headless, pid 1003, series continued)
```

**the daemon always owns the brain CLI.** in dispatch mode, it reads structured output. in interact mode, it relays raw PTY bytes. the mode changes; the ownership does not.

---

## SIGWINCH and terminal size

when the user resizes their terminal while in talk mode:

1. khlone CLI receives `SIGWINCH` (terminal resize signal)
2. khlone CLI reads new terminal size via `process.stdout.columns` / `process.stdout.rows`
3. khlone CLI sends `{ type: 'resize', cols, rows }` to daemon via IPC
4. daemon calls `brainCli.terminal.resize(cols, rows)` — sets the PTY dimensions
5. brain CLI receives `SIGWINCH` on its PTY and redraws

this is the same pattern docker uses. the daemon must proxy terminal size because it owns the PTY.

---

## impact on BrainCli contract

### the handle shape (daemon-owned, both modes)

```ts
interface BrainCli {
  pid: number;                                         // updated on each boot
  mode: 'dispatch' | 'interact';                       // current mode
  series: string | null;                               // current series ref

  // lifecycle
  executor: {
    boot(input: { mode: 'dispatch' | 'interact' }): Promise<void>;
  };
  kill(): void;

  // dispatch (only valid in dispatch mode)
  ask(input: { prompt: string }): Promise<BrainOutput>;
  act(input: { prompt: string }): Promise<BrainOutput>;

  // terminal (valid in both modes)
  terminal: {
    write(data: string): void;
    resize(cols: number, rows: number): void;
    onData(cb: (chunk: string) => void): void;
    onExit(cb: (code: number, signal?: string) => void): void;
  };
}
```

**mode constraints:**
- `ask()` and `act()` are only valid in `dispatch` mode — call in `interact` mode throws
- `terminal.write()` is valid in both modes — in `dispatch` mode it writes to the structured stdin; in `interact` mode it writes raw PTY input
- `terminal.resize()` is valid in both modes — primarily used in `interact` mode for SIGWINCH proxy
- `terminal.onData` fires in both modes — in `dispatch` mode it emits structured events; in `interact` mode it emits raw terminal output
- `executor.boot()` can be called in either mode — it always kills the current process and respawns in the target mode

**no `standby` mode.** the daemon always has a live process or is in the middle of a boot. the handle manages the boot internally — khlone never sees a gap.

**no `prepareInteract` / `completeInteract`.** those were artifacts of the direct-connect model where the CLI spawned the interact process. with daemon-owned byte relay, the daemon handles the full mode switch via `executor.boot()`.

### updated IPC messages for talk mode

```ts
type IpcMessage =
  // ... extant messages ...
  | { type: 'talk'; cloneSlug: string }
  | { type: 'talk-ready' }
  | { type: 'talk-end'; reason: 'brain-exit' | 'detach'; code: number | null }
  | { type: 'input'; cloneSlug: string; data: string }
  | { type: 'output'; cloneSlug: string; data: string }
  | { type: 'resize'; cloneSlug: string; cols: number; rows: number }
  | { type: 'detach'; cloneSlug: string }
  // ... rest ...
```

**IPC flow:**

```
khlone CLI                              daemon
    |                                     |
    |  { type: 'talk',                   |
    |    cloneSlug: 'foreman.1' }        |
    | ----------------------------------> |
    |                                     |  brainCli.executor.boot({ mode: 'interact' })
    |                                     |  (supplier: kill headless, spawn interact)
    |  { type: 'talk-ready' }            |
    | <---------------------------------- |
    |                                     |
    |  [set terminal to raw mode]         |
    |                                     |
    |  { type: 'input', data: '...' }    |  ----> brainCli.terminal.write(data)
    | ----------------------------------> |
    |                                     |
    |  { type: 'output', data: '...' }   |  <---- brainCli.terminal.onData
    | <---------------------------------- |
    |                                     |
    |  { type: 'resize', cols, rows }    |  ----> brainCli.terminal.resize(cols, rows)
    | ----------------------------------> |
    |                                     |
    |  ... byte relay continues ...       |
    |                                     |
    |  [brain CLI exits]                  |  <---- brainCli.terminal.onExit fires
    |                                     |  brainCli.executor.boot({ mode: 'dispatch' })
    |  { type: 'talk-end',               |
    |    reason: 'brain-exit',            |
    |    code: 0 }                        |
    | <---------------------------------- |
    |                                     |
    |  [restore terminal, return shell]   |
```

---

## crash recovery in talk mode

### what if the brain CLI crashes?

1. `brainCli.terminal.onExit` fires in the daemon
2. daemon boots to dispatch: `brainCli.executor.boot({ mode: 'dispatch' })`
3. daemon sends `{ type: 'talk-end', reason: 'brain-exit', code }` to khlone CLI
4. khlone CLI restores terminal, informs the user: "brain CLI exited. clone booted to dispatch mode."
5. daemon resumes task queue

the daemon handles crash recovery the same way regardless of mode — `onExit` fires, boot to dispatch.

### what if the khlone CLI crashes or disconnects?

1. the IPC connection drops
2. daemon detects client disconnect
3. daemon boots to dispatch: `brainCli.executor.boot({ mode: 'dispatch' })`
4. daemon resumes task queue
5. no CLI to notify — it's gone

the brain CLI process is unaffected by the CLI crash — the daemon owns it. the daemon just switches back to dispatch mode and continues.

### what if the daemon crashes while in talk mode?

1. the daemon dies — the brain CLI process dies too (daemon is the parent)
2. khlone CLI detects IPC disconnect
3. khlone CLI restores terminal, informs the user: "daemon crashed. restart with `khlone talk` to reconnect."
4. next `khlone talk` or `khlone act` triggers daemon restart via `genZoneDaemon` and series continuation

this is the one case where daemon-owned mode is worse than direct-connect — a daemon crash kills the interact session. but daemon crashes should be rare (the daemon is a thin supervisor), and recovery is just "run the command again."

---

## watch mode and talk mode: unified relay

both watch and talk use the same IPC byte relay — they differ only in direction:

| mode | direction | raw terminal? | daemon boots mode? |
|---|---|---|---|
| watch | output only (daemon -> CLI) | no | no (stays dispatch) |
| talk | bidirectional (daemon <-> CLI) | yes (khlone CLI sets raw mode) | yes (dispatch -> interact -> dispatch) |

**watch IPC:**
```
brainCli.terminal.onData -> daemon -> IPC { type: 'output' } -> khlone CLI -> process.stdout
```

**talk IPC:**
```
process.stdin -> khlone CLI -> IPC { type: 'input' } -> daemon -> brainCli.terminal.write()
brainCli.terminal.onData -> daemon -> IPC { type: 'output' } -> khlone CLI -> process.stdout
```

the daemon code for output relay is shared between watch and talk. talk just adds the input relay and mode switch.

---

## summary

| question | answer |
|---|---|
| how does tmux attach? | server-client over unix socket with SCM_RIGHTS fd pass |
| how does docker attach? | byte relay over REST/socket — simpler, one client |
| what should khlone use? | byte relay through daemon (docker-style) — daemon owns the process in all modes |
| why byte relay, not direct connect? | keeps khlone CLI thin; daemon is the single process owner; CLI crash does not kill brain CLI |
| who spawns the interact process? | the daemon (via `brainCli.executor.boot({ mode: 'interact' })`) |
| what does the khlone CLI do in talk mode? | thin relay: set raw mode, pipe stdin -> IPC -> daemon, pipe daemon -> IPC -> stdout |
| how does talk mode end? | any brain CLI exit OR any CLI disconnect -> daemon boots to dispatch |
| how does SIGWINCH work? | khlone CLI sends resize IPC message, daemon calls brainCli.terminal.resize() |
| how does watch relate to talk? | same output relay; talk adds input relay + mode switch |

### the mental model

```
watch mode:   daemon -- brainCli (dispatch) --> IPC --> khlone CLI --> user terminal
              (output-only relay, clone stays in dispatch mode)

talk mode:    user terminal <-> khlone CLI <-> IPC <-> daemon <-> brainCli (interact)
              (bidirectional relay, daemon boots to interact then back to dispatch)
```

### what this changes in the handoff contract

1. **`executor.boot({ mode: 'interact' })` is the mechanism** — the daemon boots the brain CLI to interact mode for talk
2. **`executor.boot({ mode: 'dispatch' })` on any exit** — brain CLI exit or CLI disconnect triggers boot back to dispatch
3. **no `prepareInteract` / `completeInteract`** — the daemon handles the full mode switch internally
4. **no `standby` mode** — the handle is always either `dispatch` or `interact`
5. **`terminal.resize(cols, rows)` added to handle** — daemon proxies terminal size for interact mode
6. **IPC messages: `talk`, `talk-ready`, `talk-end`, `input`, `output`, `resize`, `detach`** — byte relay protocol
7. **khlone CLI is always thin** — it never spawns brain CLI processes; it only sends IPC messages and relays bytes

---

## citations

- [^nielsen] [response time limits: 3 important limits (nielsen norman group)](https://www.nngroup.com/articles/response-times-3-important-limits/) — 100ms for instantaneous feel
- [^uds-node] [node.js developer's guide to unix domain sockets](https://nodevibe.substack.com/p/the-nodejs-developers-guide-to-unix) — 130us UDS latency in node.js
- [^uds-bench] [benchmark TCP/IP, unix domain socket and named pipe](https://www.yanxurui.cc/posts/server/2023-11-28-benchmark-tcp-uds-namedpipe/) — ~2.3us kernel-level UDS
