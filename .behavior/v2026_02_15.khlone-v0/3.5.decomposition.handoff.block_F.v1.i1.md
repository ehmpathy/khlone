# block F: persistence + artifacts + log

> state survives daemon death. tasks capture structured output on completion. transcripts are reviewable. this block introduces the entire persistence layer — DAOs, filesystem helpers, and the `~/.khlone/` state directory.

---

## read first

1. `./1.vision.md` — sections: "domain model > zone" (state files under `.khlone/.bind/`), "domain model > clone" (state files, checkpoint, transcript), "domain model > task" (artifacts), "operation: log" (transcript review)
2. `./2.1.criteria.blackbox.md` — usecases 12 (crash recovery — daemon-level: checkpoint + resume), 13 (task artifacts: summary, complete, tokens), 14 (transcript access: `khlone log`)
3. `./3.3.blueprint.v1.i1.md` — section 3.2 (infra contracts: filesystem helpers), section 3.3 (dao contracts: 8 daos), codepath 2.7 (crash recovery: checkpoint → resume)
4. `./3.2.distill.domain._.v1.i1.md` — domain objects: CloneCheckpoint, CloneTranscriptEmission, TaskArtifact; dao contracts: full CRUD signatures
5. `./3.5.decomposition.v1.i1.md` — block F section: what ships, what this unlocks, boundaries, file count

---

## prerequisite

**block A must be complete.** the daemon, IPC, and hero clone dispatch must work. this block adds persistence beneath the extant in-memory state model — the daemon continues to hold state in memory but now also persists mutations to disk.

---

## scope

### what to build

**infra/filesystem (persistence helpers — 4 prod, 4 test):**
- readJsonFile — json read with type cast, returns null if absent
- writeJsonFile — json write with atomic semantics (write to tmp, rename into place)
- appendJsonlFile — append a single jsonl line (transcript, append-only)
- readJsonlFile — read all jsonl lines, parse each

**domain objects (3 files):**
- CloneCheckpoint — resume point: clone slug, series ref, active task slug, prompt, timestamp
- CloneTranscriptEmission — single transcript entry: clone slug, timestamp, data (raw bytes or structured event)
- TaskArtifact — captured output on completion: key (summary, complete, tokens), value

**access/daos (6 files):**
- daoZone — persist zone state under `~/.khlone/sites/{site-slug}/zones/{zone-slug}/`
- daoCrew — persist clone registry per zone (list of clone refs)
- daoClone — persist clone state: status, series ref, pid, brain slug
- daoTask — persist task state: mode, prompt, status, artifacts, clone ref
- daoCloneCheckpoint — persist checkpoint for daemon-restart resume
- daoCloneTranscript — append-only transcript per clone (jsonl)

each dao uses internal `castIntoDatabaseSchema` / `castFromDatabaseSchema` for disk ↔ domain translation.

**domain operations (2 prod, 2 test):**
- genTaskArtifacts — post-task: prompt clone for summary via onStop hooks from khlone.yml, collect structured output
- setTaskArtifacts — write artifacts to task state via daoTask

**daemon enhancements (0 new files — extend extant daemon):**
- persist state to disk on every mutation:
  - task complete → daoTask.set.upsert (status + artifacts)
  - clone status change → daoClone.set.upsert
  - clone crash → daoCloneCheckpoint.set.append (checkpoint for daemon-restart resume)
  - brainCli.terminal.onData → daoCloneTranscript.set.append (raw output to transcript)
- on daemon startup: check for extant checkpoints → resume from last known state

**cli (1 prod):**
- invokeLog — `khlone log` command: read transcript from disk via daoCloneTranscript, render to terminal. supports `--who` filter.

**acceptance (2 tests):**
- khlone.artifacts — task completes → onStop hooks fire → artifacts captured → `khlone status --task` shows them
- khlone.log — `khlone log` shows transcript, `--who` filters to specific clone

### what this unlocks

| capability | before block F | after block F |
|---|---|---|
| daemon dies | all state lost | state on disk, daemon can resume |
| "what did the clone do?" | must query via IPC while daemon alive | `khlone log` reads transcript from disk |
| task completion data | ephemeral, lost when daemon exits | artifacts persisted per task |
| clone crash + daemon restart | task lost | checkpoint → resume from last known state |
| `khlone status` with dead daemon | "daemon not found" | reads last-known state from disk |

### filesystem layout

```
~/.khlone/
└── sites/
    └── ehmpathy--myrepo/
        └── zones/
            └── feat--auth/
                ├── zone.json
                ├── crew.json
                ├── clones/
                │   ├── foreman.1/
                │   │   ├── state.json
                │   │   ├── checkpoint.json
                │   │   └── transcript.jsonl
                │   └── mechanic.1/
                │       ├── state.json
                │       └── transcript.jsonl
                └── tasks/
                    ├── task-abc-123.json
                    └── task-def-456.json
```

### what NOT to build

- **no orchestrator registry.** `~/.khlone/` exists but has no global site index yet. the orchestrator + site registration deferred to block G.
- **no cross-zone or cross-site state.** persistence is per-zone only.
- **no `khlone list`.** needs orchestrator awareness from block G.

---

## file count

| layer | prod | test | total |
|-------|------|------|-------|
| domain.objects (3: checkpoint, transcript emission, artifact) | 3 | 0 | 3 |
| infra/filesystem (persistence helpers) | 4 | 4 | 8 |
| access/daos (6: zone, crew, clone, task, checkpoint, transcript) | 6 | 0 | 6 |
| domain.operations/task (artifacts) | 2 | 2 | 4 |
| contract/cli (log) | 1 | 0 | 1 |
| acceptance (artifacts, log) | 0 | 2 | 2 |
| **total** | **16** | **8** | **24** |

---

## usecases fulfilled

| usecase | status |
|---------|--------|
| usecase.12: crash recovery (daemon-level) | **yes** — checkpoint + transcript survive daemon death |
| usecase.13: task artifacts | **yes** — onStop hooks capture summary, complete, tokens |
| usecase.14: transcript access | **yes** — `khlone log` reads persisted transcript |

---

## playtests

```sh
# task completes with artifacts
$ khlone status --task task-abc-123
task task-abc-123
├─ mode      act
├─ prompt    "implement auth"
├─ clone     foreman.1
├─ status    ✓ done
└─ artifacts
   ├─ summary   added jwt validation to auth module
   ├─ complete  yes
   └─ tokens    4,521

# transcript review
$ khlone log
# shows transcript for default clone

$ khlone log --who mechanic.1
# shows transcript for mechanic.1

# daemon dies and restarts — state survives
$ khlone status
zone @feat/auth (local)
├─ ● foreman.1  resumed  implement auth (from checkpoint)
└─ queue 1 task
```

---

## done when

- [ ] readJsonFile/writeJsonFile round-trip works with atomic write (tmp + rename)
- [ ] appendJsonlFile/readJsonlFile round-trip works for transcript
- [ ] all 6 DAOs persist and read state under `~/.khlone/`
- [ ] daemon persists task state on completion (daoTask)
- [ ] daemon persists clone state on status change (daoClone)
- [ ] daemon persists checkpoint on clone crash (daoCloneCheckpoint)
- [ ] daemon captures transcript on brainCli.terminal.onData (daoCloneTranscript)
- [ ] genTaskArtifacts runs onStop hooks and captures summary + complete + tokens
- [ ] `khlone log` reads and renders transcript from disk
- [ ] `khlone log --who mechanic.1` filters to specific clone
- [ ] daemon restart after crash resumes from checkpoint
- [ ] `khlone status` with dead daemon reads last-known state from disk
- [ ] acceptance test: task completes → artifacts visible via status
- [ ] acceptance test: `khlone log` shows transcript
