# khlone v0: domain distillation

> domain objects, operations, and daos for site orchestration

---

## 1. domain objects

### 1.1 hierarchy

```
Orchestrator                          # global: all sites on machine
└── Site                              # repo-level: config + zones
    ├── SiteManifest                    # parsed khlone.yml
    └── Zone                          # branch-level: crew + tasks
        ├── ZoneDaemon                # per-zone supervisor process
        ├── Clone                     # enrolled brain instance
        │   ├── CloneAddress          # parsed --who token
        │   └── CloneStatus           # idle | active
        └── Task                      # unit of work
            ├── TaskMode              # ask | act
            ├── TaskStatus            # queued | active | done | failed
            └── TaskArtifact          # Artifact<GitFile> from rhachet-artifact-git
```

### 1.2 entities

entities have identity and lifecycle.

#### Orchestrator

the global machine-level registry. one per machine at `~/.khlone/`.

```ts
interface Orchestrator {
  uuid?: string;
  path: string;                       // e.g., ~/.khlone/
  sites: Ref<typeof Site>[];          // registered site refs
}
class Orchestrator extends DomainEntity<Orchestrator> implements Orchestrator {
  public static unique = ['path'] as const;
}
```

#### Site

the repo-level container. one per `org/repo`.

```ts
interface Site {
  uuid?: string;
  slug: string;                       // e.g., ehmpathy/myrepo
  path: string;                       // gitroot filesystem path
  config: SiteManifest;                 // parsed khlone.yml
}
class Site extends DomainEntity<Site> implements Site {
  public static unique = ['slug'] as const;
  public static nested = { config: SiteManifest };
}
```

#### Zone

a worktree instance. one per branch checkout.

```ts
interface Zone {
  uuid?: string;
  slug: string;                       // e.g., @feat/auth
  address: ZoneAddress;               // full address: org/repo@branch
  site: Ref<typeof Site>;
  host: 'local' | 'cloud';
  path: string;                       // worktree filesystem path
  daemon: ZoneDaemon | null;          // null if not spawned yet
}
class Zone extends DomainEntity<Zone> implements Zone {
  public static unique = ['site', 'slug'] as const;
  public static nested = { address: ZoneAddress, daemon: ZoneDaemon };
}
```

#### Clone

an enrolled brain bound to a role within a zone.

```ts
interface Clone {
  uuid?: string;
  slug: string;                       // e.g., mechanic.1
  zone: Ref<typeof Zone>;
  role: string;                       // role alias (e.g., mechanic)
  roleSlug: string;                   // fully qualified (e.g., ehmpathy/mechanic)
  brain: string;                      // brain alias (e.g., claude)
  brainSlug: string;                  // full brain slug (e.g., claude@anthropic/claude/opus/v4.5)
  index: number;                      // instance index (the .n in mechanic.n)
  status: CloneStatus;
  pid: number | null;                 // brainCli process id (null if not spawned)
  series: string | null;              // BrainSeries ref for continuation
}
class Clone extends DomainEntity<Clone> implements Clone {
  public static unique = ['zone', 'slug'] as const;
}
```

#### Task

a unit of work assigned to a clone.

```ts
interface Task {
  uuid?: string;
  slug: string;                       // e.g., task-abc-123
  zone: Ref<typeof Zone>;
  clone: Ref<typeof Clone>;
  mode: TaskMode;
  prompt: string;
  skill: string | null;               // null if no skill invoked
  status: TaskStatus;
  priority: number;                   // queue position (lower = sooner)
  artifacts: TaskArtifact[];
}
class Task extends DomainEntity<Task> implements Task {
  public static unique = ['slug'] as const;
  public static nested = { artifacts: TaskArtifact };
}
```

#### ZoneDaemon

the per-zone supervisor process that owns all brainCli handles.

```ts
interface ZoneDaemon {
  uuid?: string;
  zone: Ref<typeof Zone>;
  pid: number;                        // daemon process id
  socketPath: string;                 // e.g., /tmp/khlone-zone-feat-auth.sock
  pidPath: string;                    // e.g., /tmp/khlone-zone-feat-auth.pid
  status: 'active' | 'crashed';
}
class ZoneDaemon extends DomainEntity<ZoneDaemon> implements ZoneDaemon {
  public static unique = ['zone'] as const;
}
```

### 1.3 literals

literals are immutable value objects — identity is all their properties.

#### SiteManifest

parsed from `khlone.yml`.

```ts
interface SiteManifest {
  zone: { host: 'local' | 'cloud' };
  crew: {
    hero: { role: string; brain: string };
    roles: Record<string, string>;    // alias → fully qualified slug
    brains: Record<string, string>;   // alias → brain slug
    hooks: {
      onStop: Array<{ prompt: string; artifact: string }>;
    };
  };
}
class SiteManifest extends DomainLiteral<SiteManifest> implements SiteManifest {}
```

#### ZoneAddress

parsed zone address — supports three formats.

```ts
interface ZoneAddress {
  org: string | null;                 // null = current org
  repo: string | null;               // null = current repo
  branch: string;                    // e.g., feat/auth
}
class ZoneAddress extends DomainLiteral<ZoneAddress> implements ZoneAddress {}
```

formats:
- `@branch` → `{ org: null, repo: null, branch }`
- `repo@branch` → `{ org: null, repo, branch }`
- `org/repo@branch` → `{ org, repo, branch }`

#### CloneAddress

parsed `--who` token.

```ts
interface CloneAddress {
  role: string | null;               // null = hero role
  index: '++' | number | null;      // ++ = force-enroll, number = target .n, null = find-or-enroll
  brain: string | null;              // null = hero brain
}
class CloneAddress extends DomainLiteral<CloneAddress> implements CloneAddress {}
```

grammar: `[role][.n][@brain][++]`

#### TaskMode

```ts
type TaskMode = 'ask' | 'act';
```

literal enum. `ask` = no side effects, `act` = full tool use.

#### TaskStatus

```ts
type TaskStatus = 'queued' | 'active' | 'done' | 'failed';
```

#### CloneStatus

```ts
type CloneStatus = 'idle' | 'active';
```

#### TaskArtifact

captured output on task completion. uses `Artifact<GitFile>` from `rhachet-artifact-git` — each artifact is a git-file-backed output (e.g., `summary.md`, `complete.md`, `tokens.md`).

```ts
import { Artifact } from 'rhachet-artifact-git';

type TaskArtifact = Artifact<GitFile>;
```

#### CloneCheckpoint

resume point for crash recovery. captures enough state to restart a task where it left off.

```ts
interface CloneCheckpoint {
  task: Ref<typeof Task>;            // which task was active
  series: string;                    // BrainSeries ref for continuation
  episode: string;                   // BrainEpisode ref for resume
  progress: number;                  // estimated % complete (0-100)
  capturedAt: string;                // iso timestamp of checkpoint
}
class CloneCheckpoint extends DomainLiteral<CloneCheckpoint> implements CloneCheckpoint {}
```

#### CloneTranscriptEmission

a single emission in the clone's transcript log — one recorded event (input sent, output received, tool used, etc).

```ts
interface CloneTranscriptEmission {
  timestamp: string;                 // iso timestamp
  type: 'input' | 'output' | 'tool' | 'error';
  content: string;                   // raw content of the emission
  task: Ref<typeof Task> | null;     // null if no task active (e.g., talk mode)
}
class CloneTranscriptEmission extends DomainLiteral<CloneTranscriptEmission> implements CloneTranscriptEmission {}
```

#### DaemonConnection

a live connection to a zone daemon via unix socket. used for ipc dispatch.

```ts
interface DaemonConnection {
  zone: Ref<typeof Zone>;
  socketPath: string;                // path to unix socket
  connected: boolean;
}
class DaemonConnection extends DomainLiteral<DaemonConnection> implements DaemonConnection {}
```

---

## 2. domain operations

### 2.1 subdomain map

```
src/domain.operations/
├── clone/           # set, get, gen clone; parse --who address
├── config/          # get manifest, get context, get alias slugs
├── daemon/          # set, get, gen daemon; set, gen clone via daemon
├── dispatch/        # dispatch task, dispatch skill, enqueue, disrupt
├── observe/         # setTerminalTo* (watch, talk, detach, await)
├── orchestrator/    # gen orchestrator, set site, get sites
├── site/            # get site, gen site, get zones for site
├── status/          # getOneStatus* per scope, getOneStatusScope
├── task/            # get task, set/gen artifacts, set priority
└── zone/            # set, gen zone; get address, get clones/tasks
```

### 2.2 operations by subdomain

#### clone/

| operation | signature | what |
|-----------|-----------|------|
| `setClone` | `(input: { zone, role, brain, index? }, context) → Clone` | enroll new clone via rhachet, register in zone crew |
| `getOneClone` | `(input: { zone, role, brain }, context) → Clone \| null` | find extant clone by role + brain match |
| `genClone` | `(input: { zone, address: CloneAddress, config: SiteManifest }, context) → Clone` | alias lookup + find extant or auto-enroll |
| `getOneCloneSlug` | `(input: { role, index }) → string` | compute `{role}.{n}` slug |
| `getOneCloneNextIndex` | `(input: { zone, role }) → number` | query zone for max index of role + 1 |
| `getOneCloneAddress` | `(input: { token }) → CloneAddress` | parse `--who` value → CloneAddress |

#### config/

| operation | signature | what |
|-----------|-----------|------|
| `getOneSiteManifest` | `(input: { path }) → SiteManifest` | parse extant `khlone.yml` at gitroot |
| `genSiteManifest` | `(input: { path }) → SiteManifest` | generate new `khlone.yml` with defaults if absent |
| `getOneContextCli` | `(input: { cwd }) → { site: Site; zone: Zone; config: SiteManifest }` | derive cli context from cwd: site, zone, config |
| `getOneRoleSlugByAlias` | `(input: { alias, config: SiteManifest }) → string` | role alias → fully qualified slug |
| `getOneBrainSlugByAlias` | `(input: { alias, config: SiteManifest }) → string` | brain alias → brain slug |

#### daemon/

| operation | signature | what |
|-----------|-----------|------|
| `setZoneDaemon` | `(input: { zone }, context) → ZoneDaemon` | spawn detached daemon process for zone |
| `getOneDaemonConnection` | `(input: { zone }, context) → DaemonConnection` | connect to daemon via unix socket |
| `getOneZoneDaemon` | `(input: { zone }) → ZoneDaemon \| null` | discover daemon via pid file, check liveness |
| `genZoneDaemon` | `(input: { zone }, context) → ZoneDaemon` | derive daemon: find live or spawn fresh |
| `genCloneViaDaemon` | `(input: { clone }, context) → Clone` | ensure clone process alive; respawn via setCloneViaDaemon if dead |
| `setCloneViaDaemon` | `(input: { clone, series }, context) → Clone` | respawn clone's brainCli via BrainSeries continuation |

#### dispatch/

| operation | signature | what |
|-----------|-----------|------|
| `dispatchTask` | `(input: { task, clone }, context) → { dispatched: true }` | send task to clone via daemon ipc → brainCli.ask() or brainCli.act() |
| `dispatchSkill` | `(input: { skill, zone, config }, context) → { clone: Clone; task: Task }` | route skill to capable role, enroll if needed |
| `enqueueTask` | `(input: { task, clone, priority? }, context) → Task` | add task to clone queue via daemon |
| `disruptClone` | `(input: { clone, task }, context) → Task` | pause current task, handle disrupt task immediately |

#### observe/

| operation | signature | what |
|-----------|-----------|------|
| `setTerminalToWatchClone` | `(input: { clone }, context) → void` | set terminal to passive stream mode for clone output |
| `setTerminalToTalkWithClone` | `(input: { clone }, context) → void` | set terminal to interactive mode with clone via brainCli handle |
| `setTerminalToDetach` | `(input: { clone }, context) → void` | release terminal from clone attachment |
| `setTerminalToAwaitTask` | `(input: { task }, context) → string` | block terminal until task completes, emit output |

#### orchestrator/

| operation | signature | what |
|-----------|-----------|------|
| `genOrchestrator` | `(input: { path? }) → Orchestrator` | load or init orchestrator at `~/.khlone/` |
| `setSite` | `(input: { orchestrator, site }, context) → Site` | add site to orchestrator registry |
| `getOneSiteBySlug` | `(input: { orchestrator, slug }) → Site \| null` | lookup site in registry by slug or partial match |
| `getAllSites` | `(input: { orchestrator }) → Site[]` | enumerate all registered sites |

#### site/

| operation | signature | what |
|-----------|-----------|------|
| `getOneSite` | `(input: { path }) → Site` | load site from gitroot: parse config, detect slug |
| `genSite` | `(input: { path, orchestrator }, context) → Site` | find extant in orchestrator or load + register new |
| `getAllZonesForSite` | `(input: { site }) → Zone[]` | enumerate all zones in site |

#### status/

| operation | signature | what |
|-----------|-----------|------|
| `getOneStatusZone` | `(input: { zone }, context) → StatusZone` | zone-level: clones, tasks, progress |
| `getOneStatusSite` | `(input: { site }, context) → StatusSite` | site-level: all zones, clone counts |
| `getOneStatusOrchestrator` | `(input: { orchestrator }, context) → StatusOrchestrator` | orchestrator-level: all sites, activity |
| `getOneStatusTask` | `(input: { task }) → StatusTask` | task detail: mode, artifacts, tokens |
| `getOneStatusClone` | `(input: { clone }) → StatusClone` | clone detail: role, brain, queue |
| `getOneStatusScope` | `(input: { cwd }) → 'zone' \| 'site' \| 'orchestrator'` | smart default: feature → zone, main → site, no-git → orchestrator |

#### task/

| operation | signature | what |
|-----------|-----------|------|
| `genTask` | `(input: { mode, prompt, skill?, clone, zone }) → Task` | assemble task with computed slug |
| `genTaskArtifacts` | `(input: { task, hooks }, context) → TaskArtifact[]` | return extant artifacts or capture via setTaskArtifacts |
| `setTaskArtifacts` | `(input: { task, hooks }, context) → TaskArtifact[]` | run onStop hooks, capture artifacts |
| `getOneTaskSlug` | `() → string` | compute `task-{short-uuid}` slug |
| `setTaskPriority` | `(input: { task, clone }) → Task` | move task to front of queue |

#### zone/

| operation | signature | what |
|-----------|-----------|------|
| `setZone` | `(input: { site, branch, path }, context) → Zone` | bind worktree to zone, enroll hero |
| `genZone` | `(input: { site, branch, path }, context) → Zone` | find extant zone or auto-init (create state files + enroll hero) |
| `getOneZoneAddress` | `(input: { raw }) → ZoneAddress` | parse zone address string → ZoneAddress |
| `getOneZoneByAddress` | `(input: { address: ZoneAddress, orchestrator }, context) → Zone \| null` | look up zone by address |
| `getAllClonesForZone` | `(input: { zone }) → Clone[]` | enumerate all clones in zone |
| `getAllTasksForZone` | `(input: { zone }) → Task[]` | enumerate all tasks in zone |

---

## 3. access layer (daos)

### 3.1 dao structure

```
src/access/daos/
├── daoOrchestrator/
│   └── index.ts              # get/set orchestrator state
├── daoSite/
│   └── index.ts              # get/set/del site in orchestrator registry
├── daoZone/
│   └── index.ts              # get/set/del zone state
├── daoCrew/
│   └── index.ts              # get/set/del clone refs per zone (roster)
├── daoClone/
│   └── index.ts              # get/set/del full clone entity
├── daoCloneCheckpoint/
│   └── index.ts              # get/set/del clone checkpoint
├── daoCloneTranscript/
│   └── index.ts              # get/append clone transcript emissions
└── daoTask/
    └── index.ts              # get/set/del task state per zone
```

### 3.2 persistence layout

all state lives under `~/.khlone/` — no worktree-local state. this enables cross-zone and cross-site access from any directory.

```
~/.khlone/
├── orchestrator.json                                         # daoOrchestrator
└── sites/
    └── {site.slug}/
        ├── site.json                                         # daoSite
        └── zones/
            └── {zone.slug}/
                ├── zone.json                                 # daoZone
                ├── crew.json                                 # daoCrew (RefByUnique<Clone>[])
                ├── task.json                                 # daoTask
                └── clones/
                    └── {clone.slug}/
                        ├── clone.json                        # daoClone
                        ├── checkpoint.jsonl                   # daoCloneCheckpoint
                        └── transcript.jsonl                  # daoCloneTranscript
```

### 3.3 dao contracts

#### daoZone

persists zone state at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/zone.json`.

```ts
const daoZone = {
  get: {
    byRef(input: { path: string }): Promise<Zone | null>;
  },
  set: {
    upsert(input: { zone: Zone; path: string }): Promise<Zone>;
  },
  del: {
    byRef(input: { path: string }): Promise<void>;
  },
};
```

#### daoCrew

persists crew roster at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/crew.json`. stores only refs — full clone state lives in daoClone.

```ts
const daoCrew = {
  get: {
    all(input: { path: string }): Promise<RefByUnique<typeof Clone>[]>;
    bySlug(input: { path: string; slug: string }): Promise<RefByUnique<typeof Clone> | null>;
  },
  set: {
    upsert(input: { ref: RefByUnique<typeof Clone>; path: string }): Promise<RefByUnique<typeof Clone>>;
  },
  del: {
    bySlug(input: { path: string; slug: string }): Promise<void>;
  },
};
```

#### daoTask

persists task state at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/task.json`.

```ts
const daoTask = {
  get: {
    all(input: { path: string }): Promise<Task[]>;
    bySlug(input: { path: string; slug: string }): Promise<Task | null>;
    byClone(input: { path: string; cloneSlug: string }): Promise<Task[]>;
  },
  set: {
    upsert(input: { task: Task; path: string }): Promise<Task>;
  },
  del: {
    bySlug(input: { path: string; slug: string }): Promise<void>;
  },
};
```

#### daoClone

persists full clone entity at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/clones/{clone.slug}/clone.json`. uses internal `castIntoDatabaseSchema` / `castFromDatabaseSchema` for disk ↔ domain translation.

```ts
const daoClone = {
  get: {
    byRef(input: { clonePath: string }): Promise<Clone | null>;
  },
  set: {
    upsert(input: { clone: Clone; clonePath: string }): Promise<Clone>;
  },
  del: {
    byRef(input: { clonePath: string }): Promise<void>;
  },
};
```

#### daoCloneCheckpoint

persists clone checkpoint at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/clones/{clone.slug}/checkpoint.jsonl`.

```ts
const daoCloneCheckpoint = {
  get: {
    latest(input: { clonePath: string }): Promise<CloneCheckpoint | null>;
    all(input: { clonePath: string }): Promise<CloneCheckpoint[]>;
  },
  set: {
    append(input: { checkpoint: CloneCheckpoint; clonePath: string }): Promise<void>;
  },
};
```

#### daoCloneTranscript

persists clone transcript at `~/.khlone/sites/{site.slug}/zones/{zone.slug}/clones/{clone.slug}/transcript.jsonl`.

```ts
const daoCloneTranscript = {
  get: {
    all(input: { clonePath: string }): Promise<CloneTranscriptEmission[]>;
  },
  set: {
    append(input: { emission: CloneTranscriptEmission; clonePath: string }): Promise<void>;
  },
};
```

#### daoOrchestrator

persists orchestrator state at `~/.khlone/orchestrator.json`.

```ts
const daoOrchestrator = {
  get: {
    byRef(input: { path: string }): Promise<Orchestrator | null>;
  },
  set: {
    upsert(input: { orchestrator: Orchestrator; path: string }): Promise<Orchestrator>;
  },
};
```

#### daoSite

persists site registration at `~/.khlone/sites/{site.slug}/site.json`.

```ts
const daoSite = {
  get: {
    all(input: { path: string }): Promise<Site[]>;
    bySlug(input: { path: string; slug: string }): Promise<Site | null>;
  },
  set: {
    upsert(input: { site: Site; path: string }): Promise<Site>;
  },
  del: {
    bySlug(input: { path: string; slug: string }): Promise<void>;
  },
};
```

---

## 4. relationships

### 4.1 containment tree

```
Orchestrator (1)
└── Site (n)
    └── Zone (n)
        ├── ZoneDaemon (0..1)
        ├── Clone (n)
        └── Task (n)
```

### 4.2 references

| from | to | cardinality | key |
|------|----|-------------|-----|
| Site | Orchestrator | n:1 | site registered in orchestrator |
| Zone | Site | n:1 | zone belongs to site |
| ZoneDaemon | Zone | 1:1 | one daemon per zone |
| Clone | Zone | n:1 | clone belongs to zone |
| Task | Zone | n:1 | task belongs to zone |
| Task | Clone | n:1 | task assigned to clone |

### 4.3 value object usage

| literal | used by | purpose |
|---------|---------|---------|
| SiteManifest | Site | parsed khlone.yml |
| ZoneAddress | Zone, zone/ operations | parsed zone address string |
| CloneAddress | clone/ operations | parsed --who token |
| TaskMode | Task | ask vs act enforcement |
| TaskStatus | Task | lifecycle state |
| CloneStatus | Clone | idle vs active |
| TaskArtifact | Task | captured output per hook |
| CloneCheckpoint | daoClone | crash recovery resume point |
| CloneTranscriptEmission | daoClone | transcript log emission |
| DaemonConnection | daemon/ operations | live daemon ipc handle |

### 4.4 external dependencies (via rhachet)

| khlone concept | rhachet concept | relationship |
|----------------|-----------------|--------------|
| Clone.brainSlug | BrainCli slug | khlone resolves alias → slug; rhachet resolves slug → BrainCli instance |
| Clone.series | BrainSeries | cross-context continuation ref |
| Task dispatch | BrainCli.ask() / .act() | task mode maps to BrainCli method |
| Task artifacts (tokens, cost) | BrainOutput.metrics | captured from typed BrainCli response |
| Clone.roleSlug | Role | rhachet role enrollment |

---

## 5. dependency flow

### 5.1 layer dependencies

```
contract/cli/         → domain.operations/, domain.objects/
contract/sdk.ts       → domain.operations/, domain.objects/
domain.operations/    → domain.objects/, access/daos/, infra/
domain.objects/       → (no deps)
access/daos/          → domain.objects/
infra/                → (no deps)
```

### 5.2 subdomain dependencies

```
dispatch/       → clone/, daemon/, task/, config/
observe/        → daemon/, clone/
status/         → zone/, site/, orchestrator/, clone/, task/
zone/           → clone/, config/, daemon/
clone/          → config/ (for alias lookup)
daemon/         → (infra only — brainCli handles, ipc, filesystem)
config/         → (access only — reads khlone.yml)
orchestrator/   → site/
site/           → config/
task/           → (leaf — no subdomain deps)
```

---

## 6. composition: how domains support the wish

### 6.1 usecase.1 — instant dispatch (`khlone act "implement auth"`)

```
invokeAct (contract/cli)
  → getOneContextCli (config/)           # derive site, zone, config from cwd
  → genZone (zone/)                   # find extant or auto-init
  → getOneCloneAddress (who/)           # default: hero
  → genClone (clone/)                 # alias lookup + find-or-enroll hero
  → genZoneDaemon (daemon/)           # ensure daemon is alive
  → genTask (task/)                   # assemble task with mode: act
  → enqueueTask (dispatch/)           # send to daemon via ipc
  → return                            # shell returns immediately
```

### 6.2 usecase.4 — watch mode (`khlone watch`)

```
invokeWatch (contract/cli)
  → getOneContextCli (config/)
  → getOneZoneDaemon (daemon/)
  → getOneDaemonConnection (daemon/)
  → setTerminalToWatchClone (observe/) # stream output via daemon ipc
  → [ctrl+c] → setTerminalToDetach (observe/)
```

### 6.3 usecase.6 — smart status (`khlone status`)

```
invokeStatus (contract/cli)
  → getOneStatusScope (status/)           # pwd → zone | site | orchestrator
  → getOneStatusZone (status/)         # or getOneStatusSite, getOneStatusOrchestrator
    → getAllClonesForZone (zone/)
    → getAllTasksForZone (zone/)
  → render output
```

### 6.4 usecase.8 — clone address (`--who researcher@kimi++`)

```
getOneCloneAddress (who/)
  → CloneAddress { role: researcher, brain: kimi, index: '++' }

genClone (clone/)
  → getOneRoleSlugByAlias (config/)   # researcher → ehmpathy/researcher
  → getOneBrainSlugByAlias (config/)  # kimi → kimi@... brain slug
  → index = '++' → setClone            # force-enroll
  → return Clone
```

### 6.5 usecase.12 — crash recovery

```
daemon detects exit via brainCli.terminal.onExit for clone
  → mark Clone status → 'idle' (via daoCrew)
  → read Clone.series ref
  → genCloneViaDaemon (daemon/)        # ensure clone alive, respawn if dead
  → re-dispatch active task from checkpoint
```

---

## summary

| category | count |
|----------|-------|
| entities | 6 (Orchestrator, Site, Zone, Clone, Task, ZoneDaemon) |
| literals | 10 (SiteManifest, ZoneAddress, CloneAddress, TaskMode, TaskStatus, CloneStatus, TaskArtifact, CloneCheckpoint, CloneTranscriptEmission, DaemonConnection) |
| subdomains | 10 (clone, config, daemon, dispatch, observe, orchestrator, site, status, task, zone) |
| operations | 49 |
| daos | 8 (daoOrchestrator, daoSite, daoZone, daoCrew, daoClone, daoCloneCheckpoint, daoCloneTranscript, daoTask) |

the domain is structured around the containment hierarchy: orchestrator → site → zone → {clone, task}. the daemon subdomain handles process lifecycle (brainCli handles, ipc, crash recovery). the dispatch subdomain routes tasks to clones via the daemon. clone/ handles the `--who` grammar via `getOneCloneAddress`. all brain interaction flows through rhachet's BrainCli contract — khlone never spawns cli processes directly.
