# khlone v0: zoomin — BrainCli via `_topublish`

> develop the BrainCli contract and its first supplier inside khlone, then eject to rhachet once stable

---

## the problem

khlone's entire daemon layer depends on a `BrainCli` contract that does not yet exist in rhachet. rhachet has `BrainRepl` (SDK-level, stateless per call) but not `BrainCli` (terminal process handle with `executor.boot`/`ask`/`act`/`terminal.write`/`terminal.resize`/`terminal.onData`/`terminal.onExit`).

the standard path — "spec it, hand it off, wait for rhachet to publish, install, test, find gaps, file issues, wait for fix, re-install" — creates a brutal cycle:

```
khlone spec → rhachet implement → rhachet publish → khlone install → khlone test
    ↑                                                                      │
    └──── gap found, re-spec ──────────────────────────────────────────────┘
```

each loop costs a version bump, an npm publish, a lockfile update, and context-switch overhead between two repos. for a contract this central to khlone — every clone operation flows through BrainCli — even one iteration wasted is expensive.

**the worse version of this problem:** if khlone develops against a *mock* BrainCli, the mock drifts from reality. mocks lie. the contract looks correct in khlone's tests but breaks on first contact with a real CLI process. mock-based development defers the pain to integration time, when it's hardest to fix.

---

## the solution: `_topublish`

develop the BrainCli interface and its first supplier (claude code) inside khlone under `src/_topublish/`. khlone imports from it directly. once stable — proven against real daemon dispatch, talk mode, crash recovery — eject the module into rhachet as a published package.

this is not a novel pattern. rhachet already does this:

```
rhachet/src/_topublish/
├── file-fns/                           # staged for publish as file-fns package
├── rhachet-brains-anthropic/           # hooks adapter — later published as rhachet-brains-anthropic
└── rhachet-brains-opencode/            # hooks adapter — later published as rhachet-brains-opencode
```

the `_topublish` convention signals: "this code is scoped for extraction. it has its own bounded context. it will become its own package. but right now it lives here because the consumer needs to co-evolve with it."

---

## what lives in `_topublish`

two modules:

### 1. `rhachet` — the interface contract

the BrainCli interface — what khlone codes against. supplier-agnostic, no vendor-specific logic. ejects into rhachet core. **reuses `BrainOutput`, `BrainOutputMetrics`, `BrainEpisode`, and `BrainSeries` from rhachet directly** — these types already exist in the published package. the only new type is `BrainCli` itself.

### 2. `rhachet-brains-anthropic` — the claude supplier (cli layer)

the claude code implementation of BrainCli. spawns `claude` via terminal, maps `-p --input-format stream-json --output-format stream-json` for dispatch mode, maps `claude --resume <session-id>` for interact mode. handles the `executor.boot` lifecycle.

**this module mirrors the extant `rhachet-brains-anthropic` package structure.** the published package already has `domain.operations/atoms/`, `domain.operations/repls/`, and `domain.operations/hooks/`. the cli layer slots in as `domain.operations/clis/` — same pattern, same conventions:

| extant layer | factory | config | slug example |
|---|---|---|---|
| `atoms/` | `genBrainAtom({ slug })` | `CONFIG_BY_ATOM_SLUG` | `claude/haiku`, `claude/opus/v4.5` |
| `repls/` | `genBrainRepl({ slug })` | `CONFIG_BY_REPL_SLUG` | `claude/code`, `claude/code/opus/v4.5` |
| `hooks/` | `genBrainHooksAdapterForClaudeCode()` | — | — |
| **`clis/`** | **`genBrainCli({ slug })`** | **`CONFIG_BY_CLI_SLUG`** | **`claude/code`, `claude/code/opus/v4.5`** |

the cli slug namespace reuses the `claude/code/*` slugs from repls — same model, different grain. the `contract/sdk/index.ts` will export `getBrainClisByAnthropic` alongside the extant `getBrainAtomsByAnthropic` and `getBrainReplsByAnthropic`.

```
src/_topublish/
├── rhachet/
│   ├── domain.objects/
│   │   └── BrainCli.ts                 # the interface — the only new type; imports BrainOutput etc from rhachet
│   ├── domain.operations/
│   │   └── genBrainCli.ts              # factory: brain slug → BrainCli handle (delegates to supplier)
│   └── index.ts                        # re-exports BrainCli + genBrainCli
│
└── rhachet-brains-anthropic/
    ├── domain.operations/
    │   └── clis/                        # mirrors atoms/, repls/, hooks/ structure
    │       ├── BrainCli.config.ts       # CONFIG_BY_CLI_SLUG, AnthropicBrainCliSlug type
    │       ├── genBrainCli.ts           # factory: slug → BrainCli handle via claude terminal
    │       ├── genBrainCli.integration.test.ts
    │       ├── getOneBrainOutputFromStreamJson.ts   # parse nd-JSON events → BrainOutput
    │       ├── getOneBrainOutputFromStreamJson.test.ts
    │       ├── getOneDispatchArgs.ts    # compute CLI args for dispatch mode
    │       ├── getOneDispatchArgs.test.ts
    │       ├── getOneInteractArgs.ts    # compute CLI args for interact mode
    │       └── getOneInteractArgs.test.ts
    └── index.ts                        # exports: genBrainCli, getBrainClisByAnthropic
```

---

## the BrainCli interface

from z1 + z2 (restructured — `executor` scopes process lifecycle, `terminal` scopes terminal i/o, `boot` unifies enboot/reboot):

```ts
/**
 * .what = a handle to a brain CLI process — terminal-managed, mode-switchable, crash-recoverable
 * .why = khlone's daemon needs to spawn, dispatch to, attach to, and recover headless CLI processes
 */
interface BrainCli {
  /** current mode — dispatch (headless, structured i/o) or interact (raw terminal, human-attached) */
  mode: 'dispatch' | 'interact';

  /** cross-context continuation ref — opaque to khlone, managed by the supplier */
  series: string | null;

  // --- dispatch (only valid in dispatch mode) ---

  /**
   * .what = send a prompt with ask semantics — read-only, no side effects
   * .why = maps to task mode 'ask'; the supplier enforces tool restrictions
   * .throws = if mode is not 'dispatch'
   */
  ask(input: { prompt: string }): Promise<BrainOutput>;

  /**
   * .what = send a prompt with act semantics — full tool access, read+write
   * .why = maps to task mode 'act'; the supplier grants full tool permissions
   * .throws = if mode is not 'dispatch'
   */
  act(input: { prompt: string }): Promise<BrainOutput>;

  // --- terminal: terminal i/o (valid in both modes) ---

  terminal: {
    /**
     * .what = write raw bytes to the CLI process stdin
     * .why = in dispatch mode: structured JSON input; in interact mode: raw terminal input relay
     */
    write(data: string): void;

    /**
     * .what = proxy terminal resize to the CLI process
     * .why = interact mode needs SIGWINCH relay for proper terminal layout
     */
    resize(cols: number, rows: number): void;

    /**
     * .what = subscribe to raw bytes from the CLI process stdout
     * .why = in dispatch mode: structured event stream; in interact mode: raw terminal output relay
     */
    onData(cb: (chunk: string) => void): void;

    /**
     * .what = subscribe to CLI process exit
     * .why = crash detection — daemon uses this to trigger boot for recovery
     */
    onExit(cb: (code: number, signal?: string) => void): void;
  };

  // --- executor: process lifecycle ---

  executor: {
    /** the OS process id of the current CLI process — updated on each boot */
    pid: number;

    /**
     * .what = spawn or respawn the CLI process in the target mode
     * .why = unified lifecycle verb — the executor knows whether it has a prior pid/series
     *        and decides internally whether to kill+respawn or fresh-spawn
     */
    boot(input: { mode: 'dispatch' | 'interact' }): Promise<void>;

    /**
     * .what = terminate the CLI process
     * .why = clone shutdown or zone teardown
     */
    kill(): void;
  };
}
```

### BrainOutput, BrainEpisode, BrainSeries

**these types already exist in rhachet** — `BrainOutput`, `BrainOutputMetrics`, `BrainEpisode`, `BrainSeries` are published domain objects. the BrainCli interface imports them directly:

```ts
import type { BrainOutput, BrainEpisode, BrainSeries } from 'rhachet';
```

no re-declaration needed. the `_topublish/rhachet/` module only adds `BrainCli.ts` — the interface itself — and `genBrainCli.ts` — the factory. all other types are consumed as-is from the published rhachet package.

---

## the claude supplier implementation

### dispatch mode: `claude -p`

```
executor.boot({ mode: 'dispatch' })
  → if executor.pid extant → kill current process (SIGTERM, wait for exit)
  → if series extant → append --resume <series.id> to args
  → spawn: claude -p --input-format stream-json --output-format stream-json --allowedTools <tools>
  → set mode = 'dispatch'
  → wire terminal.onData, terminal.onExit
  → capture session_id from first JSON event → set series

ask({ prompt })
  → assert mode === 'dispatch'
  → terminal.write nd-JSON: { type: 'user', message: { role: 'user', content: prompt }, session_id: series.id }
  → collect nd-JSON events until result event
  → parse into BrainOutput
  → return

act({ prompt })
  → same as ask, but the process was spawned with a different --allowedTools set
  → the ask vs act distinction maps to the tool allowlist passed at boot time
```

**ask vs act enforcement:** claude code's `-p` mode does not have a built-in "ask-only" mode. the supplier enforces this via `--allowedTools` — **always explicit, never `--dangerously-skip-permissions`**. the allowlist differs per task mode:

| mode | allowed tools | rationale |
|------|--------------|-----------|
| `ask` | `Read`, `Glob`, `Grep`, `WebSearch`, `WebFetch` | read-only — observe, search, reason; zero side effects |
| `act` | `Read`, `Glob`, `Grep`, `Write`, `Edit`, `Bash(npx rhachet run --skill:*)`, `WebSearch`, `WebFetch` | read+write — edits + rhachet skills only; no open shell access |

**these allowlists are hardcoded for v0.** eventually, they come from the role — just like hooks come from the role via rhachet. a role's briefs and skills will declare which tools it needs, and the supplier blends them into the `--allowedTools` flag at boot time. for v0, the narrow lists above are sufficient to prove the dispatch contract.

**note:** the allowlist is set at *boot* time, not per-prompt. this means a mode switch (ask → act or vice versa) requires `executor.boot({ mode })` — the executor kills the current process and respawns with the correct allowlist. this is already how mode switch works (no CLI supports live tool permission changes), so the cost is zero.

### interact mode: `claude --resume`

```
executor.boot({ mode: 'interact' })
  → if executor.pid extant → kill current process (SIGTERM, wait for exit)
  → capture series.id from handle state
  → spawn: claude --resume <series.id> --allowedTools <act-tools>
  → set mode = 'interact'
  → re-wire terminal.onData, terminal.onExit
  → executor.pid updates to new process pid

executor.boot({ mode: 'dispatch' })     (when already in interact mode)
  → kill current process
  → spawn: claude -p --input-format stream-json --output-format stream-json --resume <series.id> --allowedTools <tools>
  → set mode = 'dispatch'
  → re-wire terminal.onData, terminal.onExit
```

**boot is unified.** the executor decides internally: if no prior pid, fresh-spawn. if extant pid, kill+respawn. if series extant, resume. the caller just says `boot({ mode })` — the executor handles the rest.

### crash recovery

```
terminal.onExit fires (unexpected)
  → series is still valid on the handle (captured before crash)
  → caller (daemon) calls executor.boot({ mode: 'dispatch' })
  → executor sees: no extant pid (process died), series extant → spawns with --resume
  → new episode, same series
```

---

## how khlone imports it

khlone imports from `_topublish` via relative path — standard TypeScript imports, no package indirection:

```ts
// in src/domain.operations/daemon/setZoneDaemon.ts
import { genBrainCli } from '../../_topublish/rhachet';
import type { BrainCli, BrainOutput } from '../../_topublish/rhachet';

// in src/domain.operations/dispatch/dispatchTask.ts
import type { BrainCli } from '../../_topublish/rhachet';
```

**the import path is the ejection seam.** when the module publishes to rhachet, the only change is the import path:

```ts
// before (dev, _topublish)
import { genBrainCli } from '../../_topublish/rhachet';

// after (published)
import { genBrainCli } from 'rhachet';
```

this is a single `sedreplace` across the codebase. the contract is identical — the types, method signatures, and behavior are all developed and tested inside khlone first.

---

## the factory: `genBrainCli`

the factory in `_topublish/rhachet/` routes the brain slug to the correct supplier. the slug format matches the extant rhachet pattern — `claude/code`, `claude/code/opus/v4.5`, etc:

```ts
/**
 * .what = create a BrainCli handle for a given brain slug
 * .why = khlone needs a handle per clone; the factory routes to the correct supplier
 */
export const genBrainCli = (
  input: {
    slug: string;          // e.g., 'claude/code', 'claude/code/opus/v4.5'
    cwd: string;           // worktree path — the CLI's work dir
    role: string;          // role slug — for enrollment context
  },
): BrainCli => {
  // route to supplier by slug prefix
  if (input.slug.startsWith('claude/')) return genBrainCli(input);

  // future: codex, opencode, gemini suppliers
  throw new BadRequestError('no BrainCli supplier for slug', { slug: input.slug });
};
```

the supplier-side factory (`genBrainCli` in `rhachet-brains-anthropic/domain.operations/clis/`) follows the same config pattern as `genBrainAtom` and `genBrainRepl`:

```ts
/**
 * .what = supported claude code cli slugs
 * .why = enables type-safe slug specification with model variants
 */
export type AnthropicBrainCliSlug =
  | 'claude/code'
  | 'claude/code/haiku'
  | 'claude/code/sonnet'
  | 'claude/code/opus'
  | 'claude/code/opus/v4.5';

export const CONFIG_BY_CLI_SLUG: Record<AnthropicBrainCliSlug, BrainCliConfig> = {
  'claude/code': { model: 'claude-sonnet-4-5-20250929', binary: 'claude', spec: ... },
  'claude/code/haiku': { model: 'claude-haiku-4-5-20251001', binary: 'claude', spec: ... },
  'claude/code/sonnet': { model: 'claude-sonnet-4-5-20250929', binary: 'claude', spec: ... },
  'claude/code/opus': { model: 'claude-opus-4-6', binary: 'claude', spec: ... },
  'claude/code/opus/v4.5': { model: 'claude-opus-4-6', binary: 'claude', spec: ... },
};
```

**v0 ships with claude supplier only.** codex, opencode, and gemini suppliers follow the same `domain.operations/clis/` pattern when needed.

---

## why `_topublish` beats mocks

| approach | cost | risk |
|----------|------|------|
| **mock BrainCli** | fast to write, zero integration proof | mock drifts from reality; every "it works" is a lie until real CLI contact; integration bugs surface late when they're hardest to fix |
| **wait for rhachet publish** | blocks khlone dev; each iteration = version bump + publish + install + test | slow cycle; rhachet develops without khlone as a live consumer; contract gaps found late |
| **`_topublish` in khlone** | real implementation, real terminal, real CLI processes; slightly more upfront work | near-zero risk: the contract is battle-tested against khlone's actual daemon before it ever leaves the repo |

the `_topublish` approach inverts the dependency: instead of khlone *wait* for rhachet, khlone *produces* the proven contract and rhachet *receives* it. the contract arrives at rhachet already validated against its primary consumer.

### the mock trap

mocks are temptation because they're fast. but for BrainCli specifically, the mock would need to simulate:

- terminal byte streams (raw terminal output is not trivial to fake)
- nd-JSON event streams with correct message shapes
- session ID capture from JSON output
- process exit codes and signals
- the executor.boot lifecycle (kill + respawn + re-wire)
- mode-dependent behavior (structured vs raw output)

a mock that faithfully reproduces all of this *is* the implementation. the effort is the same — but the mock version gives false confidence while the real version gives proof.

### test doubles for unit tests

this does not mean khlone's unit tests need real CLI processes. unit tests inject a *test double* that satisfies the BrainCli interface — a fake with controlled behavior:

```ts
// in test code — a controlled fake, not a mock
const brainCliFake: BrainCli = {
  mode: 'dispatch',
  series: null,
  executor: {
    pid: 1234,
    boot: async (input) => { brainCliFake.mode = input.mode; },
    kill: () => {},
  },
  ask: async (input) => ({ output: 'test response', metrics: exampleMetrics, ... }),
  act: async (input) => ({ output: 'test response', metrics: exampleMetrics, ... }),
  terminal: {
    write: () => {},
    resize: () => {},
    onData: () => {},
    onExit: () => {},
  },
};
```

this fake is tiny, controlled, and lives in test code. it is NOT a substitute for integration tests against the real supplier — it is a controlled double for unit tests of operations that *accept* a BrainCli handle via dependency injection.

the real supplier (`rhachet-brains-anthropic`) has its own integration tests that prove it works against a live `claude` CLI process.

---

## ejection path

when the BrainCli contract is stable (proven via khlone's daemon, dispatch, talk mode, and crash recovery):

### step 1: extract to rhachet

```sh
# copy the braincli interface into rhachet core
cp -r khlone/src/_topublish/rhachet/ rhachet/src/domain.objects/brain/cli/

# copy the clis/ layer into rhachet-brains-anthropic alongside extant atoms/, repls/, hooks/
cp -r khlone/src/_topublish/rhachet-brains-anthropic/domain.operations/clis/ \
      rhachet-brains-anthropic/src/domain.operations/clis/
```

### step 2: publish rhachet

rhachet publishes with the BrainCli interface as a public export. `rhachet-brains-anthropic` publishes with `genBrainCli` in `domain.operations/clis/` + `getBrainClisByAnthropic` in `contract/sdk/`.

### step 3: update khlone imports

```sh
# one sedreplace — all _topublish imports become package imports
sedreplace --old "from '../../_topublish/rhachet'" --new "from 'rhachet'" --glob "**/*.ts"
sedreplace --old "from '../../_topublish/rhachet-brains-anthropic'" --new "from 'rhachet-brains-anthropic'" --glob "**/*.ts"
```

### step 4: remove `_topublish`

```sh
rm -rf src/_topublish/rhachet/
rm -rf src/_topublish/rhachet-brains-anthropic/
```

the ejection is mechanical. no logic changes, no contract changes, no test changes (except import paths).

---

## file count impact on blueprint

the blueprint currently lists **182 files**. the `_topublish` modules add:

| module | prod files | test files | total |
|--------|-----------|-----------|-------|
| `rhachet` (interface + factory) | 3 | 0 | 3 |
| `rhachet-brains-anthropic` (clis/) | 6 | 4 | 10 |
| **total** | **9** | **4** | **13** |

revised blueprint total: **195 files** (182 + 13).

these 13 files are temporary — they eject to rhachet post-stabilization. but they are real production code with real tests, not throwaway stubs. `BrainOutput`, `BrainOutputMetrics`, `BrainEpisode`, and `BrainSeries` are imported from the published rhachet package — not re-declared.

---

## what changes in the blueprint

### section 1 (filediffs)

add the `_topublish` tree to the filediffs:

```
src/_topublish/
├── rhachet/
│   ├── domain.objects/
│   │   └── [+] BrainCli.ts              # imports BrainOutput, BrainEpisode, BrainSeries from rhachet
│   ├── domain.operations/
│   │   └── [+] genBrainCli.ts
│   └── [+] index.ts
│
└── rhachet-brains-anthropic/
    ├── domain.operations/
    │   └── clis/
    │       ├── [+] BrainCli.config.ts
    │       ├── [+] genBrainCli.ts
    │       ├── [+] genBrainCli.integration.test.ts
    │       ├── [+] getOneBrainOutputFromStreamJson.ts
    │       ├── [+] getOneBrainOutputFromStreamJson.test.ts
    │       ├── [+] getOneDispatchArgs.ts
    │       ├── [+] getOneDispatchArgs.test.ts
    │       ├── [+] getOneInteractArgs.ts
    │       └── [+] getOneInteractArgs.test.ts
    └── [+] index.ts
```

### section 3.1 (external deps)

change rhachet from `[○] retain` to:

```
| `rhachet` | `1.34.0` | [○] retain (dev) — actor enrollment, roles, briefs; BrainCli contract developed in _topublish, ejected post-stabilization |
```

### section 6 (execution phases)

insert as **phase 0.5** (after foundation, before config):

```
phase 0.5: BrainCli contract + claude supplier

1. _topublish/rhachet — interface + domain objects (BrainCli, BrainOutput, BrainSeries, etc)
2. _topublish/rhachet-brains-anthropic — claude code supplier implementation
3. integration tests — prove executor.boot, ask, act, executor.kill against live claude CLI
```

this must come before phase 3 (daemon + dispatch) because the daemon depends on BrainCli handles.

---

## test plan for the supplier

### unit tests

pure logic — no CLI process needed:

| operation | what to test |
|-----------|-------------|
| `getOneDispatchArgs` | CLI args computation for dispatch mode: `-p`, `--input-format stream-json`, `--output-format stream-json`, `--resume` when series extant |
| `getOneInteractArgs` | CLI args computation for interact mode: `--resume` when series extant, no `-p` flag |
| `getOneBrainOutputFromStreamJson` | nd-JSON event parse → BrainOutput: token counts, cost, session_id extraction |

### integration tests

real CLI processes — prove the contract works:

```ts
describe('genBrainCli', () => {
  given('[case1] fresh boot in dispatch mode', () => {
    const brainCli = useBeforeAll(async () => {
      const handle = genBrainCli({ slug: 'claude/code', cwd: tempDir, role: 'test' });
      await handle.executor.boot({ mode: 'dispatch' });
      return handle;
    });
    afterAll(() => brainCli.executor.kill());

    when('[t0] ask is called', () => {
      const result = useThen('it succeeds', async () =>
        brainCli.ask({ prompt: 'respond with exactly: hello' }),
      );

      then('output contains response', () => {
        expect(result.output).toContain('hello');
      });

      then('metrics have token counts', () => {
        expect(result.metrics.size.tokens.input).toBeGreaterThan(0);
        expect(result.metrics.size.tokens.output).toBeGreaterThan(0);
      });

      then('series is captured', () => {
        expect(brainCli.series).not.toBeNull();
      });
    });
  });

  given('[case2] boot from dispatch to interact', () => {
    const brainCli = useBeforeAll(async () => {
      const handle = genBrainCli({ slug: 'claude/code', cwd: tempDir, role: 'test' });
      await handle.executor.boot({ mode: 'dispatch' });
      await handle.ask({ prompt: 'say hello' });
      return handle;
    });
    afterAll(() => brainCli.executor.kill());

    when('[t0] boot to interact mode', () => {
      useThen('boot succeeds', async () => {
        const pidBefore = brainCli.executor.pid;
        await brainCli.executor.boot({ mode: 'interact' });
        return { pidBefore };
      });

      then('mode is interact', () => {
        expect(brainCli.mode).toEqual('interact');
      });

      then('pid changed', () => {
        // pid changes because it's a new process
        expect(brainCli.executor.pid).not.toEqual(0);
      });

      then('series is preserved', () => {
        expect(brainCli.series).not.toBeNull();
      });
    });
  });
});
```

these tests spawn real `claude` CLI processes. they are slow (~5-15s per case) and require `claude` to be installed. they run via `npm run test:integration`, not unit tests.

---

## citations

1. **rhachet `_topublish` pattern** — proven in rhachet@1.34.0: `dist/_topublish/rhachet-brains-anthropic/`, `dist/_topublish/rhachet-brains-opencode/` — hooks adapters developed inside rhachet, staged for extraction
2. **claude code `-p` mode** — claude code docs: `--input-format stream-json`, `--output-format stream-json`, `--resume <session-id>` — documented in z1 interactive modes zoomin `§ claude code`
3. **BrainCli interface** — z1 `§ the revised handle shape` + z2 `§ handle shape with resize` — the full contract with mode constraints and method semantics; restructured here with `executor`/`terminal` nests and unified `boot`
4. **executor.boot model** — z1 `§ the reboot approach` — the insight that no CLI supports live mode-switch, but `executor.boot` hides the kill+respawn behind a stable handle; merged from the prior enboot/reboot split into a single unified verb
5. **ask vs act enforcement via `--allowedTools`** — claude code docs: tool permission control via CLI flags — supplier maps task mode to tool allowlist; never `--dangerously-skip-permissions`; v0 hardcodes narrow lists per mode, future: role-supplied
6. **dependency inversion principle** — Robert C. Martin, *Agile Software Development* (2003) — high-level modules should not depend on low-level modules; both should depend on abstractions

---

## summary

| question | answer |
|----------|--------|
| why not mock BrainCli? | mocks lie; a faithful mock *is* the implementation; mock-based dev defers integration pain |
| why not wait for rhachet? | blocks khlone; each iteration = publish + install + test cycle; rhachet develops without its primary consumer |
| what is `_topublish`? | a bounded module inside khlone that will eject to rhachet once stable — proven pattern from rhachet itself |
| what lives in `_topublish`? | (1) `rhachet` — the interface contract; (2) `rhachet-brains-anthropic` — the claude code supplier |
| how does khlone import it? | relative imports: `from '../../_topublish/rhachet'` |
| how does it eject? | mechanical sedreplace of import paths + file copy to rhachet — zero logic changes |
| what does this add to the blueprint? | 13 files (9 prod, 4 test); phase 0.5 in execution order |
| how is the supplier tested? | integration tests against live `claude` CLI; unit tests for args computation and output parse |

### the mental model

```
development phase (now):
  khlone/src/_topublish/rhachet/               ← the interface
  khlone/src/_topublish/rhachet-brains-anthropic/ ← the claude supplier
  khlone/src/domain.operations/daemon/           ← imports from _topublish

stabilization phase (later):
  prove: daemon dispatch works
  prove: talk mode works
  prove: crash recovery works
  prove: executor.boot lifecycle works

ejection phase (once proven):
  rhachet ← braincli interface
  rhachet-brains-anthropic ← clis/ layer from _topublish
  khlone ← sedreplace imports, delete _topublish
```

the contract arrives at rhachet already battle-tested against its primary consumer. zero surprises.
