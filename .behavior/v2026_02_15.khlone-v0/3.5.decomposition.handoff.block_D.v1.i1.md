# block D: multi-clone (--who, --skill, --when disrupt)

> more than one clone per zone. address them by role, brain, and index. skills route to the capable role. disrupt pauses current work.

---

## read first

1. `./1.vision.md` — sections: "domain model > clone" (identity = role + brain + index), "brain supplier architecture" (brain alias lookup), "domain operations > ask/act" (--who, --skill, --when flags), "hero clone"
2. `./1.vision.zoomin.who-syntax.md` — full --who grammar: `[role][.n][@brain][++]`
3. `./1.vision.zoomin.braincli-lookup.md` — find-or-enroll logic for brainCli handles
4. `./2.1.criteria.blackbox.md` — usecases 3 (queue stack — full: prioritize, disrupt), 8 (clone address — full --who grammar), 9 (skill dispatch)
5. `./3.3.blueprint.v1.i1.md` — codepath 2.2 (ask/act dispatch — clone address parse, genClone, alias lookup), codepath 2.6 (skill dispatch)
6. `./3.2.distill.domain._.v1.i1.md` — clone operations, dispatch operations, task operations
7. `./3.5.decomposition.v1.i1.md` — block D section: what ships, boundaries, file count

---

## prerequisite

**block A must be complete.** the daemon, IPC, hero clone dispatch, and basic task queue must work. this block extends dispatch with clone address, skill route, and disrupt.

---

## scope

### what to build

**clone operations (5 prod, 5 test):**
- getOneCloneAddress — parse `--who` token into `{ role, index, brain, forceEnroll }` via the `[role][.n][@brain][++]` grammar
- genClone — find-or-enroll: alias lookup → find extant clone → or enroll new via rhachet
- getOneClone — find extant clone by role + brain match in the zone
- setClone — enroll new clone: compute next index, rhachet enrollment, register on daemon
- getOneCloneNextIndex — compute next available index for a role in the zone

**dispatch operations (2 prod, 2 test):**
- dispatchSkill — route `--skill` to capable role: enumerate role aliases → check which role knows the skill → 0 match = error, 1 match = route, 2+ match = error (ambiguous)
- disruptClone — `--when disrupt`: pause current task on target clone, execute the disrupt task at once

**task operations (1 prod, 1 test):**
- setTaskPriority — `--prioritize`: move task to front of queue (after current active task)

**IPC messages to add:**
- `disrupt` — cli → daemon: interrupt current work, execute now

**cli updates (0 new files — extend extant invokeAsk/invokeAct):**
- add `--who`, `--skill`, `--when`, `--prioritize` flag support to extant ask/act commands

**acceptance (2 tests):**
- khlone.who — `--who` grammar: role, role.n, @brain, role@brain++, force-enroll, error on mismatch
- khlone.skill — `--skill` routes to correct role, error on ambiguous, error on unknown

### clone identity rule

**clone identity = role + brain.** different role or different brain = different clone. same role + same brain + different index = different instance of the same clone type. the `--who` grammar encodes all three dimensions in a single token.

```
--who mechanic            find mechanic on hero brain
--who mechanic.1          find mechanic.1 (exact index)
--who mechanic++          force-enroll new mechanic on hero brain
--who @grok               find hero role on grok brain
--who researcher@kimi++   force-enroll researcher on kimi brain
```

### what NOT to build

- **no interactive talk.** `--who` on `khlone talk` deferred to block E.
- **no cross-zone dispatch.** all clones in the same zone on the same machine. cross-zone deferred to block G.
- **no persistence.** daemon holds all clone and task state in memory. DAOs deferred to block F.

---

## file count

| layer | prod | test | total |
|-------|------|------|-------|
| domain.operations/clone (5 ops) | 5 | 5 | 10 |
| domain.operations/dispatch (2 ops) | 2 | 2 | 4 |
| domain.operations/task (1 op) | 1 | 1 | 2 |
| acceptance (who, skill) | 0 | 2 | 2 |
| **total** | **8** | **10** | **18** |

---

## usecases fulfilled

| usecase | status |
|---------|--------|
| usecase.3: queue stack (full) | **yes** — enqueue + `--prioritize` + `--when disrupt` |
| usecase.8: clone address | **yes** — full `--who` grammar: `[role][.n][@brain][++]` |
| usecase.9: skill dispatch | **yes** — route to capable role, error on ambiguous |

---

## playtests

```sh
# force-enroll a researcher
$ khlone act "research patterns" --who researcher++
✓ enrolled researcher.1
✓ task-ghi-789 → researcher.1 (@feat/auth)

# disrupt hero with an urgent question
$ khlone ask "status?" --when disrupt
# pauses hero's current task, answers at once

# skill dispatch routes to the capable role
$ khlone ask --skill review.architecture
✓ task-mno-345 → reviewer.1 (skill review.architecture)

# prioritize a task
$ khlone act "hotfix" --prioritize
✓ task-nop-456 → foreman.1 [priority]

$ khlone status
zone @feat/auth (local)
├─ ● foreman.1    claude  67%  2 tasks
├─ ● researcher.1 claude  12%  1 task
└─ ● reviewer.1   claude   5%  1 task
```

---

## done when

- [ ] `--who mechanic++` force-enrolls a new mechanic clone on hero brain
- [ ] `--who @grok` finds or enrolls hero role clone on grok brain
- [ ] `--who mechanic.1` dispatches to exact clone; error if not found
- [ ] `--who mechanic.1@grok` asserts brain match; error on mismatch
- [ ] `--skill review.architecture` routes to the role that knows the skill
- [ ] `--skill code.review` with 2+ capable roles errors with disambiguation
- [ ] `--skill unknown.skill` errors with available skill list
- [ ] `--when disrupt` pauses current task and executes the new task at once
- [ ] `--prioritize` queues task at front (after current active task)
- [ ] acceptance test: --who grammar parse covers all variants
- [ ] acceptance test: --skill routes correctly, errors on ambiguous
