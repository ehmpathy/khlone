# khlone v0: site orchestration

> orchestrate clones via shell-native dispatch

---

## the outcome world

### before

```
$ claude-code
[10 seconds to load...]
[type "implement auth"]
[ui freezes while it thinks]
[keystrokes lag, get lost]
[crash mid-task, lose context]
[restart, re-explain, hope it remembers]
[laptop fans spin, terminal frozen]
[force-quit, lose work, start over]
```

your shell is hijacked. your work is fragile. tokens spent, work lost.

you run one brain-repl at a time. it owns your terminal. you wait. it crashes, you lose all of it. you want to dispatch three tasks — you can't. you want to check on progress without an interrupt — you can't. you want to walk away and come back — you can't.

the repl is in your way.

### after

```
$ khlone act "implement auth"

✓ task-001 → foreman.1 (@feature-auth)
$ _                              # instant, shell is yours

$ khlone act "add tests"         # queue more while first runs

✓ task-002 → foreman.1 (@feature-auth)

$ khlone ask "what files changed?" --watch

lets watch...

            ┬
● foreman.1 │ 3 files changed: auth.ts, jwt.ts, auth.test.ts
^C
$ _                              # ctrl+c, back to shell

$ khlone status

zone @feature-auth (local)
├─ ● foreman.1  67%  implement auth
└─ queue 1 task

$ khlone list zones

site ehmpathy/myrepo
├─ @main           ○ foreman.1
└─ @feature-auth   ● foreman.1 (67%), ○ researcher.1
```

your shell stays yours. work survives crashes. tokens tracked. tasks queue up and execute in order while you do other work.

all tasks queue to the **hero clone** (foreman.1) by default. the hero can delegate to specialists, or you can bypass with `--who researcher++`.

### the "aha" moment

you `khlone act "refactor auth"` and immediately think of three more tasks. you type them all — instant, no wait. they queue up. you walk away.

when you return: first two done, third in progress. the repl crashed once — you didn't notice because khlone restarted it and continued. you type `khlone ask "what changed?" --await >> changelog.md` and the output pipes to a file.

the repl is no longer in your way.

---

## domain model

### hierarchy

```
orchestrator (~/.khlone/)              # global state across machine
└── site (org/repo)                    # shared config, role aliases
    └── zone (@branch)                 # per worktree — independent state
        ├── crew                       # clones in the zone
        │   ├── mechanic.1             # role instance
        │   ├── reviewer.1
        │   └── researcher.1
        └── task                       # tasks in the zone
            ├── task-abc-123           # assigned to mechanic.1
            └── task-def-456           # queued
```

### scopes

| scope | slug example | description |
|-------|--------------|-------------|
| `orchestrator` | — | global: all sites on machine |
| `site` | `ehmpathy/myrepo` | repo-level: zones + config |
| `zone` | `@feat/auth` or `svc-jobs@main` | branch-level: crew + tasks |
| `crew` | `mechanic.1` | clone instances |
| `task` | `task-abc-123` | units of work |
| `skill` | `review.architecture` | role-based skills (via rhachet) |

### domain objects

#### site

the repo-level container. one site per `org/repo`.

```yaml
# khlone.yml (at gitroot)
zone:
  host: local                     # local | cloud

crew:
  hero:
    role: foreman                 # default role — all tasks queue here unless --who
    brain: claude                 # default brain — used unless @brain specified in --who

  roles:                          # role aliases for --who role++
    mechanic: ehmpathy/mechanic
    researcher: ehmpathy/researcher
    reviewer: ehmpathy/reviewer
    foreman: ehmpathy/foreman

  brains:                         # friendly aliases → brain slugs (resolved by rhachet)
    claude: claude@anthropic/claude/opus/v4.5
    codex: codex@openai/codex/v5.3-with-thought
    grok: opencode@xai/grok/code-fast-1
    gemini: gemini@google/gemini/code/v2

  hooks:
    onStop:                       # fires when task ends
      - prompt: "1-line summary"
        artifact: summary
      - prompt: "fully done? yes/no/partial"
        artifact: complete
```

**properties:**
- `slug`: `org/repo` (e.g., `ehmpathy/myrepo`)
- `config`: parsed from `khlone.yml`
- `zones`: active zones in this site

#### zone

a worktree instance. one zone per branch checkout.

**properties:**
- `slug`: `@branch` (e.g., `@feat/auth`, `@main`)
- `address`: `org/repo@branch` (full), `repo@branch` (same org), `@branch` (same site)
- `site`: parent site ref
- `crew`: clones in this zone
- `daemon`: zone daemon process (owns all brainCli handles in the zone)
- `host`: `local` | `cloud`
- `path`: worktree filesystem path

**state files:**
```
{worktree}/.khlone/.bind/
├── zone.yml      # zone config snapshot
├── crew.yml      # active clones
└── task.yml      # tasks + artifacts
```

#### clone

an enrolled brain — a brain bound to a role within a zone. runs headless via the zone daemon.

**properties:**
- `slug`: `{role}.{n}` (e.g., `mechanic.1`, `foreman.1`)
- `role`: role alias (resolves to fully qualified `repo/role` via rhachet)
- `brain`: brain alias (khlone resolves alias to brain slug; rhachet resolves slug to BrainCli)
- `status`: `idle` | `active`
- `task`:
  - `focus`: current task (`choice` + `progress`)
  - `queue`: queued tasks
- `pid`: process id of headless cli (owned by zone daemon)
- `series`: `BrainSeries` ref for cross-context continuation

**brain is immutable per clone.** a clone is bound to its brain — different brain = different clone. if you want a different brain, you get a different clone (e.g., `--who @grok` finds or enrolls a foreman on grok, while `foreman.1` on claude continues). this preserves session continuity, checkpoint state, and BrainSeries.

**brain resolution:**
- defaults to `crew.hero.brain` from `khlone.yml`
- override via `@brain` in `--who` (e.g., `--who @grok`, `--who researcher@kimi++`) — feeds into find-or-enroll
- the brain slug must reference a supplier with BrainCli support; clones require a BrainCli handle that khlone can manage (spawn, send, attach, detach, kill). the slug format is defined by rhachet and the brain suppliers.

**state files:**
```
{worktree}/.khlone/clones/{clone.id}/
├── state.json        # current status
├── checkpoint.json   # resume point
└── transcript.jsonl  # full log
```

#### hero clone

the **hero** is the default clone for a zone — all tasks queue here unless `--who` specifies otherwise.

**two patterns:**

1. **delegator hero** (recommended)
   - hero role is a foreman/orchestrator
   - foreman receives tasks and delegates to specialists
   ```yaml
   crew:
     hero:
       role: foreman    # foreman delegates to mechanic, researcher, etc
   ```

2. **direct hero**
   - hero role is a doer (e.g., `mechanic`)
   - user manually delegates via `--who` when specialist needed
   ```yaml
   crew:
     hero:
       role: mechanic   # user handles delegation via --who
   ```

**dispatch flow:**
```sh
# these are equivalent — both queue to hero
$ khlone act "implement auth"

✓ task-001 → foreman.1

$ khlone act "implement auth" --who hero

✓ task-002 → foreman.1

# explicit delegation bypasses hero
$ khlone act "research patterns" --who researcher++

✓ enrolled researcher.1
✓ task-003 → researcher.1
```

#### skill

role-based skills (via rhachet). the most frictionless way to dispatch work:

```sh
$ khlone act --skill review.architecture
```

khlone will:
1. find which role knows `review.architecture`
2. enroll a clone of that role (if needed)
3. run the skill
4. store output in the clone's artifacts

**dispatch logic for `--skill`:**
1. if hero knows the skill → hero gets it
2. if exactly one role knows it → that role gets it (enroll if needed)
3. if multiple roles know it → failfast, ask for disambiguation
4. if zero roles know it → failfast, inform user

**examples:**
```sh
# hero (foreman) knows review.architecture → foreman handles it
$ khlone ask --skill review.architecture

✓ task-001 → foreman.1 (skill review.architecture)

# only researcher knows research.patterns → enrolls researcher
$ khlone ask --skill research.patterns

✓ enrolled researcher.1
✓ task-002 → researcher.1 (skill research.patterns)

# multiple roles know code.review → failfast
$ khlone ask --skill code.review

✗ ambiguous  code.review known by [reviewer, mechanic]
  ↳ use --who reviewer++ or --who mechanic++

# no role knows unknown.skill → failfast
$ khlone ask --skill unknown.skill

✗ no role knows skill unknown.skill
  ↳ available  review.architecture, research.patterns, ...
```

#### task

a unit of work assigned to a clone. every task has a **mode** that governs what the clone is permitted to do.

- **`ask`** — the clone may read files, reason, and respond, but must not modify files, state, or infrastructure. no side effects.
- **`act`** — the clone may read *and* write. edits code, creates files, runs commands, changes state.

the mode is the enforcement boundary.

**properties:**
- `slug`: `task-{short-uuid}` (e.g., `task-abc-123`)
- `mode`: `ask` | `act`
- `prompt`: the user's request (or skill ref)
- `skill`: optional skill that was invoked
- `clone`: assigned clone ref
- `status`: `queued` | `active` | `done` | `failed`
- `priority`: queue position
- `artifacts`: captured on completion (summary, complete, tokens)

---

### brain supplier architecture

khlone depends on rhachet's **BrainCli** contract — a stable, pit-of-success interface for CLI-level brain process management that `rhachet-brains-*` supplier packages implement.

**the contract: BrainCli**

rhachet defines three brain interfaces:
- **BrainAtom** — one-shot inference via SDK (stateless, no tools)
- **BrainRepl** — multi-turn agentic loop via SDK (stateful, tools, read+write)
- **BrainCli** — CLI process with PTY management (spawn, send, attach, detach, kill)

khlone requires **BrainCli** for all clones. every clone is a BrainCli instance — a headless CLI process managed via PTY.

the BrainCli interface has two methods that map directly to khlone's task modes:

| BrainCli method | khlone task mode | permitted actions |
|------------------|------------------|-------------------|
| `.ask()` | `ask` | read files, reason, respond — no mutation tools |
| `.act()` | `act` | read, write, edit, run commands — full tool use |

**dependency inversion:**

```
khlone                           rhachet                          vendor clis
  │                                │                                │
  │  depends on BrainCli          │                                │
  │  contract (stable, typed)      │                                │
  │ ──────────────────────────────►│                                │
  │                                │  rhachet-brains-anthropic      │
  │                                │  implements BrainCli           │
  │                                │  via claude cli + PTY          │
  │                                │ ──────────────────────────────►│
  │                                │                                │
  │                                │  rhachet-brains-opencode       │
  │                                │  implements BrainCli           │
  │                                │  via opencode cli + PTY        │
  │                                │ ──────────────────────────────►│
```

khlone never spawns cli binaries directly. it calls `brainCli.ask()` or `brainCli.act()`, and the supplier package handles vendor-specific PTY spawn, stdin/stdout parse, and process lifecycle.

**supplier packages (current state, 2025-05):**

| package | BrainAtom | BrainRepl | BrainCli | notes |
|---------|-----------|-----------|----------|-------|
| `rhachet-brains-anthropic` | yes | yes | yes | cli: `claude` via PTY |
| `rhachet-brains-openai` | yes | yes | yes | cli: `codex` via PTY |
| `rhachet-brains-opencode` | yes | no | yes | cli: `opencode` via PTY |
| `rhachet-brains-google` | yes | yes | yes | cli: `gemini` via PTY |
| `rhachet-brains-xai` | yes | no | no | atom only — no cli yet |
| `rhachet-brains-chutes` | yes | no | no | atom only — open-source models |
| `rhachet-brains-togetherai` | yes | no | no | atom only — open-source models |

**the cli and atom are separate concerns.** a brain slug can pair any cli with any atom model — e.g., the opencode cli can run atoms from xai, google, anthropic, or any vendor. the BrainCli supplier may differ from the atom supplier.

**only suppliers with BrainCli can power clones.** atom-only suppliers cannot power clones directly — clones require a BrainCli handle that khlone can spawn, manage, and attach/detach headlessly. PTY management is internal to the BrainCli supplier. however, atom-only suppliers can still provide the model that a cli runs (e.g., xai's grok atom via the opencode cli).

**brain output metrics:**

every BrainCli call returns `BrainOutput` with structured metrics:

```ts
BrainOutput {
  output: TOutput;               // the result
  metrics: {
    size: {
      tokens: { input, output, cache: { get, set } };
      chars: { input, output, cache: { get, set } };
    };
    cost: {
      time: IsoDuration;
      cash: { total: IsoPrice; deets: { input, output, cache } };
    };
  };
  episode: BrainEpisode;         // continuation unit
  series: BrainSeries | null;    // cross-context continuation (cli only)
}
```

this is how khlone captures token counts, cost, and duration per task — directly from the BrainCli contract.

**continuity model:**

| rhachet term | scope | description |
|--------------|-------|-------------|
| `BrainExchange` | atomic | one request + one response |
| `BrainEpisode` | context window | chain of exchanges within one context |
| `BrainSeries` | cross-context | chain of episodes across context windows (cli only) |

khlone uses `BrainSeries` for clone session persistence — when a clone's context fills up, the cli continues in a new episode within the same series.

**brain alias resolution flow:**

`@brain` in `--who` resolves against the registered aliases in khlone.yml — so users never need to know the full brain slug. the alias maps to a brain slug, which rhachet resolves into a BrainCli instance.

```
user: khlone act "task" --who @grok

1. khlone parses --who → { role: hero, brain: grok, index: null }
2. khlone looks up "grok" in khlone.yml → opencode@xai/grok/code-fast-1
3. khlone passes the brain slug to rhachet for resolution
4. rhachet resolves the slug → returns BrainCli instance
5. clone calls brainCli.act({ prompt, role, ... })
```

the brain slug format is defined by rhachet and the brain suppliers. the examples above (e.g., `opencode@xai/grok/code-fast-1`) are illustrative — the key properties are:
- a cli (like opencode) can power any vendor's atoms (e.g., xai/grok, google/gemini)
- the BrainCli supplier may differ from the atom supplier
- users only see friendly names (claude, grok, codex) — the slug is an implementation detail

**why this matters:**

| without rhachet | with rhachet |
|-----------------|--------------|
| khlone spawns `claude` binary directly | khlone calls `brainCli.act()` |
| parse PTY stdout ad-hoc | get typed `BrainOutput` back |
| each brain needs custom PTY adapter | all brains share one BrainCli contract |
| cli changes break khlone | cli changes are absorbed by supplier |
| cost/token data is ad-hoc | cost/token data is structured via `BrainOutputMetrics` |
| session resume is vendor-specific | session resume is via `BrainSeries` |

---

### daemon architecture

khlone runs **one daemon per zone**. the daemon owns all brainCli handles in that zone — it is the session manager that eliminates the need for tmux, screen, or any external terminal multiplexer.

```
zone (@feat/auth)
└── daemon (pid: 1000)
    ├── brainCli: foreman.1 (pid: 1001)    [separate brainCli handle]
    ├── brainCli: mechanic.1 (pid: 1002)   [separate brainCli handle]
    └── brainCli: researcher.1 (pid: 1003) [separate brainCli handle]
```

**what the daemon does:**

| capability | how |
|------------|-----|
| spawn brainCli | via rhachet, on clone enroll |
| persist sessions | daemon owns the brainCli handle — survives shell exit |
| attach/detach | `khlone talk` attaches, `/exit` detaches |
| stream output | `khlone watch` reads brainCli stdout via `brainCli.terminal.onData` |
| dispatch tasks | writes to brainCli via `brainCli.terminal.write()` |
| crash recovery | detects exit via `brainCli.terminal.onExit`, respawns via BrainSeries continuation |
| IPC | listens on unix socket `/tmp/khlone-zone-{zone-id}.sock` |

**brainCli lookup — find-or-enroll:**

when a task is dispatched, khlone parses `--who` and checks whether the target clone already has a live brainCli:

```
1. khlone parses --who → { role, brain, index }
2. khlone resolves role alias (hero default or --who role → role slug via khlone.yml)
3. khlone resolves brain alias (hero default or --who @brain → brain slug via khlone.yml)
4. khlone resolves target clone (role + brain + index)
   — clone identity = role + brain + index
   — different role or different brain = different clone
5. if index is ++:
   → force-enroll: spawn new clone via rhachet, assign next index
6. if index is null:
   → find extant clone with role + brain match
   → if found: reuse extant brainCli
   → if not found: auto-enroll new clone via rhachet, assign next index
7. if index is .n:
   → find clone by exact slug (role.n)
   → if @brain specified: assert brain matches
   → if not found: error
8. khlone dispatches task via brainCli.ask() or brainCli.act()
```

rhachet is only called when no extant brainCli serves the clone. rhachet is the factory; khlone is the fleet manager.

**crash isolation invariant:** a clone crash must never take down the daemon or peer clones. each clone has its own separate brainCli handle — the daemon detects crashes via `brainCli.terminal.onExit` per clone and restarts just that clone via BrainSeries continuation (new episode, same series).

**why per-zone, not per-clone daemons:** per-clone daemons multiply the `O(clones)` overhead on the daemon layer (each node.js process ~30-50MB base). at scale (10 zones × 3 clones), per-clone daemons consume ~1.2GB in daemon overhead alone. per-zone keeps it at ~400MB. the brain CLIs are the heavy resource consumers — no reason to double the process count.

---

## domain operations

### core verbs

| verb | arguments | what it does |
|------|-----------|--------------|
| `init` | — | bind worktree to zone, enroll default clone |
| `ask` | `"prompt"` | creates an **ask** task (no side effects), return to shell |
| `act` | `"prompt"` | creates an **act** task (modifies files/state), return to shell |
| `list` | `scope` | enumerate resources: `sites\|zones\|crews\|tasks` |
| `status` | `scope?` | inspect state (smart defaults based on pwd) |
| `watch` | — | stream clone output (passive observe) |
| `talk` | — | interactive session (active converse) |
| `log` | — | view transcript |

### smart defaults for `status`

`khlone status` auto-selects scope based on pwd:

| pwd context | defaults to | shows |
|-------------|-------------|-------|
| feature branch | `zone` | clones, tasks, progress |
| main branch | `site` | all zones in repo |
| not a git repo | `orchestrator` | all sites on machine |

### operation: init

bind current worktree to a zone.

**behavior:**
1. find `khlone.yml` at gitroot
2. detect worktree branch
3. create `.khlone/.bind/` state files
4. enroll hero clone (per `crew.hero` config)
5. return zone

**implicit init:** first `ask` or `act` triggers init automatically.

```sh
$ khlone act "implement auth"

✓ init @feature-auth → foreman.1
✓ task-abc-123 → foreman.1 (@feature-auth)
```

### operation: ask

creates an **ask task**. the clone reads, reasons, and responds, but the task forbids modification of files, state, or infrastructure. no side effects. **defaults to hero** unless `--who` specified.

**options:**
- `--who [role][.n][@brain][++]` — clone address (e.g., `--who mechanic.1`, `--who @grok`, `--who researcher@kimi++`)
- `--when enqueue` — add to queue (default)
- `--when disrupt` — interrupt current work, handle now
- `--watch` — queue, then stream output
- `--talk` — queue, then interactive mode
- `--zone ADDR` — dispatch to different zone
- `--await` — block until done, emit output to stdout

**examples:**
```sh
$ khlone ask "what files changed?"              # → queues to hero
$ khlone ask "explain auth flow" --watch        # → hero, then stream
$ khlone ask "status?" --when disrupt           # → interrupt hero's current task
$ khlone ask "research this" --who researcher++ # → enroll researcher, bypass hero
$ khlone ask "summarize" --await >> summary.md  # → hero, block until done
```

### operation: act

creates an **act task**. the clone reads, reasons, and *acts* — edits code, creates files, runs commands, changes state. **defaults to hero** unless `--who` specified.

**options:** same as `ask`, plus:
- `--prioritize` — queue at front (after current task)

**examples:**
```sh
$ khlone act "implement jwt validation"         # → queues to hero
$ khlone act "refactor db" --watch              # → hero, then stream
$ khlone act "hotfix prod bug" --prioritize     # → hero, jump the queue
$ khlone act "review auth" --who reviewer++     # → enroll reviewer, bypass hero
$ khlone act "fix lint" --zone @hotfix-typo     # → hero in different zone
```

### operation: watch

stream clone output (passive observe).

**behavior:**
- streams filtered progress output
- `ctrl+c` returns to shell
- clone continues work

**examples:**
```sh
$ khlone watch                    # watch default clone
$ khlone watch --who reviewer.1   # watch specific clone
$ khlone act "task" --watch       # queue then watch
```

### operation: talk

interactive session with clone (active converse).

**behavior:**
- drops into clone's repl session
- direct input/output with clone
- `/exit` returns to shell
- queue pauses while you talk

**examples:**
```sh
$ khlone talk                     # talk to default clone
$ khlone talk mechanic.1          # talk to specific clone
$ khlone act "task" --talk        # queue then talk
```

### operation: list

enumerate resources at a given scope.

**scopes:** `sites` | `zones` | `crews` | `tasks`

**examples:**
```sh
$ khlone list sites              # all sites on machine

orchestrator ~/.khlone/
├─ ehmpathy/myrepo       2 zones │ ●3 active
└─ ehmpathy/other-repo   1 zone  │ ○ idle

$ khlone list zones              # all zones in current site

site ehmpathy/myrepo
├─ @main           ○ mechanic.1
├─ @feature-auth   ● mechanic.1 (67%), ○ researcher.1
└─ @hotfix-typo    ● mechanic.1 (12%)

$ khlone list crews              # all clones in current zone

zone @feature-auth (local)
├─ ● mechanic.1     claude   67%   2 tasks
├─ ○ reviewer.1     claude    —    0 tasks
└─ ● researcher.1   claude   12%   1 task

$ khlone list tasks              # all tasks in current zone

zone @feature-auth (local)
├─ ✓ task-abc-123  "setup project"    mechanic.1   4,521 tok
├─ ● task-def-456  "implement auth"   mechanic.1   67%
└─ ◌ task-ghi-789  "add tests"        mechanic.1   queued
```

### operation: status

inspect state at a given scope — smart defaults based on pwd.

**examples:**
```sh
$ khlone status                  # auto-selects based on pwd

zone @feature-auth (local)
│
├─ ● mechanic.1  67%  implement auth
│  ├─ ✓ setup project structure
│  │  ├─ summary   created src/ with auth module skeleton
│  │  ├─ complete  yes
│  │  └─ tokens    4,521
│  └─ ● implement jwt validation
│
└─ queue 2 tasks

$ khlone status orchestrator     # explicit: all sites

orchestrator ~/.khlone/
├─ ehmpathy/myrepo       2 zones │ ●3 clones │ $4.21 today
└─ ehmpathy/other-repo   1 zone  │ ○ idle

$ khlone status --task task-abc-123   # specific task

task task-abc-123
├─ mode      act
├─ prompt    "setup project structure"
├─ clone     mechanic.1
├─ status    ✓ done
└─ artifacts
   ├─ summary   created src/ with auth module skeleton
   ├─ complete  yes
   └─ tokens    4,521
```

---

## flags reference

### scope flags (universal)

| flag | narrows to | example |
|------|-----------|---------|
| `--site SLUG` | specific repo | `--site ehmpathy/svc-jobs` |
| `--zone ADDR` | specific zone | `--zone @feat/auth` or `--zone svc-jobs@main` |
| `--who [role][.n][@brain][++]` | clone address | `--who mechanic.1`, `--who @grok`, `--who researcher@kimi++` |
| `--task SLUG` | specific task | `--task task-abc-123` |

**zone address formats:**
```
@branch                    # current site, this branch
repo@branch                # same org, different repo
org/repo@branch            # full address
```

### behavior flags (ask/act)

| flag | purpose |
|------|---------|
| `--skill NAME` | invoke skill (routes to capable role) |
| `--when enqueue` | add to queue (default) |
| `--when disrupt` | interrupt current work, handle now |
| `--prioritize` | queue at front (after current task) |
| `--watch` | stream output after dispatch (passive) |
| `--talk` | interactive mode after dispatch (active) |
| `--await` | block until done, emit output to stdout |

---

## output legend

| symbol | indicates |
|--------|-----------|
| `●` | active (in progress) |
| `○` | idle (available) |
| `✓` | done (completed) |
| `◌` | queued (awaited) |
| `✗` | failed (error) |
| `→` | enqueued to |
| `├─` `└─` `│` | tree structure |

---

## cross-scope dispatch

### the pattern

```
khlone <verb> [args] [--site X] [--zone X] [--who X] [--task X]
```

you can be anywhere and reach into any scope. the orchestrator at `~/.khlone/` knows about all sites you've touched, so cross-scope address just works.

### playtest: multi-repo coordination

**scenario:** you're in `app-hometools-native`, and coordinate work across multiple backend services.

```sh
# check what's active in svc-jobs (site-level status)
$ khlone status --site svc-jobs

site ahbode/svc-jobs
├─ @main          ○ foreman.1
└─ @feat/invoice  ● foreman.1 (45%)

# ask a question about auth in a different repo
$ khlone ask 'how does jwt validation work here' \
    --zone svc-auth@main \
    --who researcher++ \
    --await >> notes/auth-flow.md

# dispatch work to svc-jobs while you stay in current repo
$ khlone act 'add unit tests for invoices' \
    --zone svc-jobs@feat/invoice \
    --who mechanic.1

✓ task-xyz-789 → mechanic.1 (svc-jobs@feat/invoice)
```

### playtest: zone hop

**scenario:** you're on `@main`, but need to check on and dispatch to feature branches.

```sh
# see all zones in current site
$ khlone list zones

site ehmpathy/myrepo
├─ @main          ○ mechanic.1
├─ @feat/auth     ● mechanic.1 (67%), ○ researcher.1
├─ @feat/invoice  ● mechanic.1 (12%)
└─ @hotfix/typo   ✓ mechanic.1

# dispatch urgent fix to hotfix branch
$ khlone act 'fix the typo in README' \
    --zone @hotfix/typo \
    --who mechanic++ \
    --prioritize

✓ enrolled mechanic.2
✓ task-abc-123 → mechanic.2 (@hotfix/typo) [priority]

# watch progress from here
$ khlone watch --zone @hotfix/typo --who mechanic.2

lets watch...

             ┬
● mechanic.2 │ edit README.md
● mechanic.2 │ fix typo: "recieve" → "receive"
^C
```

### playtest: research delegation

**scenario:** you need answers from multiple codebases without context switch.

```sh
# ask three repos about their patterns, pipe to files
$ khlone ask 'how do you handle rate limits' \
    --zone svc-api-gateway@main \
    --who researcher++ \
    --await >> research/rate-limits-gateway.md

$ khlone ask 'how do you handle rate limits' \
    --zone svc-jobs@main \
    --who researcher++ \
    --await >> research/rate-limits-jobs.md

$ khlone ask 'how do you handle rate limits' \
    --zone svc-notifications@main \
    --who researcher++ \
    --await >> research/rate-limits-notifications.md
```

### playtest: orchestrator overview

**scenario:** start of day — see all repos at a glance.

```sh
# from anywhere (even outside a git repo)
$ khlone status

orchestrator ~/.khlone/
├─ ahbode/app-hometools     2 zones │ ●1 active │ $2.15 today
├─ ahbode/svc-jobs          3 zones │ ●2 active │ $4.82 today
├─ ahbode/svc-auth          1 zone  │ ○ idle
└─ ehmpathy/domain-objects  1 zone  │ ○ idle

# drill into a specific site
$ khlone status --site ahbode/svc-jobs

site ahbode/svc-jobs
├─ zones    3
├─ clones   ●4 active  ○2 idle
├─ tasks    ✓5 done  ●2 active  ◌3 queued
└─ tokens   45,210 today
```

### why this works

the orchestrator (`~/.khlone/`) maintains a registry of all sites:

```
~/.khlone/
├── orchestrator.yml          # global config
├── sites/
│   ├── ahbode--svc-jobs/     # symlink or state ref
│   ├── ahbode--svc-auth/
│   └── ehmpathy--myrepo/
```

when you use `--site svc-jobs`, khlone:
1. looks up the full slug in the orchestrator registry
2. resolves to the site's gitroot path
3. dispatches the command there
4. returns output to your current shell

no need to `cd` anywhere. your shell stays yours.

---

## mental model

### how you'd describe khlone to a friend

> "khlone is a dispatcher for ai code assistants. `ask` creates an ask task — questions, explanations, research — no side effects. `act` creates an act task — edits files, writes code, changes state. both are instant. the command queues and i'm back in my shell. the brain cli runs headless in the background via rhachet's BrainCli contract — claude, codex, opencode, whatever. i can watch output, talk directly, or just let it work. if it crashes, khlone restarts it. my shell stays mine."

### analogies

| analogy | fit |
|---------|-----|
| **construction site** | orchestrator manages sites, zones have crews of clones, each with a role |
| **print spooler** | queue tasks, execute in order, survive crashes |
| **tmux for ai** | daemon owns brainCli sessions — persist, attach, detach — no tmux needed |
| **job control** | `&` and `fg` and `bg`, but with crash recovery via BrainSeries |

### term map

| you might say | khlone term | construction analog |
|---------------|-------------|-------------------|
| "the machine" | orchestrator | general contractor's office |
| "the repo" | site | job site |
| "the branch" | zone | work zone on the site |
| "the workers" | crew | the crew on that zone |
| "a worker" | clone | a tradesperson (mechanic, reviewer, etc) |
| "do this" | act | work order |
| "answer this" | ask | request for information |
| "what's the status" | status | site walk |
| "show me what they're up to" | watch | observe the crew |
| "let me talk to them" | talk | pull a worker aside |

---

## evaluation

### goals solved

| goal | solved? |
|------|---------|
| instant input | yes — 0ms keystrokes, local buffer |
| shell stays yours | yes — ask/act returns immediately |
| survive crashes | yes — queue persists, checkpoint resumes |
| work while busy | yes — queue stacks tasks |
| see progress | yes — watch streams filtered output |
| raw repl access | yes — talk gives direct access |
| zone awareness | yes — always shows which zone |
| token track | yes — transcript archived per clone |
| task visibility | yes — artifacts (summary, complete) per task |
| cross-zone dispatch | yes — `--zone` from any terminal |
| cross-site dispatch | yes — `--site` from anywhere |
| shell-native output | yes — `--await` pipes to files |

### pros

| benefit | details |
|---------|---------|
| instant input | 0ms keystroke latency |
| shell stays yours | ask/act and return |
| queue tasks | don't wait for completion |
| crash recovery | auto-restart via BrainSeries continuation, resume from checkpoint |
| headless efficiency | no ui overhead, daemon owns brainCli handles |
| multi-clone | parallel workers |
| multi-zone | parallel worktrees |
| multi-site | dispatch across repos from anywhere |
| transcript archive | review, token track |
| no infra required | works locally |

### edgecases

| edgecase | mitigation |
|----------|------------|
| checkpoint accuracy | conservative checkpoints, may redo some work |
| headless support | not all repls support it — fallback to hidden window |
| multi-clone resources | per-zone daemon keeps overhead flat; brain CLIs are the real cost |
| daemon crash | all clones in zone lose supervisor — mitigated by thin daemon + orchestrator health monitor |
| vendor cli changes | absorbed by rhachet-brains-* suppliers; khlone depends only on BrainCli contract |
| supplier lacks BrainCli | failfast with clear error — atom-only and repl-only suppliers cannot power clones |
| new brain vendor | add new rhachet-brains-* package; khlone config unchanged |

### pit of success

| risk | mitigation |
|------|------------|
| forget zone | always shown in output, auto-resolved from cwd |
| lose work on crash | queue persists, checkpoint resumes, BrainSeries continues |
| repl hangs terminal | repl is headless via daemon, shell never blocked |
| orphan clones | `.bind/` shared across terminals |
| forgot to init | implicit init on first ask/act |
| enroll unknown role | role++ only works for defined aliases |

---

## what ships in v0

| capability | description |
|------------|-------------|
| `khlone init` | bind worktree to zone, enroll hero |
| implicit init | first ask/act triggers init |
| hero clone | default task target per `crew.hero` config |
| `khlone ask "..."` | creates ask task, return |
| `khlone act "..."` | creates act task, return |
| `khlone list scope` | enumerate: `sites\|zones\|crews\|tasks` |
| `khlone status [scope]` | inspect state with smart defaults |
| `khlone watch` | stream clone output |
| `khlone talk` | interactive session |
| `khlone log` | transcript review |
| `--who [role][.n][@brain][++]` | clone address — role, brain, index in a single token |
| `--skill NAME` | invoke skill, route to capable role |
| `--when` | enqueue vs disrupt |
| `--watch` | stream output after dispatch |
| `--talk` | interactive mode after dispatch |
| `--zone` | cross-zone dispatch |
| `--site` | cross-site dispatch |
| `--await` | block + emit output |
| smart status defaults | pwd-aware scope selection |
| orchestrator state | `~/.khlone/` tracks all sites |
| task artifacts | summary, complete, tokens |
| onStop hooks | capture artifacts on task end |
| per-zone daemon | owns all brainCli handles, eliminates tmux dependency |
| find-or-enroll brainCli | reuse extant or spawn fresh via rhachet |
| clone crash isolation | separate brainCli handle per clone, daemon detects exit via `brainCli.terminal.onExit` and restarts |
| queue persistence | survives shell exit — daemon owns processes |
| crash recovery | auto-restart via BrainSeries continuation |
| headless execution | daemon-managed brainCli handles, low resource |
| transcript capture | full log per clone |

---

## summary

**khlone v0** = site orchestration for clones

- **orchestrator** → **site** → **zone** → **crew** + **task** hierarchy
- **hero clone** receives all tasks by default (delegator or direct doer)
- **ask** creates ask tasks / **act** creates act tasks — instant return
- **brains via rhachet** — all clones use `BrainCli` contract from `rhachet-brains-*` suppliers (PTY is internal to the supplier)
- **list/status** with scope argument and smart defaults
- **`--who` clone address** — `[role][.n][@brain][++]` addresses role, brain, and index in a single token
- **cross-scope dispatch** via universal `--site`, `--zone`, `--who` flags
- **watch/talk** observation modes
- **per-zone daemon** owns all brainCli handles — eliminates tmux, enables persist/attach/detach
- **find-or-enroll** brainCli lookup — reuse extant or spawn fresh via rhachet
- **crash recovery** via BrainSeries continuation (new episode, same series)
- **clone crash isolation** via separate brainCli handles — one crash never takes down peers
- **headless execution** via daemon-managed brainCli handles
- **shell-native** output with `--await`

```sh
$ khlone act "implement auth"

✓ task-001 → foreman.1 (@feature-auth)
$ _                              # that's it. shell is yours.

$ khlone act "research patterns" --who researcher++

✓ task-002 → researcher.1 (@feature-auth)

$ khlone status                  # smart default: zone scope

zone @feature-auth
├─ ● foreman.1    67%
├─ ● researcher.1 12%
└─ queue 1 task
```
