# khlone v0: zoomin — claude code auth for headless dispatch

> how khlone's daemon authenticates `claude -p` subprocesses — and why it can reuse extant machine credentials

---

## the question

khlone's daemon spawns `claude -p` as headless subprocesses via `executor.boot()`. these processes need valid auth to reach the anthropic API. can the daemon reuse auth that already exists on the machine? or does each subprocess need its own credentials?

specifically:
1. where does claude code store its auth?
2. will a headless subprocess read it?
3. does the browser OAuth flow work from a daemon?
4. what's the v0 auth strategy?

---

## findings

### where claude code stores auth

| platform | location | mechanism |
|----------|----------|-----------|
| linux | `~/.claude/.credentials.json` | plaintext JSON — `accessToken`, `refreshToken`, `expiresAt`, `subscriptionType` |
| macos | macOS Keychain (service: `"Claude Code-credentials"`) | encrypted keychain entry — `.credentials.json` gets deleted on macOS |
| all | `~/.claude/config.json` | `primaryApiKey` field — for console API key auth |
| all | `ANTHROPIC_API_KEY` env var | overrides all other auth methods when set |

the `~/.claude/.credentials.json` on linux contains:

```json
{
  "claudeAiOauth": {
    "accessToken": "...",
    "refreshToken": "...",
    "expiresAt": 1771564112485,
    "scopes": ["..."],
    "subscriptionType": "...",
    "rateLimitTier": "..."
  }
}
```

### five auth backends

| method | how it works | headless-compatible? |
|--------|-------------|---------------------|
| **claude.ai OAuth** (Teams/Enterprise/Max) | browser-based OAuth 2.0 + PKCE via `claude login`; stores tokens in `.credentials.json` | yes — subprocess reads extant tokens; no — cannot initiate the browser flow |
| **console API key** | stored in `config.json` via `claude login` | yes |
| **`ANTHROPIC_API_KEY` env var** | set the var, claude uses it directly; pay-as-you-go API rates | yes — the simplest headless path |
| **Amazon Bedrock** | `AWS_ACCESS_KEY_ID` / `AWS_SECRET_ACCESS_KEY` / `AWS_SESSION_TOKEN` | yes |
| **Google Vertex AI** | `GOOGLE_APPLICATION_CREDENTIALS` + `ANTHROPIC_VERTEX_PROJECT_ID` | yes |

**priority rule:** when `ANTHROPIC_API_KEY` is set, it overrides all other auth. the `/status` command shows which auth method is active.

### will a headless subprocess reuse extant auth?

**yes.** on linux, `claude -p` reads `~/.claude/.credentials.json` from the filesystem. any process that runs as the same user and inherits the same `$HOME` will use the same tokens. no interactive prompt needed — the subprocess just reads the file.

**caveat — token expiry:** OAuth access tokens have a limited lifetime (the `expiresAt` field). on the *same machine where you ran `claude login`*, claude code refreshes the token via the `refreshToken` when it expires. on a machine where the `.credentials.json` was *copied*, refresh does not work — it fails with a 401 [^1].

for khlone v0 (local-only dispatch on the same machine), this is not a concern. the daemon runs on the same machine where the human authenticated. token refresh works.

### does the browser OAuth flow work from a daemon?

**no.** `claude login` opens a browser for interactive consent. a daemon cannot do this.

but **it doesn't need to.** the human authenticates once via `claude login` in their terminal. the result persists at `~/.claude/.credentials.json`. khlone's daemon — which runs as the same user on the same machine — reads the same file. no re-auth needed until the token expires, at which point the human re-runs `claude login`.

this is the exact same model as `git` — you authenticate once, credentials persist, all subprocesses reuse them.

### the `apiKeyHelper` escape hatch

claude code supports a `apiKeyHelper` field in `~/.claude/settings.json`:

```json
{
  "apiKeyHelper": "my-credential-command.sh"
}
```

the command runs every 5 minutes (configurable via `CLAUDE_CODE_API_KEY_HELPER_TTL_MS`) or on 401. it returns a fresh API key to stdout. this is the enterprise-friendly approach for credential rotation — and a natural fit for khlone's future cloud dispatch (where the daemon runs on a remote machine and needs credentials from a vault).

---

## v0 auth strategy

### the simple path: reuse extant OAuth

for v0 (local dispatch only), khlone does **zero auth work**. the daemon inherits the same `$HOME` and user as the human who runs `khlone act`. claude code's subprocess reads `~/.claude/.credentials.json` — the same file the human's interactive `claude` session uses.

**precondition:** the human has run `claude login` at least once on the machine. khlone can verify this:

```
genBrainCli → executor.boot()
  → supplier checks: does ~/.claude/.credentials.json exist? is accessToken present?
  → if no → BadRequestError: 'claude code not authenticated; run `claude login` first'
  → if yes → spawn claude -p (it reads the credentials itself)
```

**no env var forwarding needed.** no API key management needed. no credential storage in khlone. the auth is claude code's concern — khlone just spawns the process and lets it authenticate itself.

### the override path: `ANTHROPIC_API_KEY`

if the human sets `ANTHROPIC_API_KEY` in their shell environment, khlone's daemon inherits it (via the shell that launched the daemon). `claude -p` will use the API key and skip OAuth entirely.

this path is useful for:
- CI/CD environments
- pay-as-you-go API access (no subscription needed)
- environments where `claude login` cannot run

khlone does not need to handle this explicitly — it's transparent. the daemon inherits the env, the subprocess inherits the env, claude code sees the key.

### future: cloud dispatch + `apiKeyHelper`

when khlone supports cloud zones (remote machines), the daemon runs on a machine where the human has *not* run `claude login`. in this case:

1. **`ANTHROPIC_API_KEY`** passed to the remote daemon via secure env injection (e.g., from a vault)
2. **`apiKeyHelper`** configured on the remote machine to fetch credentials from a secrets manager

this is a post-v0 concern. the auth model scales naturally — khlone never manages credentials itself, it delegates to claude code's auth layer or the environment.

---

## what this means for the BrainCli contract

**auth is not part of the BrainCli interface.** the supplier handles auth internally — it spawns the CLI process, the CLI process authenticates itself via its own credential chain. khlone never sees tokens, keys, or OAuth flows.

the only auth-related concern for khlone is the **precondition check**: before the first `executor.boot()`, verify that auth is plausible (credentials file exists or `ANTHROPIC_API_KEY` is set). this prevents a confusing error 30 seconds into a task when the CLI process fails to authenticate.

```ts
// in the claude supplier's boot() implementation
const credentialsPath = path.join(os.homedir(), '.claude', '.credentials.json');
const hasCredentials = await fileExists(credentialsPath);
const hasApiKey = !!process.env.ANTHROPIC_API_KEY;

if (!hasCredentials && !hasApiKey)
  throw new BadRequestError(
    'claude code not authenticated. run `claude login` or set ANTHROPIC_API_KEY.',
  );
```

---

## environment variables reference

### auth

| variable | purpose |
|----------|---------|
| `ANTHROPIC_API_KEY` | direct API key — overrides all other auth |
| `ANTHROPIC_AUTH_TOKEN` | alternative auth token |
| `CLAUDE_CODE_OAUTH_TOKEN` | inject OAuth token directly — overrides `.credentials.json` |
| `ANTHROPIC_BASE_URL` | custom API endpoint URL |
| `CLAUDE_CODE_API_KEY_HELPER_TTL_MS` | TTL for `apiKeyHelper` credential cache (default: 5 min) |

### cloud providers

| variable | purpose |
|----------|---------|
| `AWS_ACCESS_KEY_ID` | Bedrock auth |
| `AWS_SECRET_ACCESS_KEY` | Bedrock auth |
| `AWS_SESSION_TOKEN` | Bedrock temporary credentials |
| `AWS_BEARER_TOKEN_BEDROCK` | bearer-based Bedrock access |
| `GOOGLE_APPLICATION_CREDENTIALS` | path to GCP service account JSON |
| `ANTHROPIC_VERTEX_PROJECT_ID` | GCP project for Vertex AI |

---

## citations

1. [^1]: [GitHub issue #21765](https://github.com/anthropics/claude-code/issues/21765) — OAuth refresh token not honored on copied credentials; subprocess auth fails with 401 after token expiry on non-original machines
2. [Claude Code authentication docs](https://code.claude.com/docs/en/authentication) — official auth flow documentation: OAuth, API key, Bedrock, Vertex
3. [Claude Code headless mode docs](https://code.claude.com/docs/en/headless) — `-p` mode auth behavior: inherits credentials from `~/.claude/` or env vars
4. [Claude Code settings docs](https://code.claude.com/docs/en/settings) — `apiKeyHelper` configuration and TTL
5. [GitHub issue #7100](https://github.com/anthropics/claude-code/issues/7100) — remote/headless auth workarounds: SSH port forwarding for OAuth callback
6. [GitHub issue #10039](https://github.com/anthropics/claude-code/issues/10039) — macOS deletes `.credentials.json` in favor of Keychain; cross-platform credential location divergence
7. [GitHub issue #11587](https://github.com/anthropics/claude-code/issues/11587) — auth conflict when both `CLAUDE_CODE_OAUTH_TOKEN` and `apiKeyHelper` are set

---

## summary

| question | answer |
|----------|--------|
| can khlone reuse extant auth? | yes — `claude -p` reads `~/.claude/.credentials.json` as the same user on the same machine |
| does the browser OAuth flow work from a daemon? | no — but it doesn't need to; the human authenticates once, the daemon reuses the credentials |
| what's the v0 auth strategy? | zero auth work — daemon inherits the same `$HOME`, claude code authenticates itself |
| does khlone need to manage credentials? | no — auth is claude code's concern; khlone just checks the precondition (credentials exist or env var set) |
| what about cloud dispatch? | post-v0 — `ANTHROPIC_API_KEY` via vault injection or `apiKeyHelper` on the remote machine |
| is auth part of the BrainCli contract? | no — the supplier handles it internally; khlone only does a precondition check before first boot |
