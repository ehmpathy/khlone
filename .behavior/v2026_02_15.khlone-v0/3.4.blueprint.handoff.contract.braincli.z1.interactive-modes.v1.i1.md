# khlone v0: zoomin — brain CLI interactive vs non-interactive modes

> how claude code, opencode, and codex handle headless dispatch vs interactive sessions — and what this means for khlone's daemon + talk mode

> **note:** z2 (`3.4.blueprint.handoff.contract.braincli.z2.talk-mode.v1.i1.md`) builds on this doc. z2 establishes a daemon-owned byte relay model for talk mode: the daemon calls `brainCli.reboot({ mode: 'interact' })` and relays raw PTY bytes between the IPC client and the brain CLI. the `enboot`/`reboot` model from this doc is retained — z2 adds the interact mode and byte relay protocol. the per-CLI research findings in this doc remain valid.

---

## the question

the handoff contract assumes khlone can:
1. dispatch tasks to a headless CLI process (ask/act)
2. later attach a user's terminal to that same process for interactive talk mode
3. detach and continue headless

but do these CLIs actually support that? can you start headless and then "attach" interactively? or are interactive and non-interactive fundamentally separate invocation modes?

this matters because khlone's daemon spawns brainCli processes and needs to support both `khlone act` (headless dispatch) and `khlone talk` (interactive session) on the **same clone**.

---

## findings per CLI

### claude code (`claude`)

**two separate invocation modes — cannot switch between them on a live process.**

| mode | invocation | behavior |
|---|---|---|
| interactive | `claude` or `claude "prompt"` | full TUI/REPL, owns the terminal |
| non-interactive | `claude -p "prompt"` (print mode) | process prompt, emit output, exit |

**non-interactive (`-p`) details:**
- stdout format controlled by `--output-format`: `text` (default), `json` (structured with `result`, `session_id`, metadata), `stream-json` (nd-JSON event stream)
- stdin format controlled by `--input-format`: `text` (default), `stream-json` (nd-JSON messages for multi-turn)
- multi-turn over a single process: yes, via `--input-format stream-json` — send JSON messages with `{type, message, session_id}` on stdin, receive nd-JSON events on stdout
- session continuation across invocations: `--resume <session-id>` or `--continue` (most recent)
- session ID available in JSON output — capture and pass back for continuation
- max turns: `--max-turns N` (print mode only)
- permissions: `--dangerously-skip-permissions` or `--allowedTools "Tool1,Tool2"`

**multi-turn stdin protocol (stream-json):**
```json
{"type":"user","message":{"role":"user","content":"what files changed?"},"session_id":"abc-123"}
```

**key constraint:** no way to attach a TUI to a live `-p` process. to go interactive, you must start a new `claude` process (can resume the same session via `--resume`).

**session continuation model:**
- sessions stored in `~/.claude/sessions/`
- `--resume <id>` works in both interactive and `-p` modes
- `-p` mode returns `session_id` in JSON output — the "series" ref for khlone

### opencode (`opencode`)

**separate modes, BUT has a unique serve + attach model.**

| mode | invocation | behavior |
|---|---|---|
| interactive | `opencode` | full TUI (Bubble Tea) |
| non-interactive | `opencode run "prompt"` | process prompt, emit output, exit |
| headless server | `opencode serve` | HTTP server, no TUI |
| ACP server | `opencode acp` | JSON-RPC over stdio (nd-JSON) |

**non-interactive (`run`) details:**
- prompt passed as CLI arguments (not stdin — piped stdin has known issues)
- stdout format: `--format default` (text) or `--format json` (raw JSON events)
- session continuation: `--continue` (last), `--session <id>` (specific), `--fork` (branch)

**the serve + attach model (unique to opencode):**
- `opencode serve` starts a persistent headless backend on an HTTP port
- `opencode run --attach http://localhost:4096 "prompt"` sends tasks to the server (non-interactive)
- `opencode attach http://localhost:4096` connects a full TUI to the server (interactive)
- this is the **only CLI that supports true attach-to-headless** — start headless, attach interactive later, detach, re-attach

**ACP protocol (Agent Client Protocol):**
- `opencode acp` speaks JSON-RPC over nd-JSON on stdio
- structured bidirectional protocol — closest to a "drive it programmatically" interface
- follows the ACP v1 spec (agentclientprotocol.com)

**key insight:** opencode's serve model is exactly what khlone's daemon does — a persistent backend that accepts tasks and supports interactive attach/detach. the architecture validates khlone's approach.

### codex (`codex`)

**two separate invocation modes — no attach, no serve.**

| mode | invocation | behavior |
|---|---|---|
| interactive | `codex` or `codex "prompt"` | full TUI |
| non-interactive | `codex exec "prompt"` | process prompt, emit output, exit |

**non-interactive (`exec`) details:**
- prompt as positional argument, or `-` to read from stdin: `echo "fix bug" | codex exec -`
- stdout: plain text (final message only, progress on stderr)
- `--json` / `--experimental-json`: JSONL event stream (`thread.started`, `turn.*`, `item.*`, `error`)
- `--output-schema <path>`: constrain final response to JSON Schema
- `--full-auto`: auto-approve edits (low friction)
- `--dangerously-bypass-approvals-and-sandbox` / `--yolo`: bypass all safeguards
- `-o <path>`: write final message to file

**session continuation:**
- `codex resume --last` or `codex resume <session-id>` for interactive resume
- `codex exec resume --last "new task"` for non-interactive resume
- transcripts stored locally

**key constraint:** no serve, no attach. each `codex exec` is a standalone process. the only way to "continue" is to start a new process that resumes a session.

---

## cross-CLI comparison

### can you start headless and later attach interactively?

| CLI | answer | mechanism |
|---|---|---|
| claude code | **no** — must start a new process, can resume same session via `--resume` | session-id-based continuation |
| opencode | **yes** — `opencode serve` + `opencode attach` | HTTP server + TUI client |
| codex | **no** — must start a new process, can resume via `codex resume` | transcript-based continuation |

### stdin protocol for headless dispatch

| CLI | protocol |
|---|---|
| claude code | `--input-format stream-json`: nd-JSON messages on stdin with `{type, message, session_id}` |
| opencode | prompt as CLI args for `run`; JSON-RPC nd-JSON on stdio for `acp` |
| codex | prompt as positional arg or `-` for raw text stdin; no structured JSON input |

### stdout protocol for headless output

| CLI | protocol |
|---|---|
| claude code | `--output-format stream-json`: nd-JSON event stream (filterable with jq) |
| opencode | `--format json`: raw JSON events; ACP: JSON-RPC nd-JSON responses |
| codex | `--json`: JSONL event stream (`thread.started`, `turn.*`, `item.*`) |

### session continuation across invocations

| CLI | mechanism | ref type |
|---|---|---|
| claude code | `--resume <session-id>` | UUID (from JSON output `session_id` field) |
| opencode | `--session <id>` or `--continue` | session ID |
| codex | `codex exec resume <id> "prompt"` | session ID |

---

## what this means for khlone

### the core tension

khlone's handoff contract assumed a single BrainCli process that supports both headless dispatch (ask/act) and interactive attach (talk). **no CLI supports this natively** — except opencode's serve model, which is an HTTP server rather than a PTY process.

the actual landscape is:
- all three CLIs have a non-interactive mode that accepts a prompt and emits output
- all three support session continuation via session IDs
- none support live mode-switch on a single process (except opencode serve, via a different architecture)

### the reboot approach: `enboot` + `reboot`

the raw findings show that no CLI supports live mode-switch on a single OS process. but **that's an implementation detail the BrainCli abstraction can hide.**

the insight: `brainCli.reboot({ mode })` kills the current OS process, captures the series ref, and respawns in the new mode — all behind the same handle. khlone never sees the process churn. it just sees a mode change.

**two methods:**
- `brainCli.enboot({ mode: 'dispatch' })` — initial boot (first spawn)
- `brainCli.reboot({ mode: 'interactive' | 'dispatch' })` — mode switch (kill + respawn with same series)

**what happens under the hood (supplier's concern, not khlone's):**

```
brainCli.enboot({ mode: 'dispatch' })
  → supplier spawns: claude -p --input-format stream-json --output-format stream-json
  → or: codex exec --json
  → or: opencode run --format json
  → handle is live, pid updated, onData/onExit re-wired

brainCli.reboot({ mode: 'interactive' })
  → supplier captures series ref (session_id)
  → supplier kills current process
  → supplier spawns: claude --resume <session-id>
  → or: opencode attach <server-url>
  → or: codex resume <session-id>
  → handle stays the same, pid updated, onData/onExit re-wired

brainCli.reboot({ mode: 'dispatch' })
  → supplier captures series ref
  → supplier kills interactive process
  → supplier spawns headless process --resume <session-id>
  → handle stays the same, pid updated
```

**why this is the right abstraction:**

| concern | who owns it |
|---|---|
| "I need this clone in talk mode now" | khlone (calls `reboot({ mode: 'interactive' })`) |
| "how do I switch claude from `-p` to interactive?" | supplier (kills process, respawns with `--resume`) |
| "how do I switch opencode from `run` to `attach`?" | supplier (uses serve + attach internally) |
| "how do I switch codex from `exec` to interactive?" | supplier (kills process, respawns with `resume`) |
| "what's the session ID format?" | supplier (opaque to khlone) |

khlone's daemon never needs to know how the mode switch works. it just calls `reboot` and the handle comes back alive in the new mode. the series ref is the bridge — the supplier uses it to ensure the new process continues where the old one left off.

### the clone lifecycle with enboot/reboot

```
khlone act "implement auth"
  → daemon calls brainCli.enboot({ mode: 'dispatch' })
  → daemon calls brainCli.act({ prompt: 'implement auth' })
  → brainCli.onData fires — daemon captures output

khlone act "add tests"
  → daemon calls brainCli.act({ prompt: 'add tests' })      (same handle, no reboot)

khlone talk
  → daemon calls brainCli.reboot({ mode: 'interactive' })   (supplier kills + respawns)
  → daemon pipes user terminal ↔ brainCli PTY
  → user types /exit
  → daemon calls brainCli.reboot({ mode: 'dispatch' })  (back to headless)

khlone act "task 3"
  → daemon calls brainCli.act({ prompt: 'task 3' })         (same handle, series continued)
```

**the handle is stable across reboots.** khlone holds one `brainCli` ref per clone for the clone's entire lifetime. the pid changes on reboot, the mode changes, but the handle identity is stable. `onData` and `onExit` callbacks are re-wired automatically by the supplier after each reboot.

### crash recovery fits naturally

crash recovery is just a reboot that khlone triggers instead of the user:

```
brainCli.onExit fires (unexpected crash)
  → daemon calls brainCli.reboot({ mode: 'dispatch' })
  → supplier respawns with same series ref
  → daemon re-dispatches active task
```

the supplier handles the series ref capture internally — khlone doesn't need to fish it out of the crash output. the handle already knows its series.

### watch mode is unaffected

`brainCli.onData` fires in both `dispatch` and `interactive` modes. the daemon captures all output regardless of mode. `khlone watch` just forwards the onData stream to the user's terminal.

in `dispatch` mode, onData emits the structured output stream (nd-JSON events, etc). in `interactive` mode, onData emits raw terminal output. the daemon archives both — the format difference is a supplier concern.

### the revised handle shape

```ts
interface BrainCli {
  pid: number;                                         // updated on each reboot
  mode: 'dispatch' | 'interactive';                // current mode
  series: string | null;                               // current series ref

  // lifecycle
  enboot(input: { mode: 'dispatch' | 'interactive' }): Promise<void>;
  reboot(input: { mode: 'dispatch' | 'interactive' }): Promise<void>;
  kill(): void;

  // dispatch (only valid in dispatch mode)
  ask(input: { prompt: string }): Promise<BrainOutput>;
  act(input: { prompt: string }): Promise<BrainOutput>;

  // PTY (valid in both modes)
  write(data: string): void;
  onData(cb: (chunk: string) => void): void;
  onExit(cb: (code: number, signal?: string) => void): void;
}
```

**mode constraints:**
- `ask()` and `act()` are only valid in `dispatch` mode — call in `interactive` mode throws
- `write()` is valid in both modes — in `dispatch` mode it writes to the structured stdin; in `interactive` mode it writes raw PTY input
- `onData` fires in both modes — in `dispatch` mode it emits structured events; in `interactive` mode it emits raw terminal output
- `reboot()` can be called in either mode — it always kills the current process and respawns in the target mode

---

## summary

| question | answer |
|---|---|
| can you switch a live CLI process between interactive and headless? | no — but `reboot` hides this behind the BrainCli abstraction |
| can you dispatch tasks headless? | yes — all three CLIs support it via `dispatch` mode |
| can you continue sessions across reboots? | yes — all three via series ref (session ID) |
| how does talk mode work? | `brainCli.reboot({ mode: 'interactive' })` — same handle, new process |
| how does watch mode work? | `brainCli.onData` fires in both modes — daemon forwards to user |
| how does crash recovery work? | `brainCli.reboot({ mode: 'dispatch' })` — same as any other reboot |

### the mental model

```
clone lifecycle:

  brainCli.enboot({ mode: 'dispatch' })          # initial spawn
  brainCli.act({ prompt: 'implement auth' })          # task 1
  brainCli.act({ prompt: 'add tests' })               # task 2 (same process)
  brainCli.reboot({ mode: 'interactive' })            # talk mode (kill + respawn)
  ... user interacts via PTY ...
  brainCli.reboot({ mode: 'dispatch' })           # back to headless (kill + respawn)
  brainCli.act({ prompt: 'fix lint' })                # task 3 (series continued)
  [crash] → brainCli.reboot({ mode: 'dispatch' }) # auto-recovery (same as any reboot)
  brainCli.act({ prompt: 'resume: fix lint' })        # re-dispatch
  brainCli.kill()                                      # clone shutdown
```

### what this changes in the handoff contract

1. **§1.1 (spawn):** replace `genBrainCli` with handle creation + `brainCli.enboot({ mode })` — the handle is created first, then booted
2. **§1.2 (ask/act dispatch):** add mode constraint — only valid in `dispatch` mode
3. **§1.5 (crash detection):** crash recovery is just `reboot({ mode: 'dispatch' })` — same mechanism as talk→dispatch transition
4. **§1.8 (BrainSeries):** series is internal to the handle — khlone can read it but doesn't need to pass it on reboot. the handle manages its own series across reboots.
5. **§4.5 (handle shape):** updated with `enboot`, `reboot`, `mode`, and mode constraints on `ask`/`act`
6. **no separate `genBrainCliInteractive` needed** — `reboot({ mode: 'interactive' })` covers it
