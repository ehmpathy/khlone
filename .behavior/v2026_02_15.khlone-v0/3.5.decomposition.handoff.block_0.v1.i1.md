# block 0: BrainCli contract + claude supplier

> deliver the BrainCli interface and its first supplier (claude code), tested against a live CLI process. khlone's daemon will code against this handle.

---

## read first

these docs provide the context you need. read them in this order:

1. `./1.vision.md` — sections: "brain supplier architecture", "daemon architecture", "domain model > clone"
2. `./3.3.blueprint.v1.i1.md` — section: "3. contracts > 3.1 external dependencies" (rhachet types to import)
3. `./3.3.blueprint.z2.braincli-topublish.v1.i1.md` — the `_topublish` pattern: develop in-repo, eject later
4. `./3.4.blueprint.handoff.contract.braincli.v1.i1.md` — the full BrainCli contract handoff (what khlone requires from rhachet)
5. `./3.4.blueprint.handoff.contract.braincli.z1.interactive-modes.v1.i1.md` — dispatch vs interact mode mechanics
6. `./3.4.blueprint.handoff.contract.braincli.z2.talk-mode.v1.i1.md` — talk mode byte relay requirements
7. `./3.3.blueprint.z3.braincli-auth.v1.i1.md` — auth strategy: zero auth work, reuse extant credentials
8. `./3.3.blueprint.z4.braincli-auth-refresh.v1.i1.md` — token refresh mechanics (context only, no action needed for v0)
9. `./3.1.research.claims._.v1.i1.md` — validated claims about claude code CLI behavior (nd-JSON, stream events, flags)
10. `./3.1.research.access._.v1.i1.md` — claude code CLI access patterns and flags

---

## scope

### what to build

**location:** `src/_topublish/` inside khlone repo

**`_topublish/rhachet/`** — the interface contract (3 prod files):
- `BrainCli.ts` — the interface type with three surfaces:
  - `terminal: { onData, onExit, write, resize }` — raw i/o surface
  - `executor: { boot, kill, pid, series }` — process lifecycle
  - `ask({ prompt })` / `act({ prompt })` — dispatch methods that return `BrainOutput`
- `genBrainCli.ts` — factory: brain slug + config → BrainCli handle (routes to supplier by slug prefix)
- `index.ts` — re-exports

**`_topublish/rhachet-brains-anthropic/`** — the claude supplier (6 prod, 4 test):
- `BrainCli.config.ts` — `CONFIG_BY_CLI_SLUG` map, `AnthropicBrainCliSlug` type
- `genBrainCli.ts` — factory: slug → handle via claude terminal spawn
- `getOneBrainOutputFromStreamJson.ts` — parse nd-JSON stream events from claude `-p` into `BrainOutput`
- `getOneDispatchArgs.ts` — compute CLI args for dispatch mode: `-p --input-format stream-json --output-format stream-json --allowedTools ...`
- `getOneInteractArgs.ts` — compute CLI args for interact mode: `--resume <session-id>`
- `index.ts` — exports

**imports from published rhachet package** (not re-declared):
- `BrainOutput`, `BrainOutputMetrics`, `BrainEpisode`, `BrainSeries`

### what to prove

each capability below must have an integration test against a real claude CLI process:

| capability | how to test |
|---|---|
| `executor.boot({ mode: 'dispatch' })` | spawns `claude -p` with structured i/o, captures session_id |
| `executor.boot({ mode: 'interact' })` | kills dispatch process, spawns `claude --resume` in raw terminal mode |
| `ask({ prompt })` | sends nd-JSON input, collects structured `BrainOutput` with metrics (tokens, cost) |
| `act({ prompt })` | same as ask, different `--allowedTools` set (permits file edit, bash, etc) |
| `terminal.onData` / `terminal.onExit` | raw byte stream and exit signal from CLI process |
| `executor.kill()` | clean termination |
| crash → `executor.boot()` | series preserved on handle, respawn with `--resume` — new episode, same series |
| ask vs act enforcement | `--allowedTools` restricts tool access per mode; never `--dangerously-skip-permissions` |

### what NOT to build

- **no khlone domain objects.** no Zone, Clone, Task, Orchestrator, etc. pure BrainCli contract.
- **no daemon.** the handle is used directly in tests. daemon consumption comes in block A.
- **no persistence.** no DAOs, no filesystem state, no `~/.khlone/`.
- **no other brain suppliers.** claude only. codex, opencode, gemini follow the same pattern later.
- **no khlone CLI.** no `khlone` command. this block produces a library, not a CLI.

---

## file count

| layer | prod | test | total |
|-------|------|------|-------|
| `_topublish/rhachet` (interface + factory) | 3 | 0 | 3 |
| `_topublish/rhachet-brains-anthropic` (supplier) | 6 | 4 | 10 |
| **total** | **9** | **4** | **13** |

---

## key decisions already made

1. **`_topublish` pattern** — develop inside khlone, eject to rhachet core + rhachet-brains-anthropic once stable. see z2 zoomin for rationale.
2. **two boot modes** — `dispatch` (headless, nd-JSON structured i/o) and `interact` (raw terminal, PTY byte relay). see z1 zoomin.
3. **ask vs act via `--allowedTools`** — task mode enforcement at the CLI arg level. ask restricts to read-only tools. act permits all tools. never use `--dangerously-skip-permissions`.
4. **series preservation** — the handle holds the `BrainSeries` ref across boots. `executor.boot()` after a crash uses `--resume <session-id>` to continue the same series.
5. **auth: zero work** — reuse extant `~/.claude/.credentials.json` on the same machine. precondition check only: credentials file exists or `ANTHROPIC_API_KEY` is set. see z3 zoomin.

---

## ejection path

once proven against khlone's daemon (blocks A through E):

1. copy `_topublish/rhachet/` → rhachet core package
2. copy `_topublish/rhachet-brains-anthropic/` → rhachet-brains-anthropic alongside extant `atoms/`, `repls/`, `hooks/`
3. publish both packages
4. sedreplace khlone imports: `from '../../_topublish/rhachet'` → `from 'rhachet'`
5. delete `_topublish/`

mechanical. zero logic changes.

---

## done when

- [ ] `BrainCli` interface type exists with `terminal`, `executor`, `ask`, `act`
- [ ] `genBrainCli({ slug, cwd, role })` returns a handle for claude slugs
- [ ] integration test: boot dispatch → ask → get BrainOutput with tokens > 0
- [ ] integration test: boot dispatch → act → get BrainOutput (verify different tool set)
- [ ] integration test: boot dispatch → kill → boot dispatch again (series preserved)
- [ ] integration test: boot dispatch → ask → boot interact → verify raw terminal mode → kill
- [ ] integration test: terminal.onData fires with output bytes
- [ ] integration test: terminal.onExit fires on process death
