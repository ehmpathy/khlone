# khlone v0: handoff — BrainCli contract for rhachet

> what khlone needs from rhachet to power clones via headless CLI processes

---

## context

khlone orchestrates clones — headless brain CLI processes that run in the background, managed by a per-zone daemon. today, rhachet exposes no BrainCli contract. this handoff declares what khlone requires rhachet to implement so that khlone can:

1. spawn a brain CLI process from a brain slug
2. dispatch tasks to that process via `.ask()` and `.act()`
3. stream output from the process (watch mode)
4. write input to the process (talk mode)
5. detect crashes and respawn with session continuity
6. capture structured output metrics (tokens, cost, duration)

khlone never spawns CLI binaries directly. it calls rhachet, and rhachet calls the vendor CLI. this is the dependency inversion boundary.

---

## 1. what is required

### 1.1 spawn a BrainCli from a brain slug

**the fundamental:** khlone holds a brain slug (e.g., `claude@anthropic/claude/code/opus/v4.5`). it needs to hand that slug to rhachet and get back a live BrainCli handle — a process that khlone's daemon can manage.

**why:** every clone needs a CLI process. the daemon spawns one per clone. the slug comes from `khlone.yml` alias expansion (e.g., user writes `claude`, khlone expands to full slug, rhachet expands slug into a runnable CLI).

**what khlone passes in:**
- `brainSlug` — the fully qualified brain slug
- `cwd` — the worktree path where the CLI should operate
- `role` — the role slug (so the CLI can load role-specific context, briefs, etc.)
- `series` — optional `BrainSeries` ref for session continuation (null on first spawn)
- `env` — optional environment variables

**what khlone gets back:**
- a handle with: `pid`, methods to interact (ask, act, write, onData, onExit, kill), and a `series` ref

**constraints:**
- the CLI process must be spawnable as a child of khlone's daemon (not a grandchild that gets orphaned)
- the process must support PTY — PTY allocation is internal to the BrainCli supplier, not a khlone concern
- the process must be headless — no UI, no interactive prompts that block without stdin

### 1.2 dispatch via .ask() and .act()

**the fundamental:** khlone dispatches tasks in two modes. `ask` = read-only, no side effects. `act` = full tool use, read + write. these map 1:1 to BrainCli methods.

**why:** task mode enforcement is the core safety boundary. `khlone ask "what changed?"` must never mutate files. `khlone act "implement auth"` may mutate. the BrainCli contract is where this enforcement happens — khlone passes mode, and the CLI enforces it.

**what khlone calls:**
- `brainCli.ask({ prompt })` — for ask-mode tasks
- `brainCli.act({ prompt })` — for act-mode tasks

**what khlone gets back:**
- a `BrainOutput` with the result, metrics, episode ref, and updated series ref

**constraints:**
- `.ask()` must enforce read-only — the CLI must not allow mutation tools
- `.act()` must allow full tool use
- both must be callable on the same live BrainCli instance (the clone persists across tasks — task-001 via `.act()`, then task-002 via `.ask()`, on the same process)
- both must work on an already-active PTY process (not spawn a new one per call)

### 1.3 PTY output stream

**the fundamental:** khlone's daemon needs to capture all output from the CLI process — both for transcript archival and for live stream to `khlone watch`.

**why:** `khlone watch` streams clone output to the user's terminal. `khlone log` shows the transcript. the daemon captures all PTY stdout and archives it as `CloneTranscriptEmission` entries.

**what khlone needs:**
- an `onData(callback)` hook that fires for every chunk of PTY stdout
- the data should be the raw terminal output (ANSI codes and all — khlone archives as-is)

**constraints:**
- must fire for all output — not just final results, but also intermediate progress, tool use output, etc.
- must not buffer — khlone needs real-time stream for watch mode

### 1.4 PTY input write

**the fundamental:** khlone's daemon needs to write to the CLI process stdin — both for task dispatch and for `khlone talk` interactive mode.

**why:** `khlone talk` drops the user into direct conversation with the clone. the user types, khlone pipes their input to the CLI's PTY stdin. the CLI responds, khlone pipes stdout back.

**what khlone needs:**
- a `write(data)` method that writes raw data to the PTY stdin

**constraints:**
- must accept arbitrary text (user input in talk mode is freeform)
- must not interfere with in-progress task execution (write is how ask/act dispatch works under the hood)

### 1.5 crash detection

**the fundamental:** when the CLI process dies (crash, OOM, signal), the daemon must detect it immediately so it can respawn the clone.

**why:** crash recovery is a core v0 feature. the daemon catches clone exit via `brainCli.terminal.onExit`, identifies which clone crashed, saves a checkpoint, and respawns via BrainSeries continuation.

**what khlone needs:**
- an `onExit(callback)` hook that fires when the CLI process terminates
- the callback receives the exit code (or signal name)

**constraints:**
- must fire for all exit paths — clean exit, crash, OOM kill, signal
- must fire exactly once per process termination

### 1.6 process termination

**the fundamental:** khlone needs to cleanly shut down a CLI process — for zone shutdown, clone removal, or daemon exit.

**why:** when the daemon shuts down (SIGTERM/SIGINT), it must kill all clone processes. when a clone is removed, its process must be terminated.

**what khlone needs:**
- a `kill()` method that terminates the CLI process

**constraints:**
- must be graceful where possible (SIGTERM first, then SIGKILL after timeout)
- must clean up any child processes the CLI may have spawned (separate BrainCli handles per clone ensure crash isolation)

### 1.7 structured output metrics

**the fundamental:** every task dispatch (ask or act) must return structured metrics — token counts, cost, duration.

**why:** `khlone status` shows token counts and cost per task. `khlone list tasks` shows tokens per completed task. task artifacts capture cost data. without structured metrics, khlone would have to parse vendor-specific CLI output — which defeats the purpose of the abstraction.

**what khlone expects in BrainOutput:**
- `metrics.size.tokens` — `{ input, output, cache: { get, set } }`
- `metrics.cost.time` — duration of the call
- `metrics.cost.cash` — `{ total, deets: { input, output, cache } }`

**constraints:**
- metrics must be per-call (per ask/act invocation), not cumulative
- if a supplier cannot provide cost data (e.g., self-hosted model), fields should be null — not error

### 1.8 session continuity via BrainSeries

**the fundamental:** when a clone's context fills up, the CLI continues in a new episode within the same series. when a clone crashes and respawns, the new process resumes the same series. khlone needs a ref it can persist and pass back on respawn.

**why:** crash recovery. if foreman.1 crashes mid-task, khlone respawns it. the new process must be able to resume the prior conversation context — not start fresh. BrainSeries is the cross-context continuation mechanism.

**what khlone persists:**
- `series` — an opaque ref text from BrainOutput
- `episode` — an opaque ref text from BrainOutput (the current context window)

**what khlone passes on respawn:**
- the `series` ref to the spawn call, so the new process continues the prior series

**constraints:**
- series must survive process death — it's a ref, not a live handle
- series must be serializable (khlone persists it as text in clone state JSON)
- not all suppliers may support series — if unsupported, the field is null and crash recovery starts a fresh context (degraded but functional)

---

## 2. what is not required (but optional)

### 2.1 BrainAtom

khlone does not need one-shot inference. all clone work goes through the CLI process. if rhachet wants to expose BrainAtom alongside BrainCli, that's fine — khlone won't use it for v0.

### 2.2 BrainRepl

khlone does not need SDK-level multi-turn. the CLI process handles its own multi-turn loop. if rhachet wants to expose BrainRepl alongside BrainCli, that's fine — khlone won't use it for v0.

### 2.3 skill execution

khlone handles skill dispatch itself (route skill to capable role, enroll clone, dispatch task). rhachet does not need to know about skills. if rhachet's role system already has skill metadata, khlone may query it (`getOneRoleSkills`), but the dispatch logic is khlone's.

### 2.4 role enrollment

khlone calls `enrollActor` (or equivalent) when a clone is first created. this is an extant rhachet concept (actors). if rhachet already supports actor enrollment, khlone reuses it. if not, khlone can handle enrollment itself — the only hard requirement is that the CLI process respects the role context (briefs, permissions, etc.).

### 2.5 progress estimation

khlone shows `67%` progress in status output. if BrainCli can emit structured progress events (e.g., tool calls completed, estimated work left), khlone will consume them. if not, khlone can estimate from transcript heuristics. this is a nice-to-have, not a blocker.

---

## 3. what is flexible

### 3.1 how .ask() and .act() are implemented

khlone needs two dispatch modes. whether that's:
- two separate methods (`.ask(prompt)` and `.act(prompt)`)
- one method with a mode param (`.dispatch({ prompt, mode: 'ask' | 'act' })`)
- PTY stdin write with a mode prefix (write `ask: prompt` vs `act: prompt`)

...is up to rhachet. khlone will adapt to whatever contract rhachet chooses. the fundamental is: khlone must be able to dispatch a task with a mode, and the CLI must enforce that mode.

### 3.2 how PTY management is exposed

PTY management is internal to the BrainCli supplier. whether rhachet:
- returns a raw spawn config (command, args, env) and khlone does the PTY spawn itself
- returns a pre-spawned PTY handle with onData/write/kill methods
- returns a higher-level wrapper that abstracts PTY internals

...is up to rhachet. khlone needs: spawn, write, onData, onExit, kill. how those are packaged is flexible.

**preference:** khlone would prefer rhachet to own the PTY spawn internally (PTY is a BrainCli supplier concern, not a khlone concern). crash isolation is automatic from separate BrainCli handles per clone. but if rhachet returns a raw spawn config instead, khlone can adapt.

### 3.3 how metrics are captured

whether metrics come from:
- structured JSON emitted by the CLI process on a sideband (stderr, separate socket, etc.)
- parse of the CLI's final output
- a post-call API query to the vendor

...is up to the supplier. khlone just needs `BrainOutput.metrics` to be populated after each `.ask()` / `.act()` call.

### 3.4 how series refs are formatted

the series ref is opaque to khlone. it could be:
- a UUID
- a file path
- a vendor-specific session ID
- a hash of the conversation history

khlone persists it as text and passes it back on respawn. the format is rhachet's concern.

### 3.5 supplier capability discovery

khlone needs to know whether a brain slug supports BrainCli (vs only BrainAtom). whether that's:
- a method (`rhachet.hasBrainCli(slug)`)
- a type guard on the derived brain object
- a static registry

...is flexible. khlone needs a way to fail fast with a clear error when a user's `@brain` alias maps to an atom-only supplier.

---

## 4. preferred contract shape

these are preferences, not demands. rhachet should design its own contract — but this shows what khlone's consumption site looks like.

### 4.1 spawn

```ts
/**
 * expand a brain slug into a BrainCli spawn config or live handle.
 *
 * khlone calls this once per clone enrollment (or respawn after crash).
 * the returned handle is long-lived — persists across many ask/act calls.
 */
const brainCli = await genBrainCli({
  brainSlug: 'claude@anthropic/claude/code/opus/v4.5',
  cwd: '/home/vlad/git/ehmpathy/myrepo',
  role: 'ehmpathy/foreman',
  series: null,              // null on first spawn; ref text on respawn
  env: { KHLONE_ZONE: '@feat/auth' },
});
```

### 4.2 dispatch

```ts
// ask mode — read-only, no side effects
const askOutput = await brainCli.ask({ prompt: 'what files changed?' });

// act mode — full tool use
const actOutput = await brainCli.act({ prompt: 'implement jwt validation' });
```

### 4.3 BrainOutput

```ts
interface BrainOutput<TOutput = string> {
  output: TOutput;
  metrics: {
    size: {
      tokens: { input: number; output: number; cache: { get: number; set: number } };
      chars: { input: number; output: number; cache: { get: number; set: number } };
    };
    cost: {
      time: string;          // ISO duration
      cash: {
        total: string;       // ISO price (e.g., "$0.042")
        deets: { input: string; output: string; cache: string };
      } | null;              // null if supplier cannot provide cost
    };
  };
  episode: string;           // current context window ref
  series: string | null;     // cross-context continuation ref (null if unsupported)
}
```

### 4.4 PTY hooks

```ts
brainCli.terminal.onData((chunk: string) => {
  // raw PTY stdout — ANSI codes, partial lines, etc.
  // khlone archives this for transcript + streams to watch
});

brainCli.terminal.onExit((code: number, signal?: string) => {
  // process terminated
  // khlone triggers crash recovery if unexpected
});

brainCli.terminal.write('some input\n');  // raw PTY stdin
brainCli.kill();                 // graceful termination
```

### 4.5 handle shape (summary)

```ts
interface BrainCli {
  pid: number;                                         // updated on each boot
  mode: 'dispatch' | 'interact';                       // current mode
  series: string | null;                               // current series ref

  // lifecycle
  executor: {
    boot(input: { mode: 'dispatch' | 'interact' }): Promise<void>;
  };
  kill(): void;

  // dispatch (only valid in dispatch mode)
  ask(input: { prompt: string }): Promise<BrainOutput>;
  act(input: { prompt: string }): Promise<BrainOutput>;

  // terminal (valid in both modes)
  terminal: {
    write(data: string): void;
    resize(cols: number, rows: number): void;
    onData(cb: (chunk: string) => void): void;
    onExit(cb: (code: number, signal?: string) => void): void;
  };
}
```

**mode constraints:**
- `ask()` and `act()` are only valid in `dispatch` mode — call in `interact` mode throws
- `terminal.write()` is valid in both modes — in `dispatch` mode it writes to the structured stdin; in `interact` mode it writes raw PTY input
- `terminal.resize()` is valid in both modes — primarily used in `interact` mode for SIGWINCH proxy
- `terminal.onData` fires in both modes — in `dispatch` mode it emits structured events; in `interact` mode it emits raw terminal output
- `executor.boot()` can be called in either mode — it always kills the current process and respawns in the target mode
- `kill()` — valid in any mode

**the daemon always owns the brain CLI process.** in dispatch mode, the daemon reads structured output and dispatches tasks. in interact mode, the daemon relays raw PTY bytes between the IPC client (khlone CLI) and the brain CLI. the mode changes; the ownership does not.

---

## 5. usage playtests

these show exactly how khlone's daemon uses BrainCli at each touchpoint.

### 5.1 first clone enrollment + task dispatch

```ts
// daemon: user ran `khlone act "implement auth"` — first task in zone

// 1. spawn brainCli for the hero clone
const brainCli = await genBrainCli({
  brainSlug: 'claude@anthropic/claude/code/opus/v4.5',
  cwd: '/home/vlad/git/ehmpathy/myrepo',
  role: 'ehmpathy/foreman',
  series: null,
});

// 2. register in daemon state
cloneProcesses.set('foreman.1', { brainCli, pid: brainCli.pid });

// 3. archive transcript
brainCli.terminal.onData((chunk) => {
  daoCloneTranscript.set.append({
    emission: { timestamp: new Date().toJSON(), type: 'output', content: chunk, task: taskRef },
    clonePath: clonePath,
  });
});

// 4. detect crash
brainCli.terminal.onExit((code, signal) => {
  handleCloneCrash({ cloneSlug: 'foreman.1', code, signal });
});

// 5. dispatch task
const output = await brainCli.act({ prompt: 'implement auth' });

// 6. capture metrics as task artifact
await daoTask.set.upsert({
  task: { ...task, status: 'done', artifacts: [/* from output.metrics */] },
  path: taskPath,
});

// 7. series ref updated — persist for crash recovery
await daoClone.set.upsert({
  clone: { ...clone, series: output.series, status: 'idle' },
  clonePath,
});
```

### 5.2 second task on same clone (reuse)

```ts
// daemon: user ran `khlone act "add tests"` — foreman.1 already alive

// 1. look up extant brainCli — already in daemon state
const { brainCli } = cloneProcesses.get('foreman.1')!;

// 2. dispatch second task on same process — no spawn
const output = await brainCli.act({ prompt: 'add tests' });

// 3. update series ref
await daoClone.set.upsert({
  clone: { ...clone, series: output.series },
  clonePath,
});
```

### 5.3 crash recovery

```ts
// daemon: foreman.1's brainCli process died (brainCli.terminal.onExit fired)

async function handleCloneCrash({ cloneSlug, code, signal }) {
  const clone = await daoClone.get.byRef({ clonePath });

  // 1. save checkpoint
  await daoCloneCheckpoint.set.append({
    checkpoint: {
      task: activeTaskRef,
      series: clone.series!,
      episode: lastEpisodeRef,
      progress: estimatedProgress,
      capturedAt: new Date().toJSON(),
    },
    clonePath,
  });

  // 2. respawn with series continuation
  const brainCli = await genBrainCli({
    brainSlug: clone.brainSlug,
    cwd: zonePath,
    role: clone.roleSlug,
    series: clone.series,           // <-- pass prior series ref
  });

  // 3. update daemon state
  cloneProcesses.set(cloneSlug, { brainCli, pid: brainCli.pid });

  // 4. re-register hooks
  brainCli.terminal.onData((chunk) => { /* transcript */ });
  brainCli.terminal.onExit((code, signal) => { handleCloneCrash({ cloneSlug, code, signal }); });

  // 5. re-dispatch active task
  const checkpoint = await daoCloneCheckpoint.get.latest({ clonePath });
  if (checkpoint) {
    await brainCli.act({ prompt: `resume task: ${activeTask.prompt}` });
  }
}
```

### 5.4 watch mode (stream output)

```ts
// cli: user ran `khlone watch`

// 1. connect to daemon via IPC
const conn = await getOneDaemonConnection({ zone });

// 2. daemon receives 'attach' message
//    daemon pipes brainCli.terminal.onData to IPC client
//    (brainCli.terminal.onData was already registered — daemon just adds a second consumer)

// 3. cli receives chunks via IPC, writes to process.stdout
conn.onMessage((msg) => {
  if (msg.type === 'output') process.stdout.write(msg.data);
});

// 4. ctrl+c → detach
// cli sends 'detach' message, daemon stops the pipe
// brainCli.terminal.onData still fires for transcript — only the IPC pipe stops
```

### 5.5 talk mode (byte relay through daemon)

```ts
// cli: user ran `khlone talk`

// 1. tell daemon to switch clone to interact mode
const conn = await getOneDaemonConnection({ zone });
await conn.send({ type: 'talk', cloneSlug: 'foreman.1' });
// daemon: calls brainCli.executor.boot({ mode: 'interact' })
// daemon: returns { type: 'talk-ready' }

// 2. set terminal to raw mode (no local echo, no line buffer)
process.stdin.setRawMode(true);

// 3. relay stdin -> daemon -> brainCli
process.stdin.on('data', (chunk) => {
  conn.send({ type: 'input', cloneSlug: 'foreman.1', data: chunk.toString() });
});

// 4. relay brainCli -> daemon -> stdout
conn.onMessage((msg) => {
  if (msg.type === 'output') process.stdout.write(msg.data);
  if (msg.type === 'talk-end') {
    // brain CLI exited or detach — restore terminal, return to shell
    process.stdin.setRawMode(false);
  }
});

// 5. proxy terminal resize
process.stdout.on('resize', () => {
  conn.send({ type: 'resize', cloneSlug: 'foreman.1', cols: process.stdout.columns, rows: process.stdout.rows });
});

// 6. talk ends via any of:
//    a. brain CLI exits -> daemon catches terminal.onExit, boots to dispatch, sends talk-end
//    b. khlone CLI disconnects (ctrl+c, terminal close) -> daemon detects IPC drop, boots to dispatch
//    c. user sends detach signal -> CLI sends { type: 'detach' }, daemon boots to dispatch
```

### 5.6 ask mode enforcement

```ts
// daemon: user ran `khlone ask "what files changed?"`

// dispatch via .ask() — the CLI must enforce read-only
const output = await brainCli.ask({ prompt: 'what files changed?' });

// the brainCli guarantees: no files were mutated, no commands were run
// khlone trusts the CLI enforcement — it does not verify post-hoc
```

### 5.7 supplier capability check (fail fast)

```ts
// cli: user ran `khlone act "task" --who @xai-atom`
// xai-atom maps to a brain slug for an atom-only supplier

// khlone expands alias → brain slug
// khlone checks: does this slug support BrainCli?

const hasCli = await hasBrainCli({ brainSlug });
if (!hasCli) {
  throw new BadRequestError(
    `brain "xai-atom" does not support BrainCli — clones require a CLI process. ` +
    `available brains with CLI support: claude, codex, grok, gemini`
  );
}
```

---

## 6. summary of the contract boundary

```
khlone owns:                              rhachet owns:
├── clone lifecycle                       ├── brain slug → BrainCli lookup
├── daemon process management             ├── BrainCli contract (interface)
├── task queue + dispatch                 ├── supplier packages (implementations)
├── brain alias → slug expansion          ├── PTY spawn internals (per supplier)
├── find-or-enroll decision               ├── mode enforcement (ask vs act)
├── PTY relay via BrainCli contract        ├── BrainOutput metrics capture
├── transcript capture                    ├── BrainSeries continuation
├── crash detection + recovery logic      ├── supplier capability metadata
├── IPC between cli ↔ daemon              ├── mode switch (dispatch ↔ interact)
├── byte relay for talk mode              └── role context setup (briefs, etc.)
└── terminal multiplexer (daemon)
```

**the one-sentence contract:** khlone gives rhachet a brain slug and gets back a handle it can use to dispatch tasks, stream output, switch between dispatch and interact modes, and recover from crashes — with no need to know which vendor CLI is underneath.

---

## 7. what blocks khlone v0 without this

| khlone capability | blocked without BrainCli |
|---|---|
| clone enrollment (spawn process) | yes — no way to start a brain CLI |
| task dispatch (ask/act) | yes — no way to send tasks to a brain |
| watch mode (stream output) | yes — no PTY output to stream |
| talk mode (interactive) | yes — no `executor.boot({ mode: 'interact' })` for byte relay |
| crash recovery | yes — no way to respawn with series continuation |
| token/cost capture | yes — no structured metrics source |
| multi-brain support | yes — no slug expansion to vendor CLI |
| mode enforcement (ask vs act) | yes — no contract to enforce read-only |

every khlone feature that touches a brain process depends on this contract. it is the most critical external dependency for v0.
