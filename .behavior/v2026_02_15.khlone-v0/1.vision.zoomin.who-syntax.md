# khlone v0: zoomin — --who clone address syntax

> `--who` addresses a clone by its identity — role, brain, and index are all part of that identity

---

## the question

clone identity = role + brain + index. `--who` addresses clone identity. brain is not a separate concern — it's part of the unique key.

the prior vision had `--brain` as a separate flag. this split role and brain across two flags, even though they are equal parts of clone identity. `--brain` should never have been its own flag — it's just one component of `--who`.

this zoomin formalizes the `--who` syntax to address all three components of clone identity in a single token.

---

## the syntax

**grammar:**

```
--who [role][.n][@brain][++]
```

where:
- `role` = role alias from khlone.yml (defaults to hero role if omitted)
- `.n` = specific clone index (optional — omit to let khlone find any match)
- `@brain` = brain alias from khlone.yml (defaults to hero brain if omitted)
- `++` = force-enroll a new clone even if one exists (optional — omit for find-or-enroll)

**parse output:**

```ts
{ role: string; brain: string; index: number | '++' | null }
```

---

## the full example table

| syntax | role | brain | index | behavior |
|--------|------|-------|-------|----------|
| (omitted) | hero | hero | null | find or enroll hero clone |
| `--who researcher@kimi` | researcher | kimi | null | find or enroll researcher on kimi |
| `--who researcher` | researcher | hero | null | find or enroll researcher on hero brain |
| `--who @kimi` | hero | kimi | null | find or enroll hero clone on kimi |
| `--who mechanic.1` | mechanic | (whatever .1 has) | 1 | target specific clone mechanic.1 |
| `--who mechanic.1@kimi` | mechanic | kimi | 1 | target mechanic.1, must be on kimi |
| `--who researcher@kimi++` | researcher | kimi | ++ | force-enroll new researcher on kimi |
| `--who researcher++` | researcher | hero | ++ | force-enroll new researcher on hero brain |
| `--who @kimi++` | hero | kimi | ++ | force-enroll new hero role clone on kimi |
| `--who ++` | hero | hero | ++ | force-enroll new hero clone on hero brain |

---

## playtests

### playtest.1 — default dispatch (no --who)

```sh
$ khlone act "implement auth"
```

**parse:** `{ role: hero, brain: hero, index: null }`

**what happens:**
```
1. role = foreman (hero role from khlone.yml)
2. brain = claude (hero brain from khlone.yml)
3. find or enroll clone: foreman on claude → foreman.1
4. dispatch task to foreman.1
```

### playtest.2 — role override, default brain

```sh
$ khlone act "research auth patterns" --who researcher++
```

**parse:** `{ role: researcher, brain: hero, index: ++ }`

**what happens:**
```
1. role alias "researcher" → ehmpathy/researcher (via khlone.yml)
2. brain = claude (hero default, no @brain specified)
3. ++ = force-enroll → spawn researcher.{n} on claude (next available index)
4. dispatch task to researcher.{n}
```

### playtest.3 — brain override, default role

```sh
$ khlone act "quick fix" --who @grok
```

**parse:** `{ role: hero, brain: grok, index: null }`

**what happens:**
```
1. role = foreman (hero default, no role specified)
2. brain alias "grok" → brain slug (via khlone.yml)
3. find or enroll clone: foreman on grok → foreman.2
4. dispatch task to foreman.2
```

### playtest.4 — brain override, force-enroll

```sh
$ khlone act "quick fix" --who @grok++
```

**parse:** `{ role: hero, brain: grok, index: ++ }`

**what happens:**
```
1. role = foreman (hero default)
2. brain alias "grok" → brain slug (via khlone.yml)
3. ++ = force-enroll → spawn foreman.{n} on grok (next available index)
4. dispatch task to foreman.{n}
```

### playtest.5 — role + brain override

```sh
$ khlone ask "research auth patterns" --who researcher@kimi++
```

**parse:** `{ role: researcher, brain: kimi, index: ++ }`

**what happens:**
```
1. role alias "researcher" → ehmpathy/researcher
2. brain alias "kimi" → brain slug
3. ++ = force-enroll → spawn researcher.{n} on kimi (next available index)
4. dispatch ask task to researcher.{n}
```

### playtest.6 — specific clone by index

```sh
$ khlone act "continue the refactor" --who mechanic.1
```

**parse:** `{ role: mechanic, brain: (whatever .1 has), index: 1 }`

**what happens:**
```
1. look up mechanic.1 in zone crew registry
2. mechanic.1 found → brain is whatever it was enrolled with
3. dispatch task to mechanic.1
```

### playtest.7 — specific clone by index + brain assertion

```sh
$ khlone act "continue the refactor" --who mechanic.1@claude
```

**parse:** `{ role: mechanic, brain: claude, index: 1 }`

**what happens:**
```
1. look up mechanic.1 in zone crew registry
2. mechanic.1 found → check brain matches claude
3. if brain matches → dispatch task
4. if brain does not match → error: mechanic.1 is on grok, not claude
```

### playtest.8 — find or enroll by role + brain (no index, no ++)

```sh
$ khlone act "review this" --who reviewer@claude
```

**parse:** `{ role: reviewer, brain: claude, index: null }`

**what happens:**
```
1. role alias "reviewer" → ehmpathy/reviewer
2. brain alias "claude" → brain slug
3. find or enroll clone: reviewer on claude → reviewer.1
4. dispatch task to reviewer.1
```

---

## why --brain was wrong

### brain was always part of clone identity

`--brain` as a separate flag implied brain is a task-level concern — "use this brain for this task." but brain is a clone-level concern — it's part of the clone's unique key. a clone IS a role + brain + index. `--who` addresses clone identity. brain belongs there.

### the prior design leaked an implementation detail

`--brain` existed because the vision was thought about in two steps: "which clone?" then "which brain?" but from the user's perspective, there's one question: "who should do this?" the answer is a clone address — role, brain, index — in a single token.

### `@` reads naturally

`researcher@kimi` reads as "researcher on kimi" — the role at that brain. this parallels email (`user@host`) and git (`branch@remote`) patterns.

### no flag interaction to define

with two flags, you'd have to define: what happens when `--who mechanic.1 --brain grok` and mechanic.1 is on claude? is that an error? a new clone? the question itself reveals the flaw — two flags for one identity creates ambiguity. one token, no ambiguity.

---

## `@` overload with zone addresses

zones use `@` in their address format:
- `--zone @feat/auth`
- `--zone svc-jobs@main`

`--who` now also uses `@`:
- `--who researcher@kimi`

**no parse ambiguity** — these are in different flag contexts. but the semantic overlap is worth a note:
- zone `@` = "at branch" (`svc-jobs` at `main`)
- clone `@` = "on brain" (`researcher` on `kimi`)

both read as "X at/on Y" — which is arguably consistent rather than contradictory.

in a full command:
```sh
khlone act "task" --who researcher@kimi++ --zone @feat/auth
```

the two `@` usages are visually distinct by context and don't collide.

---

## error experiences

```
given(--who specifies role alias not in khlone.yml)
  when(user runs `khlone act "task" --who unknown++`)
    then(error indicates unknown role)
    then(error lists available roles from khlone.yml)

given(--who specifies brain alias not in khlone.yml)
  when(user runs `khlone act "task" --who @unknown`)
    then(error indicates unknown brain)
    then(error lists available brains from khlone.yml)

given(--who specifies index + brain mismatch)
  when(user runs `khlone act "task" --who mechanic.1@kimi`)
    then(error indicates mechanic.1 is on claude, not kimi)

given(--who specifies brain alias that maps to atom-only supplier)
  when(user runs `khlone act "task" --who @xai-grok`)
    then(error indicates cli supplier lacks BrainCli)
    then(error explains clones require BrainCli, not BrainAtom)
    then(error lists brain aliases with BrainCli support)
```

---

## the updated find-or-enroll flow

```
user: khlone act "task" --who researcher@kimi++

1. khlone parses --who → { role: researcher, brain: kimi, index: ++ }
2. khlone resolves role alias ("researcher" → ehmpathy/researcher via khlone.yml)
3. khlone resolves brain alias ("kimi" → brain slug via khlone.yml)
4. if index is ++:
   → force-enroll: spawn new clone via rhachet, assign next index
5. if index is null:
   → find extant clone with role + brain match
   → if found: reuse extant brainCli
   → if not found: auto-enroll new clone via rhachet, assign next index
6. if index is .n:
   → find clone by exact slug (role.n)
   → if @brain specified: assert brain matches
   → if not found: error
7. khlone dispatches task via brainCli.ask() or brainCli.act()
```

---

## impact on the vision

### correction
- `--brain` is removed — it was a design error that split clone identity across two flags
- `--who` grammar is `[role][.n][@brain][++]` — addresses all three components of clone identity

### sections to update
- clone domain object: brain resolution is part of `--who` parse, not a separate flag
- brain alias resolution flow: triggered by `@brain` component in --who
- flags reference table: remove --brain row, document --who grammar
- all examples that used `--brain` → rewrite with `--who @brain` syntax
- usecase.8 (clone target) + usecase.10 (brain selection): merge into one usecase, since both are clone address components
- matrix.6 (clone target) + matrix.8 (brain selection): merge, since both are `--who` parse dimensions
- error experiences: all clone address errors are `--who` errors

### sections unchanged
- brain supplier architecture (rhachet contract, BrainCli, suppliers) — unaffected
- daemon architecture — unaffected
- khlone.yml `crew.brains` config — still needed for alias resolution
