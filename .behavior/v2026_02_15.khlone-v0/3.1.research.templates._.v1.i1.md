# khlone v0: research — templates

> rhachet repo structure as template for khlone

---

## 1. top-level layout

rhachet's `src/` follows ehmpathy's layered architecture:

```
src/
├── contract/          # public surface: cli + sdk exports
│   ├── cli/           # commander-based cli handlers (invoke*.ts)
│   └── sdk*.ts        # selective re-exports for consumers
├── domain.objects/    # flat domain entity/literal declarations
├── domain.operations/ # subdomain folders, one operation per file
├── access/            # daos + external sdks
│   └── daos/          # one folder per dao (index.ts + schema.ts)
├── infra/             # domain-free utilities (filesystem, prompts)
└── index.ts           # re-exports contract/sdk.ts
```

**citation [1]**: rhachet `src/` tree via `tree -L 2 /home/vlad/git/ehmpathy/rhachet/src/`

---

## 2. bin/ entrypoint pattern

rhachet uses a bash router as the cli entrypoint:

```sh
#!/usr/bin/env bash
# bin/run — routes to bun (fast) or jit (flexible) based on command
case "$1" in
  run)           exec "$SCRIPT_DIR/run.bun" "$@" ;;
  roles)
    case "$2" in
      boot|cost)  exec "$SCRIPT_DIR/run.bun" "$@" ;;
      *)          exec "$SCRIPT_DIR/run.jit" "$@" ;;
    esac ;;
  *)             exec "$SCRIPT_DIR/run.jit" "$@" ;;
esac
```

the jit dispatcher is a one-liner:

```js
#!/usr/bin/env -S node --experimental-strip-types ...
require('../dist/contract/cli/invoke').invoke({ args: process.argv.slice(2) });
```

**citation [2]**: `/home/vlad/git/ehmpathy/rhachet/bin/run` lines 1-50
**citation [3]**: `/home/vlad/git/ehmpathy/rhachet/bin/run.jit` lines 1-3

package.json declares the bin field:

```json
{
  "bin": { "rhachet": "./bin/run", "rhx": "./bin/rhx" }
}
```

**citation [4]**: `/home/vlad/git/ehmpathy/rhachet/package.json` bin field

---

## 3. contract layer — cli

the cli uses commander with one `invoke*.ts` file per command:

```
src/contract/cli/
├── invoke.ts              # main router — creates program, registers all commands
├── invokeAct.ts           # act command handler
├── invokeInit.ts          # init command handler
├── invokeRoles.ts         # roles command
├── invokeRun.ts           # run command (skills)
├── invokeUpgrade.ts       # upgrade command
└── ... (~20 invoke files)
```

the main router pattern:

```ts
// invoke.ts
export const invoke = async (input: { args: string[] }) => {
  const context = await genContextConfigOfUsage({ cwd: process.cwd() });
  const program = new Command();
  program.name('rhachet');
  invokeInit({ program });
  invokeAct({ program }, context);
  // ... register all commands
  await program.parseAsync(input.args, { from: 'user' });
};
```

each handler is a thin delegation to domain.operations:

```ts
// invokeInit.ts — representative pattern
export const invokeInit = (input: { program: Command }) => {
  input.program
    .command('init')
    .description('...')
    .action(async () => {
      const context = await genContextCli({ cwd: process.cwd() });
      await initRolesFromPackages(context);
      await syncHooksForLinkedRoles(context);
    });
};
```

**citation [5]**: `/home/vlad/git/ehmpathy/rhachet/src/contract/cli/invoke.ts`
**citation [6]**: `/home/vlad/git/ehmpathy/rhachet/src/contract/cli/invokeInit.ts`

---

## 4. contract layer — sdk exports

rhachet exports via selective re-export from `contract/sdk*.ts`:

```ts
// sdk.ts — main exports
export * from '@src/domain.objects';
export { genActor } from '@src/domain.operations/actor/genActor';
export { genBrainContinuables } from '@src/domain.operations/brainContinuation/genBrainContinuables';
// ... cherry-picked operations
```

subpath exports for consumers who need a subset:

```json
{
  "exports": {
    ".":         { "types": "./dist/index.d.ts", "default": "./dist/index.js" },
    "./brains":  { "types": "./dist/contract/sdk.brains.d.ts", "default": "./dist/contract/sdk.brains.js" },
    "./actors":  { "types": "./dist/contract/sdk.actors.d.ts", "default": "./dist/contract/sdk.actors.js" },
    "./keyrack": { "types": "./dist/contract/sdk.keyrack.d.ts", "default": "./dist/contract/sdk.keyrack.js" }
  }
}
```

`src/index.ts` simply re-exports:

```ts
export * from './contract/sdk';
```

**citation [7]**: `/home/vlad/git/ehmpathy/rhachet/src/contract/sdk.ts`
**citation [8]**: `/home/vlad/git/ehmpathy/rhachet/src/contract/sdk.brains.ts`
**citation [9]**: `/home/vlad/git/ehmpathy/rhachet/package.json` exports field

---

## 5. domain.objects pattern

flat files, one class per file, extends `DomainEntity` or `DomainLiteral`:

```ts
// Actor.ts — representative entity
export interface Actor<TRole extends Role = Role> {
  role: TRole;
  brains: ActorBrain[];
  act: ActorActOp<TRole>;
  run: ActorRunOp<TRole>;
  ask: ActorAskOp;
}
export class Actor<TRole extends Role = Role>
  extends DomainEntity<Actor<TRole>>
  implements Actor<TRole>
{
  public static unique = ['role.slug'] as const;
}
```

the folder is flat — no subdomain folders for domain objects:

```
src/domain.objects/
├── Actor.ts
├── ActorBrain.ts
├── BrainAtom.ts
├── BrainCli.ts
├── BrainEpisode.ts
├── BrainSeries.ts
├── Role.ts
├── Skill.ts
├── ... (~60 files)
└── index.ts           # barrel export (allowed: package entrypoint)
```

**citation [10]**: `/home/vlad/git/ehmpathy/rhachet/src/domain.objects/Actor.ts`
**citation [11]**: `/home/vlad/git/ehmpathy/rhachet/src/domain.objects/index.ts`

---

## 6. domain.operations pattern

organized by subdomain folder, one operation per file, collocated tests:

```
src/domain.operations/
├── actor/
│   ├── genActor.ts
│   ├── genActor.test.ts
│   └── actorAct.ts
├── brain/
│   ├── genBrainAtom.ts
│   └── genBrainRepl.ts
├── brainCost/
│   ├── computeBrainCostFromUsage.ts
│   └── computeBrainCostFromUsage.test.ts
├── config/
│   ├── genContextConfigOfUsage.ts
│   └── genContextCli.ts
├── init/
│   ├── initRolesFromPackages.ts
│   └── syncHooksForLinkedRoles.ts
├── role/
│   ├── genRole.ts
│   └── genRoleFromPackage.ts
└── ... (18 subdomain folders)
```

each operation follows the `(input, context?)` pattern:

```ts
// genActor.ts — representative operation
export const genActor = <TRole extends Role>(input: {
  role: TRole;
  brains: ActorBrain[];
}): Actor<TRole> => {
  return new Actor({
    role: input.role,
    brains: input.brains,
    act: (actInput) => actorAct({ ...actInput, role: input.role }, { brains: input.brains }),
    run: (runInput) => actorRun({ ...runInput, role: input.role }, { brains: input.brains }),
    ask: (askInput) => actorAsk(askInput, { brains: input.brains }),
  });
};
```

**citation [12]**: `/home/vlad/git/ehmpathy/rhachet/src/domain.operations/actor/genActor.ts`

---

## 7. access layer

minimal — one folder per dao:

```
src/access/daos/
├── daoKeyrackHostManifest/
│   ├── index.ts          # dao interface (get/set/del)
│   └── schema.ts         # validation schema
└── daoKeyrackRepoManifest/
    ├── index.ts
    └── schema.ts
```

**citation [13]**: rhachet `src/access/` tree

---

## 8. infra layer

domain-free utilities — no business rules:

```
src/infra/
├── filesystem/
│   ├── readFileSafe.ts
│   └── writeFileSafe.ts
├── findsertFile.ts
├── upsertFile.ts
└── promptUserChoice.ts
```

**citation [14]**: rhachet `src/infra/` tree

---

## 9. tsconfig path aliases

```json
{
  "compilerOptions": {
    "paths": {
      "@src/*": ["src/*"],
      "@/*": ["*"]
    }
  }
}
```

all imports use `@src/` prefix for absolute paths within src/.

**citation [15]**: `/home/vlad/git/ehmpathy/rhachet/tsconfig.json`

---

## 10. dependency flow

top-down, strict:

```
contract/cli/     → domain.operations/, domain.objects/
contract/sdk*.ts  → domain.operations/, domain.objects/
domain.operations/→ domain.objects/, access/, infra/
domain.objects/   → (no deps — leaf layer)
access/           → domain.objects/
infra/            → (no deps — leaf layer)
```

**citation [16]**: inferred from import analysis of rhachet src/

---

## 11. proposed khlone template

based on rhachet's patterns, adapted for khlone's domain:

### top-level

```
bin/
├── run               # bash router (bun/jit dispatch)
├── run.bun           # bun entrypoint (fast path)
└── run.jit           # node jit entrypoint

src/
├── contract/
│   ├── cli/          # commander handlers (one per verb)
│   │   ├── invoke.ts
│   │   ├── invokeAct.ts
│   │   ├── invokeAsk.ts
│   │   ├── invokeInit.ts
│   │   ├── invokeList.ts
│   │   ├── invokeLog.ts
│   │   ├── invokeStatus.ts
│   │   ├── invokeTalk.ts
│   │   └── invokeWatch.ts
│   └── sdk.ts        # selective re-exports
│
├── domain.objects/   # flat, one per file
│   ├── Clone.ts
│   ├── CloneAddress.ts
│   ├── Crew.ts
│   ├── ZoneDaemon.ts
│   ├── Orchestrator.ts
│   ├── Site.ts
│   ├── SiteManifest.ts
│   ├── Task.ts
│   ├── TaskArtifact.ts
│   ├── TaskMode.ts
│   ├── Zone.ts
│   ├── ZoneAddress.ts
│   └── index.ts
│
├── domain.operations/ # subdomain folders
│   ├── clone/         # enroll, find-or-enroll, crash recovery
│   ├── config/        # parse khlone.yml, gen context
│   ├── daemon/        # spawn, monitor, restart, ipc
│   ├── dispatch/      # route task to clone via brainCli
│   ├── observe/       # watch + talk modes
│   ├── orchestrator/  # global state, site registry
│   ├── site/          # site-level operations
│   ├── status/        # smart status, list resources
│   ├── task/          # queue, prioritize, artifacts
│   ├── who/           # parse --who syntax, alias lookup
│   └── zone/          # init, state files, crew management
│
├── access/
│   └── daos/          # state file persistence
│       ├── daoZone/
│       ├── daoCrew/
│       └── daoTask/
│
├── infra/             # domain-free: pty, ipc, filesystem
│   ├── pty/           # node-pty wrappers
│   ├── ipc/           # unix socket client/server
│   └── filesystem/    # safe read/write helpers
│
└── index.ts           # re-exports contract/sdk.ts
```

### bin field

```json
{
  "bin": { "khlone": "./bin/run", "khx": "./bin/run" }
}
```

two names, one binary: `khlone` (full) and `khx` (alias for speed).

### bun compilation strategy

the cli compiles to a bun binary for fast cold-start. this is viable because the cli itself is thin — it only needs to:
1. parse args (commander)
2. talk to the zone daemon via unix socket ipc

the cli never does package resolution against dynamic brain suppliers (`rhachet-brains-*`). that is the daemon's job. the daemon runs as a long-lived node process and can afford the jit cost of dynamic `require()` for supplier packages. this separation keeps the cli binary small and startup instant.

```
cli (bun binary, fast)          daemon (node, long-lived)
├── parse --who                 ├── require('rhachet-brains-anthropic')
├── parse --zone                ├── require('rhachet-brains-opencode')
├── send ipc to daemon          ├── spawn brainCli via supplier
└── render output               └── manage pty lifecycle
```

### key patterns to carry over from rhachet

1. **bin/run bash router** — same bun/jit dispatch pattern
2. **invoke*.ts per verb** — thin cli handlers that delegate to domain.operations
3. **sdk.ts selective re-exports** — consumers get curated surface
4. **flat domain.objects/** — one file per entity/literal, barrel export in index.ts
5. **subdomain folders in domain.operations/** — collocated tests, one operation per file
6. **`(input, context?)` pattern** — all operations follow the standard signature
7. **`@src/*` path alias** — absolute imports within src/
8. **top-down dependency flow** — contract → domain.operations → domain.objects, access, infra

### key differences from rhachet

1. **no `src/logic/`** — rhachet has a minimal logic/ folder; khlone should fold any glue into domain.operations/ directly
2. **daemon subdomain** — khlone needs pty/ipc operations that rhachet does not (rhachet delegates pty to brain supplier packages)
3. **state file daos** — khlone persists zone/crew/task state to `.khlone/.bind/` files, unlike rhachet which uses manifest daos for keyrack

---

## summary

rhachet's repo structure provides a proven template for khlone:
- **contract/** for public surface (cli + sdk)
- **domain.objects/** for flat entity declarations
- **domain.operations/** for subdomain-scoped business logic
- **access/** for persistence
- **infra/** for domain-free utilities
- top-down dependency flow, `(input, context)` everywhere, one operation per file

the adaptation for khlone maps naturally: replace rhachet's actor/brain/role subdomains with khlone's clone/zone/task/daemon subdomains, add pty/ipc infra, and keep the same architectural patterns.
