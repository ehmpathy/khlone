# khlone v0: blackbox coverage matrix

> dimension analysis of blackbox criteria

---

## matrix.1 = dispatch behavior

covers: usecase.1 (instant dispatch), usecase.3 (queue stack)

| ind: init state | ind: mode | ind: queue mode | dep: shell | dep: zone | dep: clone | dep: queue position |
|-----------------|-----------|-----------------|------------|-----------|------------|---------------------|
| initialized | ask | enqueue (default) | returns immediately | current | hero | end of queue |
| initialized | act | enqueue (default) | returns immediately | current | hero | end of queue |
| initialized | ask | --prioritize | returns immediately | current | hero | front of queue |
| initialized | act | --prioritize | returns immediately | current | hero | front of queue |
| initialized | ask | --when disrupt | returns immediately | current | hero | interrupts current |
| initialized | act | --when disrupt | returns immediately | current | hero | interrupts current |
| not initialized | ask | enqueue | returns immediately | auto-init | hero enrolled | first task |
| not initialized | act | enqueue | returns immediately | auto-init | hero enrolled | first task |

**gaps:** none — all combinations covered

---

## matrix.2 = task mode enforcement

covers: usecase.2 (task mode enforcement)

| ind: mode | ind: clone action | dep: permitted | dep: rationale |
|-----------|-------------------|----------------|----------------|
| ask | read files | yes | ask tasks read freely |
| ask | reason and respond | yes | ask tasks reason and respond |
| ask | modify files | no | ask = no side effects |
| ask | run commands | no | ask = no side effects |
| act | read files | yes | act tasks read freely |
| act | reason and respond | yes | act tasks reason and respond |
| act | modify files | yes | act = may modify |
| act | run commands | yes | act = may modify |

**gaps:** none — ask/act enforcement boundary fully covered

---

## matrix.3 = observation modes

covers: usecase.4 (observation modes), usecase.5 (block output)

| ind: mode | ind: invocation | dep: shell behavior | dep: clone continues | dep: queue |
|-----------|-----------------|---------------------|----------------------|------------|
| watch | `khlone watch` | streams, ctrl+c exits | yes | unchanged |
| watch | `--watch` flag | queues then streams | yes | unchanged |
| talk | `khlone talk` | interactive session | yes | paused |
| talk | `--talk` flag | queues then interactive | yes | paused |
| await | `--await` flag | blocks until complete | n/a (task done) | unchanged |

**gaps:** none — all combinations covered

**note:** `--watch` and `--talk` are mutually exclusive (error experience documented)

---

## matrix.4 = status scope resolution

covers: usecase.6 (status inspection)

| ind: pwd context | ind: explicit scope | dep: scope shown |
|------------------|---------------------|------------------|
| feature branch | (none) | zone |
| main branch | (none) | site |
| not a git repo | (none) | orchestrator |
| any | `orchestrator` | orchestrator |
| any | `site` | site |
| any | `zone` | zone |
| any | `--task task-id` | task details + mode |
| any | `--who clone-id` | clone details |

**gaps:** none — smart defaults + explicit override both covered

---

## matrix.5 = resource enumeration

covers: usecase.7 (resource enumeration)

| ind: scope | dep: shows | dep: includes |
|------------|------------|---------------|
| sites | all sites on machine | zone counts, activity |
| zones | all zones in current site | clone status per zone |
| crews | all clones in current zone | role, brain, status, queue depth |
| tasks | all tasks in current zone | mode, status, clone, tokens |

**gaps:** none — all four scopes covered

---

## matrix.6 = clone address resolution

covers: usecase.8 (clone address)

| ind: --who value | ind: role valid | ind: @brain valid | ind: cli supplier has BrainCli | dep: target | dep: enroll | dep: brain |
|------------------|-----------------|-------------------|--------------------------------|-------------|-------------|------------|
| (none) | n/a | n/a | n/a | hero | find-or-enroll | hero default |
| `role` | yes | n/a | n/a | role on hero brain | find-or-enroll | hero default |
| `@brain` | n/a | yes | yes | hero on brain | find-or-enroll | specified |
| `role@brain` | yes | yes | yes | role on brain | find-or-enroll | specified |
| `clone.n` | n/a | n/a | n/a | specified clone | no | whatever .n has |
| `clone.n@brain` | n/a | yes | yes | specified clone | no | asserted match |
| `role++` | yes | n/a | n/a | new clone | force-enroll | hero default |
| `role@brain++` | yes | yes | yes | new clone | force-enroll | specified |
| `@brain++` | n/a | yes | yes | new hero clone | force-enroll | specified |
| `++` | n/a | n/a | n/a | new hero clone | force-enroll | hero default |
| `role++` | no | n/a | n/a | error | no | n/a |
| `@brain` | n/a | no | n/a | error: unknown alias | no | n/a |
| `@brain` | n/a | yes | no (atom-only) | error: lacks BrainCli | no | n/a |
| `clone.n@brain` | n/a | yes | yes | error: brain mismatch | no | n/a |

**note:** brain aliases in khlone.yml map to brain slugs that khlone resolves from the alias, then rhachet resolves the slug into BrainCli instances. the slug format is defined by rhachet and the brain suppliers (e.g., `opencode@xai/grok/code-fast-1` is illustrative). the task mode (`ask` vs `act`) maps to `BrainCli.ask()` vs `BrainCli.act()`.

**gaps:** none — all `--who` grammar combinations covered (default, role, brain, role+brain, index, index+brain assertion, force-enroll variants, and error cases)

---

## matrix.7 = skill dispatch route

covers: usecase.9 (skill dispatch)

| ind: skill location | dep: target | dep: enroll | dep: outcome |
|---------------------|-------------|------------|--------------|
| hero knows | hero | no | skill invoked |
| single role knows | that role | yes (if needed) | skill invoked |
| multiple roles know | n/a | no | error: ambiguity |
| no role knows | n/a | no | error: not found |

**gaps:** none — all route cases covered

---

## matrix.8 = cross-scope dispatch

covers: usecase.10 (cross-zone), usecase.11 (cross-site)

| ind: scope level | ind: target extant | dep: outcome | dep: user location |
|------------------|-------------------|--------------|-------------------|
| zone (same site) | yes | dispatch to zone | unchanged |
| zone (same site) | no | create zone, dispatch | unchanged |
| site (different repo) | yes | dispatch to site | unchanged |
| site (different repo) | no | error: not found | unchanged |

**gaps:** none — existence checks covered for both scopes

---

## matrix.9 = crash recovery

covers: usecase.12 (crash recovery)

| ind: failure mode | ind: detection | dep: crashed clone | dep: peer clones | dep: task | dep: user impact |
|-------------------|----------------|--------------------|--------------------|-----------|------------------|
| clone crashes | daemon catches SIGCHLD | auto-restart via BrainSeries (new episode, same series) | unaffected (process group isolation) | resume from checkpoint | none |
| shell exits | n/a (daemon owns PTY) | continues (daemon-owned) | continues | queue preserved | none |
| shell reopens | n/a | (was active) | (was active) | status shows progress | none |
| daemon crashes | orchestrator health monitor | lose supervisor, respawn via orchestrator | lose supervisor, respawn via orchestrator | preserved in state files | temporary (daemon restarts) |

**note:** clone crash isolation is enforced via process groups — each clone's brainCli runs in its own process group. daemon catches crashes per child and restarts just that clone. BrainSeries continuation ensures the new brainCli resumes within the same series (new episode, same series), so cross-context memory persists.

**gaps:** none — clone crash, daemon crash, and shell exit all covered

---

## matrix.10 = artifacts and logs

covers: usecase.13 (task artifacts), usecase.14 (transcript access)

| ind: query type | ind: scope | dep: shows |
|-----------------|------------|------------|
| status | --task id | mode, artifacts (summary, complete, tokens) |
| log | (none) | current clone transcript |
| log | --who clone | specified clone transcript |

**gaps:** none — artifact query and log query both covered

---

## matrix.11 = error conditions

covers: error experiences

| ind: condition | dep: error message | dep: suggestion |
|----------------|-------------------|-----------------|
| not in git repo | not in a git repo | use --site flag |
| khlone.yml absent | absent config | how to create khlone.yml |
| --watch + --talk | mutually exclusive flags | (none needed) |
| invalid zone format | invalid format | valid formats |
| unknown role++ | unknown role | list available roles |
| unknown @brain in --who | unknown brain alias | list available brains |
| atom-only @brain in --who | cli supplier lacks BrainCli | list brain aliases with BrainCli support |
| --who index + brain mismatch | brain mismatch | show actual brain for clone |
| supplier not installed | package not found | show install command |
| unknown --skill | skill not found | list available skills |
| ambiguous --skill | ambiguity | list roles, suggest --who |
| unknown --site | site not found | how to register site |

**gaps:** none — all documented error cases covered

---

## decomposition analysis

all matrices have 2-3 independent dimensions — no decomposition needed.

the behavioral boundaries are appropriately scoped:
- dispatch behavior (init × mode × queue mode)
- task mode enforcement (mode × action)
- observation modes (mode × invocation)
- status scope (pwd × explicit)
- clone address (--who grammar × role validity × brain validity × supplier BrainCli support)
- skill dispatch (location)
- cross-scope (level × existence)
- crash recovery (failure mode × detection × peer impact)
- artifacts/logs (query × scope)
- errors (condition)

each matrix is small enough to enumerate fully.

---

## coverage summary

| matrix | combinations | gaps |
|--------|--------------|------|
| dispatch behavior | 8 | 0 |
| task mode enforcement | 8 | 0 |
| observation modes | 5 | 0 |
| status scope | 8 | 0 |
| resource enumeration | 4 | 0 |
| clone address | 14 | 0 |
| skill dispatch | 4 | 0 |
| cross-scope dispatch | 4 | 0 |
| crash recovery | 4 | 0 |
| artifacts and logs | 3 | 0 |
| error conditions | 12 | 0 |

**total: 76 combinations, 0 gaps**
