# block A: headless dispatch (stateless)

> a single hero clone boots, receives tasks, and executes them headlessly via BrainCli. the daemon holds all state in memory — zero persistence, zero DAOs, zero `~/.khlone/`. the human dispatches `khlone act` or `khlone ask` and gets their shell back at once.

---

## read first

1. `./1.vision.md` — full vision: domain model, daemon architecture, domain operations (init, ask, act, status), flags, output legend
2. `./2.1.criteria.blackbox.md` — usecases 1 (instant dispatch), 2 (task mode enforcement), 3 (queue stack — partial: FIFO only), 6 (status — partial: zone-level only)
3. `./3.3.blueprint.v1.i1.md` — full blueprint: filediffs, codepaths (esp. 2.2 ask/act dispatch, 2.3 daemon loop, 2.5 status), contracts (infra, IPC, domain operations, CLI)
4. `./3.2.distill.domain._.v1.i1.md` — domain distillation: domain objects, operations, DAO contracts
5. `./3.3.blueprint.z1.ipc-message.v1.i1.md` — IPC message protocol design
6. `./1.vision.zoomin.braincli-lookup.md` — find-or-enroll logic for brainCli handles
7. `./3.5.decomposition.v1.i1.md` — block A section: "how state works without persistence", file counts, boundaries
8. `./3.1.research.claims._.v1.i1.md` — validated claims (IPC, PTY, process management)
9. `./priors/v2026_02_12.khlone-worksite/3.1.research.ipc-process-management.v1.i1.md` — IPC + process management research
10. `./priors/v2026_02_12.khlone-worksite/3.1.research.pty.v1.i1.md` — PTY research

---

## prerequisite

**block 0 must be complete.** the BrainCli handle (`genBrainCli`, `ask`, `act`, `executor.boot`, `terminal.onData`) must exist under `src/_topublish/`. this block consumes that handle inside the daemon.

---

## scope

### what to build

**this is the keystone block** — the largest (70 files) and the foundation for all other blocks.

**domain objects (11 files):**
- SiteManifest — parsed khlone.yml config shape
- Zone, ZoneAddress — zone identity and address literal
- ZoneDaemon, DaemonConnection — daemon metadata + IPC handle type
- Clone, CloneAddress, CloneStatus — clone identity + state
- Task, TaskMode (`ask` | `act`), TaskStatus (`queued` | `active` | `done` | `failed`)

**infra (9 prod, 9 test):**
- ipc: createIpcServer, createIpcClient, IpcMessage (subset: enqueue, status, status-response, task-complete, kill, ack, error)
- filesystem: getOneGitroot, getOneGitBranch — cwd derivation (read-only, no writes)
- process: spawnDetached, isProcessAlive, writePidFile, readPidFile — daemon lifecycle

note: no PTY infra here — BrainCli abstracts PTY away. the supplier (block 0) owns all PTY lifecycle internally. khlone's daemon calls `brainCli.ask()`, `.act()`, `.terminal.write()`, `.terminal.onData`, `.terminal.onExit` — never touches PTY directly.

**domain operations (12 prod, 12 test):**
- config: getOneSiteManifest (parse khlone.yml), getOneContextCli (derive zone + config from cwd), getOneRoleSlugByAlias, getOneBrainSlugByAlias
- zone: getOneZoneAddress (parse @branch format)
- clone: getOneCloneSlug (compute role.n)
- daemon: setZoneDaemon (spawn), getOneZoneDaemon (discover via pid), genZoneDaemon (find alive or spawn), getOneDaemonConnection (connect IPC)
- dispatch: dispatchTask (brainCli.ask/act), enqueueTask (IPC to daemon)

**cli + entry (8 prod):**
- invoke.ts (commander program, routes verbs)
- invokeInit (spawn daemon + verify config)
- invokeAsk, invokeAct (dispatch task)
- invokeStatus (query daemon via IPC, render zone-level view)
- sdk.ts (public exports)
- bin/run, bin/run.jit (shell entry)

**daemon entry (1 prod):**
- the supervisor process: boot hero brainCli, listen on unix socket, dequeue tasks, execute via brainCli.ask() or brainCli.act(), respond to IPC status queries

**test assets (4 files):**
- exampleSiteManifest, exampleClone, exampleTask, exampleZone

**acceptance (4 tests):**
- khlone.act, khlone.ask, khlone.queue (partial — FIFO only), khlone.status (basic — zone-level only)

### how state works (critical — read carefully)

the daemon **is** the state. zero persistence. all zone, clone, and task state lives in daemon memory:

```
daemon process (pid 1234)
├── zone: { address: '@feat/auth', site: 'ehmpathy/myrepo' }
├── hero: { slug: 'foreman.1', brainCli: <handle>, status: 'active' }
├── tasks:
│   ├── task-abc-123: { mode: 'act', prompt: '...', status: 'active' }
│   └── task-def-456: { mode: 'ask', prompt: '...', status: 'queued' }
└── ipc: unix socket at /tmp/khlone-zone-{hash}.sock
```

the CLI discovers the daemon via pid file → connects via unix socket → queries or dispatches via IPC. no filesystem state beyond the pid file and socket.

**tradeoff:** daemon death = total state loss. acceptable — durability comes in block F.

### IPC message subset for this block

only these message types are needed:

| type | direction | purpose |
|------|-----------|---------|
| `enqueue` | cli → daemon | queue a task to hero |
| `status` | cli → daemon | query zone state |
| `status-response` | daemon → cli | return clones + tasks |
| `task-complete` | daemon → cli | notify task done |
| `kill` | cli → daemon | graceful shutdown |
| `ack` | daemon → cli | acknowledge receipt |
| `error` | daemon → cli | report errors |

additional message types (attach, detach, talk, input, output, resize, disrupt) are added by later blocks.

### what NOT to build

- **no `~/.khlone/` directory.** no DAOs, no json/jsonl persistence.
- **no `--who` flag.** hero clone only. all tasks queue to the single hero.
- **no watch, talk, await.** dispatch is fire-and-check (use `khlone status`).
- **no crash recovery.** if the clone crashes, it stays dead until daemon restart.
- **no `--prioritize`, no `--when disrupt`.** tasks enqueue in FIFO order.
- **no `khlone list`.** needs multi-zone awareness from block G.
- **no smart status defaults.** needs orchestrator from block G.
- **no cross-zone/cross-site dispatch.**
- **no artifacts, no transcript capture.**

---

## file count

| layer | prod | test | total |
|-------|------|------|-------|
| domain.objects (11 shapes) | 11 | 0 | 11 |
| infra (ipc + filesystem + process) | 9 | 9 | 18 |
| domain.operations (config, zone, clone, daemon, dispatch) | 12 | 12 | 24 |
| contract/cli + sdk | 6 | 0 | 6 |
| bin | 2 | 0 | 2 |
| daemon entry | 1 | 0 | 1 |
| test assets | 4 | 0 | 4 |
| acceptance | 0 | 4 | 4 |
| **total** | **45** | **25** | **70** |

---

## usecases fulfilled

| usecase | status |
|---------|--------|
| usecase.1: instant dispatch | **yes** — ask/act return to shell at once, task queued to hero |
| usecase.2: task mode enforcement | **yes** — ask → brainCli.ask(), act → brainCli.act() |
| usecase.3: queue stack | **partial** — FIFO enqueue works; --prioritize deferred to block D |
| usecase.6: status | **partial** — zone-level via IPC query; smart defaults deferred to block G |

---

## playtests

```sh
$ khlone act "implement auth"

✓ task-abc-123 → foreman.1 (@feat/auth)
$ _                              # instant return, shell is yours

$ khlone ask "what files changed?"

✓ task-def-456 → foreman.1 (@feat/auth)

$ khlone status

zone @feat/auth (local)
├─ ● foreman.1  45%  implement auth
└─ queue 2 tasks
```

---

## done when

- [ ] `khlone act "prompt"` dispatches a task and returns to shell immediately
- [ ] `khlone ask "prompt"` dispatches a task in ask mode (no file mutation tools)
- [ ] daemon spawns as a detached process, survives shell exit
- [ ] daemon boots hero brainCli via `executor.boot({ mode: 'dispatch' })`
- [ ] tasks execute in FIFO order via brainCli.ask() or brainCli.act()
- [ ] `khlone status` shows zone-level view (active clone, queue depth)
- [ ] daemon discoverable via pid file + unix socket
- [ ] IPC round-trip: cli → daemon → response works for enqueue + status
- [ ] acceptance test: act → status → verify task queued
- [ ] acceptance test: ask → verify task mode is ask
