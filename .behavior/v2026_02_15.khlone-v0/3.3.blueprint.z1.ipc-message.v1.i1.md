# khlone v0: zoomin — IPC message protocol

> why the khlone CLI and daemon communicate via typed IPC messages, what each message does, and the exact minimum set

---

## why IPC messages

the khlone architecture separates two processes: the **khlone CLI** (thin client) and the **zone daemon** (process supervisor). they must communicate.

the daemon owns all brain CLI processes for a zone — it spawns them, dispatches tasks to them, relays their output, reboots them on crash, and switches their modes for talk. the khlone CLI is a thin executor that sends commands to the daemon and relays bytes to the user's terminal.

these two processes need a typed protocol to coordinate. that protocol is IpcMessage.

### why not function calls?

the daemon is a **separate, long-lived process**. the khlone CLI starts, sends a command, and exits (or relays bytes, then exits). they share no memory. function calls between them are impossible — IPC is the only option.

### why typed messages?

untyped bytes on a socket require ad-hoc parse. typed messages (serialized JSON with a `type` discriminator) give us:

1. **exhaustive route** — the daemon can switch on `msg.type` and handle every variant. the compiler catches any gap.
2. **schema validation** — each message type has a known shape. malformed messages are detectable at the boundary.
3. **protocol evolution** — add a new message type without any break to extant types. the daemon can reject unknown types via `error` response.
4. **test** — unit test each message type's serialization and handler in isolation.

### why unix domain socket?

unix domain sockets are the standard IPC mechanism for local daemon-client architectures (tmux, docker, systemd, postgresql). they provide:

- **~0.13ms latency** per message (770x below Nielsen's 100ms perception threshold [^nielsen])
- **bidirectional stream** — both sides can send at any time
- **file-based address** — `/tmp/khlone-zone-{id}.sock` — discoverable by any process
- **peer credential check** — the OS exposes the sender's uid/gid for auth
- **zero network overhead** — kernel copies bytes between processes, no TCP stack

---

## how the protocol works

### transport: nd-JSON over unix socket

each IPC message is a JSON object terminated by newline (`\n`). this is nd-JSON (newline-delimited JSON) — the same format claude code, codex, and opencode use for their structured output modes.

```
{"type":"dispatch","task":{...},"when":"enqueue","priority":null}\n
{"type":"ack"}\n
```

**why nd-JSON:**
- trivial to parse: `line.split('\n').filter(Boolean).map(JSON.parse)`
- trivial to emit: `JSON.stringify(msg) + '\n'`
- no length prefix, no binary frame, no protocol negotiation
- human-readable for debug: `socat - UNIX-CONNECT:/tmp/khlone-zone-*.sock`

### three protocol patterns

every IPC message falls into one of three patterns:

| pattern | direction | response? | example |
|---|---|---|---|
| **command** | CLI → daemon | yes (waits for response) | `dispatch`, `status`, `talk`, `kill` |
| **relay** | CLI → daemon (fire-and-forget) | no | `input`, `resize`, `detach` |
| **push** | daemon → CLI (unsolicited) | no | `output`, `talk-end`, `task-complete` |

**command** messages are request-response. the CLI sends, then blocks on the socket until the daemon responds. the response is always one of: a specialized response type (e.g., `status-response`, `talk-ready`), `ack` (generic success), or `error`.

**relay** messages are fire-and-forget. the CLI sends and does not wait. used for high-frequency byte relay in talk mode — the CLI cannot afford to block on each keystroke.

**push** messages are daemon-initiated. the daemon sends them to the CLI without a prior request. used for output stream and lifecycle events. the CLI must be ready to receive these at any time after an `attach` or `talk` command.

### connection lifecycle

```
1. CLI opens unix socket connection
2. CLI sends one or more commands
3. daemon responds to each command
4. (if watch/talk) daemon pushes output messages to CLI
5. CLI closes socket (or daemon detects disconnect)
```

a single CLI invocation opens one connection and holds it for the duration of the command. `khlone act "task"` opens, sends `dispatch`, receives `ack`, closes. `khlone watch` opens, sends `attach`, then holds the connection open to receive `output` pushes until ctrl+c.

---

## the message types

### minimum analysis

the current blueprint lists 16 message variants. the question: which are essential, which are redundant?

**analysis per message:**

| message | pattern | essential? | why |
|---|---|---|---|
| `enqueue` | command | **merge candidate** | same shape as `disrupt` — unify into `dispatch` |
| `disrupt` | command | **merge candidate** | same shape as `enqueue` — unify into `dispatch` |
| `status` | command | **yes** | query daemon state |
| `status-response` | response | **yes** | paired response to `status` |
| `attach` | command | **yes** | subscribe to clone output (watch mode) |
| `detach` | relay | **yes** | unsubscribe from output (watch and talk) |
| `talk` | command | **yes** | switch to interact mode, start byte relay |
| `talk-ready` | response | **yes** | paired response to `talk` — CLI must wait for reboot |
| `talk-end` | push | **yes** | daemon tells CLI talk mode ended |
| `input` | relay | **yes** | keystroke relay in talk mode |
| `output` | push | **yes** | clone output relay (watch and talk) |
| `resize` | relay | **yes** | terminal size proxy in talk mode |
| `task-complete` | push | **yes** | notify CLI that task finished (for `--await`) |
| `kill` | command | **yes** | graceful daemon shutdown |
| `ack` | response | **yes** | generic success response for commands |
| `error` | response | **yes** | generic failure response for commands |

**one merge candidate:** `enqueue` + `disrupt` → `dispatch` with a `when` field.

### the consolidation: `dispatch` replaces `enqueue` + `disrupt`

`enqueue` and `disrupt` both deliver a task to a clone. the difference is queue semantics:
- `enqueue`: add to queue (default), or add at front (`priority`)
- `disrupt`: pause current task, handle now

these can merge into one message type with a `when` discriminator:

```ts
| { type: 'dispatch'; task: Task; when: 'enqueue' | 'disrupt'; priority: number | null }
```

the daemon routes:
- `when: 'enqueue'` → add task to clone queue at `priority` position
- `when: 'disrupt'` → pause current task, execute new task immediately

**why merge:** the daemon handler for both is the same entry point (`dispatchTask`), differentiated by schedule semantics. one message type with a union field is more honest than two types with identical shapes minus one field.

**why NOT merge:** `enqueue` and `disrupt` map to separate domain operations (`enqueueTask.ts` and `disruptClone.ts`). separate IPC types make the message ↔ operation 1:1. this is a valid tradeoff — clarity at the IPC layer vs fewer types.

**recommendation:** merge. the IPC layer is infra — it should be minimal. the daemon router can dispatch to different domain operations based on `when`. the 1:1 match is a nice-to-have, not a requirement.

---

## the minimum set: 15 message types

after the `enqueue` + `disrupt` → `dispatch` merge:

```ts
type IpcMessage =
  // === commands (CLI → daemon, response expected) ===
  | { type: 'dispatch'; task: Task; when: 'enqueue' | 'disrupt'; priority: number | null }
  | { type: 'status' }
  | { type: 'attach'; cloneSlug: string }
  | { type: 'talk'; cloneSlug: string }
  | { type: 'kill' }

  // === responses (daemon → CLI, paired to command) ===
  | { type: 'ack' }
  | { type: 'error'; message: string }
  | { type: 'status-response'; clones: Clone[]; tasks: Task[] }
  | { type: 'talk-ready' }

  // === relay (CLI → daemon, fire-and-forget) ===
  | { type: 'input'; cloneSlug: string; data: string }
  | { type: 'resize'; cloneSlug: string; cols: number; rows: number }
  | { type: 'detach'; cloneSlug: string }

  // === push (daemon → CLI, unsolicited) ===
  | { type: 'output'; cloneSlug: string; data: string }
  | { type: 'talk-end'; reason: 'brain-exit' | 'detach'; code: number | null }
  | { type: 'task-complete'; taskSlug: string; output: string };
```

### per-message reference

#### commands (CLI → daemon)

**`dispatch`** — deliver a task to a clone.
- `task`: the task to dispatch (includes mode, prompt, clone ref)
- `when`: `'enqueue'` (add to queue) or `'disrupt'` (interrupt current work)
- `priority`: queue position for enqueue (null = end of queue, 0 = front)
- response: `ack` on success, `error` on failure
- used by: `khlone ask`, `khlone act`

**`status`** — query zone state.
- no fields — returns all clones and tasks for this zone
- response: `status-response`
- used by: `khlone status`, `khlone list crews`, `khlone list tasks`

**`attach`** — subscribe to a clone's output stream.
- `cloneSlug`: which clone to observe
- response: `ack`, then daemon pushes `output` messages
- the daemon pipes `brainCli.onData` to this client
- used by: `khlone watch`, `khlone act --watch`, `khlone ask --await`

**`talk`** — switch clone to interact mode and start bidirectional byte relay.
- `cloneSlug`: which clone to talk to
- response: `talk-ready` (after daemon finishes `brainCli.reboot({ mode: 'interact' })`)
- after `talk-ready`, daemon pushes `output` messages and accepts `input` messages
- used by: `khlone talk`, `khlone act --talk`

**`kill`** — graceful daemon shutdown.
- no fields
- response: `ack`, then daemon kills all clones and closes socket
- used by: internal lifecycle (daemon restart, zone cleanup)

#### responses (daemon → CLI)

**`ack`** — generic success response.
- no fields — the command succeeded
- response to: `dispatch`, `kill`, `attach`

**`error`** — generic failure response.
- `message`: human-readable error description
- response to: any command that fails

**`status-response`** — zone state data.
- `clones`: all clones in this zone with current status
- `tasks`: all tasks in this zone with current status
- response to: `status`

**`talk-ready`** — interact mode is live.
- no fields — the brain CLI has rebooted to interact mode and the byte relay is ready
- response to: `talk`
- signals the CLI to: set terminal to raw mode and start the relay loop

#### relay (CLI → daemon, fire-and-forget)

**`input`** — keystroke relay.
- `cloneSlug`: which clone receives the input
- `data`: raw bytes from the user's terminal (base64 or utf-8)
- daemon calls: `brainCli.write(data)`
- no response — fire-and-forget for latency (per-keystroke)
- only valid after `talk-ready`

**`resize`** — terminal size proxy.
- `cloneSlug`: which clone receives the resize
- `cols`, `rows`: new terminal dimensions
- daemon calls: `brainCli.resize(cols, rows)`
- no response — fire-and-forget
- only valid after `talk-ready`

**`detach`** — stop the relay.
- `cloneSlug`: which clone to detach from
- no response — fire-and-forget
- in watch mode: daemon stops the `output` pipe to this client
- in talk mode: daemon reboots to dispatch (`brainCli.reboot({ mode: 'dispatch' })`), then sends `talk-end`

#### push (daemon → CLI, unsolicited)

**`output`** — clone output bytes.
- `cloneSlug`: which clone produced this output
- `data`: raw bytes from `brainCli.onData`
- sent by daemon after `attach` or `talk-ready`
- in dispatch mode (watch): structured output from headless brain CLI
- in interact mode (talk): raw terminal output from brain CLI TUI
- the daemon also captures this to transcript — the IPC pipe is a second consumer

**`talk-end`** — talk mode ended.
- `reason`: `'brain-exit'` (brain CLI exited) or `'detach'` (user or CLI disconnected)
- `code`: exit code if brain-exit, null if detach
- sent by daemon when: brain CLI exits amid interact mode, or client sends `detach` amid talk
- signals the CLI to: restore terminal from raw mode, inform user, return to shell

**`task-complete`** — a task finished.
- `taskSlug`: which task completed
- `output`: the task's final output (for `--await` pipe to stdout)
- sent by daemon when: a task reaches `done` or `failed` status
- used by: `khlone ask --await`, `khlone act --await` — the CLI blocks until this arrives

---

## message flow per CLI verb

### `khlone act "implement auth"`

```
CLI                    daemon
 |  dispatch            |
 |  { task, when:       |
 |    'enqueue',        |
 |    priority: null }  |
 | ===================> |  -> add to hero clone queue
 |                      |
 |  ack                 |
 | <=================== |
 |                      |
 |  [CLI exits]         |
```

1 command, 1 response. instant.

### `khlone act "task" --await`

```
CLI                    daemon
 |  dispatch            |
 | ===================> |  -> add to queue
 |  ack                 |
 | <=================== |
 |                      |
 |  attach              |
 | ===================> |  -> pipe brainCli.onData to client
 |  ack                 |
 | <=================== |
 |                      |
 |  output (...)        |  <- clone works...
 | <~~~~~~~~~~~~~~~~~~~ |
 |  output (...)        |
 | <~~~~~~~~~~~~~~~~~~~ |
 |                      |
 |  task-complete       |  <- task done
 | <~~~~~~~~~~~~~~~~~~~ |
 |                      |
 |  detach              |
 | ~~~~~~~~~~~~~~~~~~=> |  -> stop output pipe
 |                      |
 |  [CLI exits,         |
 |   emits output       |
 |   to stdout]         |
```

2 commands + hold for push messages.

### `khlone watch`

```
CLI                    daemon
 |  attach              |
 | ===================> |  -> pipe brainCli.onData to client
 |  ack                 |
 | <=================== |
 |                      |
 |  output (...)        |  <- clone output stream
 | <~~~~~~~~~~~~~~~~~~~ |
 |  output (...)        |
 | <~~~~~~~~~~~~~~~~~~~ |
 |                      |
 |  [ctrl+c]            |
 |  detach              |
 | ~~~~~~~~~~~~~~~~~~=> |  -> stop output pipe
 |                      |
 |  [CLI exits]         |
```

1 command, then hold for output. detach on exit.

### `khlone talk`

```
CLI                    daemon
 |  talk                |
 | ===================> |  -> brainCli.reboot({ mode: 'interact' })
 |                      |
 |  talk-ready          |
 | <=================== |  <- reboot complete
 |                      |
 |  [set raw mode]      |
 |                      |
 |  input (keystroke)   |  -> brainCli.write()
 | ~~~~~~~~~~~~~~~~~~=> |
 |  output (response)   |  <- brainCli.onData
 | <~~~~~~~~~~~~~~~~~~~ |
 |  input (keystroke)   |
 | ~~~~~~~~~~~~~~~~~~=> |
 |  output (response)   |
 | <~~~~~~~~~~~~~~~~~~~ |
 |  resize (80x24)      |  -> brainCli.resize()
 | ~~~~~~~~~~~~~~~~~~=> |
 |                      |
 |  ... relay loop ...  |
 |                      |
 |  [brain CLI exits]   |  <- brainCli.onExit
 |                      |  -> brainCli.reboot({ mode: 'dispatch' })
 |  talk-end            |
 |  { reason:           |
 |    'brain-exit' }    |
 | <~~~~~~~~~~~~~~~~~~~ |
 |                      |
 |  [restore terminal]  |
 |  [CLI exits]         |
```

1 command, then bidirectional relay until talk-end.

### `khlone status`

```
CLI                    daemon
 |  status              |
 | ===================> |
 |                      |
 |  status-response     |
 |  { clones, tasks }   |
 | <=================== |
 |                      |
 |  [CLI renders tree,  |
 |   exits]             |
```

1 command, 1 response. simplest flow.

---

## why not fewer?

each message was evaluated for removal or merge. here is why the 15 that remain cannot shrink further:

### can `attach` merge into `talk`?

no. `attach` subscribes to output without mode change (watch mode). `talk` reboots the brain CLI to interact mode and adds bidirectional relay. the daemon behavior is fundamentally different: watch observes a dispatch-mode clone; talk takes control of an interact-mode clone. separate messages.

### can `detach` be implicit (just close the socket)?

partially. the daemon could treat socket close as implicit detach. but explicit `detach` allows the CLI to disconnect from one clone while the socket stays open for subsequent commands (e.g., detach from clone A, attach to clone B in the same session). explicit detach also enables the daemon to reboot to dispatch before the socket closes — cleaner lifecycle.

### can `talk-ready` fold into `ack`?

technically yes — `talk-ready` is just the success response to `talk`. but `talk-ready` carries semantic weight: "the brain CLI has finished its reboot and is live in interact mode." the CLI must not enter raw mode until this arrives. a distinct type makes the protocol self-evident. the alternative — to use `ack` and infer that `ack` means "reboot complete" for `talk` specifically — is fragile.

### can `talk-end` fold into `output`?

no. `output` carries raw bytes. `talk-end` carries structured metadata (`reason`, `code`). the CLI handles them differently: `output` → `process.stdout.write(data)`, `talk-end` → restore terminal + inform user. different shapes, different handlers.

### can `task-complete` fold into `output`?

no, same reason. `output` is raw bytes for the terminal. `task-complete` is structured data (`taskSlug`, `output`) for the `--await` handler. the CLI needs to know which task completed, not just receive raw bytes.

### can `status-response` fold into `ack`?

no. `ack` carries no data. `status-response` carries clones and tasks. they have different shapes. to use `ack` with a payload field would make `ack` not generic — it would just be `status-response` with a worse name.

### can `error` fold into `ack`?

no. `ack` = success, `error` = failure. to combine them into one type with a `success: boolean` field is possible but obfuscates the protocol — every consumer would need to check the boolean. separate types enable exhaustive match: the compiler forces you to handle both.

### can `kill` be replaced by process signals?

technically the CLI could send `SIGTERM` to the daemon pid. but:
1. the CLI may not know the daemon's pid (it connects via socket path, not pid)
2. signals cannot carry data (no graceful shutdown handshake)
3. the daemon already listens on the socket — one more message type is cleaner than a mix of IPC and signals

---

## what each message group is for

### dispatch group (`dispatch`, `ack`)

the reason khlone exists: queue work to clones. the CLI creates a task, sends it to the daemon, daemon queues it. one message type with a `when` discriminator covers both normal enqueue and disrupt.

### query group (`status`, `status-response`)

read-only state inspection. the CLI asks "what's the state of this zone?" and the daemon responds with clone and task data. used by `khlone status` and `khlone list`.

### observe group (`attach`, `detach`, `output`)

passive observation. the CLI subscribes to a clone's output stream. the daemon pipes `brainCli.onData` to the subscriber. `detach` unsubscribes. this is the foundation that both watch mode and talk mode build on.

### talk group (`talk`, `talk-ready`, `talk-end`, `input`, `resize`)

bidirectional terminal relay. builds on top of the observe group (reuses `output` messages). adds: mode reboot (`talk` → `talk-ready`), keystroke relay (`input`), terminal size proxy (`resize`), and lifecycle signal (`talk-end`). this group is what makes the daemon a terminal multiplexer.

### lifecycle group (`kill`, `error`)

daemon lifecycle. `kill` for graceful shutdown. `error` for failure responses to any command.

### await group (`task-complete`)

task completion notification. used by `--await` to block the CLI until a task finishes. the daemon pushes this when a task reaches `done` or `failed` status.

---

## summary

| question | answer |
|---|---|
| why IPC messages? | daemon and CLI are separate processes — IPC is the only option |
| why typed messages? | exhaustive route, schema validation, safe protocol evolution |
| why unix socket? | ~0.13ms latency, bidirectional, file-based address, no network overhead |
| why nd-JSON? | trivial parse/emit, human-readable, same as brain CLI output formats |
| how many patterns? | 3 — command (request-response), relay (fire-and-forget), push (unsolicited) |
| how many message types? | 15 (down from 16 via `enqueue` + `disrupt` → `dispatch` merge) |
| can it be fewer? | no — each type serves a distinct protocol role with a different shape or handler |

### the 15 types at a glance

| type | pattern | group | purpose |
|---|---|---|---|
| `dispatch` | command | dispatch | deliver task to clone queue |
| `status` | command | query | request zone state |
| `status-response` | response | query | return zone state |
| `attach` | command | observe | subscribe to clone output |
| `detach` | relay | observe | unsubscribe from output |
| `output` | push | observe | clone output bytes |
| `talk` | command | talk | switch to interact mode |
| `talk-ready` | response | talk | interact mode is live |
| `talk-end` | push | talk | talk mode ended |
| `input` | relay | talk | keystroke relay |
| `resize` | relay | talk | terminal size proxy |
| `task-complete` | push | await | task finished |
| `kill` | command | lifecycle | graceful shutdown |
| `ack` | response | lifecycle | generic success |
| `error` | response | lifecycle | generic failure |

### the final type

```ts
type IpcMessage =
  // commands (CLI -> daemon, response expected)
  | { type: 'dispatch'; task: Task; when: 'enqueue' | 'disrupt'; priority: number | null }
  | { type: 'status' }
  | { type: 'attach'; cloneSlug: string }
  | { type: 'talk'; cloneSlug: string }
  | { type: 'kill' }

  // responses (daemon -> CLI, paired to command)
  | { type: 'ack' }
  | { type: 'error'; message: string }
  | { type: 'status-response'; clones: Clone[]; tasks: Task[] }
  | { type: 'talk-ready' }

  // relay (CLI -> daemon, fire-and-forget)
  | { type: 'input'; cloneSlug: string; data: string }
  | { type: 'resize'; cloneSlug: string; cols: number; rows: number }
  | { type: 'detach'; cloneSlug: string }

  // push (daemon -> CLI, unsolicited)
  | { type: 'output'; cloneSlug: string; data: string }
  | { type: 'talk-end'; reason: 'brain-exit' | 'detach'; code: number | null }
  | { type: 'task-complete'; taskSlug: string; output: string };
```

---

## citations

### unix domain socket latency

- [^uds-bench] [benchmark TCP/IP, unix domain socket and named pipe](https://www.yanxurui.cc/posts/server/2023-11-28-benchmark-tcp-uds-namedpipe/) — measured ~2.3us for UDS vs ~3.6us for TCP loopback on linux
- [^uds-node] [node.js developer's guide to unix domain sockets: 50% lower latency than TCP](https://nodevibe.substack.com/p/the-nodejs-developers-guide-to-unix) — measured 130us for UDS vs 334us for TCP in node.js
- [^ipc-bench] [rigtorp/ipc-bench: latency benchmarks of unix IPC mechanisms](https://github.com/rigtorp/ipc-bench) — comprehensive benchmark across UDS, pipes, shared memory

### human perception thresholds

- [^nielsen] [response time limits: 3 important limits (nielsen norman group)](https://www.nngroup.com/articles/response-times-3-important-limits/) — 100ms for instantaneous feel, 1s for uninterrupted thought, 10s for attention
- [^chi15] [how much faster is fast enough? (CHI 2015)](https://www.tactuallabs.com/papers/howMuchFasterIsFastEnoughCHI15.pdf) — just-noticeable differences: ~33ms for drag, ~82ms for tap
- [^latency17] [characterize latency perception thresholds (2017)](https://www.researchgate.net/publication/317801603_Are_100_ms_Fast_Enough_Characterizing_Latency_Perception_Thresholds_in_Mouse-Based_Interaction) — range 34-137ms, mean 65ms

### nd-JSON / JSONL protocol precedent

- [^ndjson] [ndjson specification](https://github.com/ndjson/ndjson-spec) — newline-delimited JSON format spec
- [^claude-cli] [claude code CLI reference](https://code.claude.com/docs/en/cli-reference) — `--output-format stream-json` emits nd-JSON
- [^codex-cli] [openai codex CLI non-interactive mode](https://developers.openai.com/codex/noninteractive/) — `--json` flag for JSONL event stream

### tmux architecture (SCM_RIGHTS)

- [^tmux-proc] [tmux/proc.c (github)](https://github.com/tmux/tmux/blob/master/proc.c) — `proc_send` passes fd via `imsg_compose`
- [^tmux-client] [tmux/client.c (github)](https://github.com/tmux/tmux/blob/master/client.c) — client passes tty fd to server
- [^scm-rights] [know your SCM_RIGHTS (cloudflare blog)](https://blog.cloudflare.com/know-your-scm_rights/) — SCM_RIGHTS mechanism explainer

### docker attach (byte relay)

- [^docker-attach] [docker/container_attach.go (github)](https://github.com/jessfraz/docker/blob/master/client/container_attach.go) — HTTP POST then connection hijack to raw stream
- [^docker-hijack] [docker hijack protocol (gist)](https://gist.github.com/fuweid/20583775d10028b84e40cf2fbb3faf75) — HTTP-to-raw-stream upgrade protocol

### unix socket in daemon-client architectures

- [^systemd-socket] [systemd.socket(5) man page](https://www.freedesktop.org/software/systemd/man/latest/systemd.socket.html) — socket activation via UDS
- [^pg-uds] [postgresql: connections and authentication](https://www.postgresql.org/docs/current/runtime-config-connection.html) — `unix_socket_directories` for local connections

### typed discriminated unions for protocols

- [^ts-unions] [typescript handbook: unions and intersection types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html) — official documentation
- [^ts-deep-dive] [discriminated unions (typescript deep dive)](https://basarat.gitbook.io/typescript/type-system/discriminated-unions) — exhaustive match pattern
- [^eip-fire-forget] [fire-and-forget (enterprise integration patterns)](https://www.enterpriseintegrationpatterns.com/patterns/conversation/FireAndForget.html) — one-way message pattern
- [^electron-ipc] [electron IPC tutorial](https://www.electronjs.org/docs/latest/tutorial/ipc) — request-response IPC in electron
