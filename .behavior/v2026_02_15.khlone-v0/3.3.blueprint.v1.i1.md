# khlone v0: blueprint

> implementation plan for site orchestration

---

## 1. filediffs

**legend:**
- `[+] create` — file to create
- `[~] update` — file to update
- `[-] delete` — file to delete

```
[~] package.json                                    # add runtime deps, bin entry
[+] bin/run                                         # bash router: bun or jit
[+] bin/run.jit                                     # node --experimental-strip-types
[+] bin/run.bun                                     # bun compiled fast path

src/
├── [+] index.ts                                    # re-exports contract/sdk.ts

├── contract/
│   ├── cli/
│   │   ├── [+] invoke.ts                           # commander program, registers verbs
│   │   ├── [+] invokeInit.ts                       # khlone init
│   │   ├── [+] invokeAsk.ts                        # khlone ask "..."
│   │   ├── [+] invokeAct.ts                        # khlone act "..."
│   │   ├── [+] invokeList.ts                       # khlone list <scope>
│   │   ├── [+] invokeStatus.ts                     # khlone status [scope]
│   │   ├── [+] invokeWatch.ts                      # khlone watch
│   │   ├── [+] invokeTalk.ts                       # khlone talk
│   │   └── [+] invokeLog.ts                        # khlone log
│   └── [+] sdk.ts                                  # public sdk exports

├── domain.objects/
│   ├── [+] Orchestrator.ts
│   ├── [+] Site.ts
│   ├── [+] SiteManifest.ts
│   ├── [+] Zone.ts
│   ├── [+] ZoneAddress.ts
│   ├── [+] ZoneDaemon.ts
│   ├── [+] Clone.ts
│   ├── [+] CloneAddress.ts
│   ├── [+] CloneStatus.ts
│   ├── [+] CloneCheckpoint.ts
│   ├── [+] CloneTranscriptEmission.ts
│   ├── [+] DaemonConnection.ts
│   ├── [+] Task.ts
│   ├── [+] TaskMode.ts
│   ├── [+] TaskStatus.ts
│   └── [+] TaskArtifact.ts

├── domain.operations/
│   ├── clone/
│   │   ├── [+] setClone.ts
│   │   ├── [+] setClone.test.ts
│   │   ├── [+] getOneClone.ts
│   │   ├── [+] getOneClone.test.ts
│   │   ├── [+] genClone.ts
│   │   ├── [+] genClone.test.ts
│   │   ├── [+] getOneCloneSlug.ts
│   │   ├── [+] getOneCloneSlug.test.ts
│   │   ├── [+] getOneCloneNextIndex.ts
│   │   ├── [+] getOneCloneNextIndex.test.ts
│   │   ├── [+] getOneCloneAddress.ts
│   │   └── [+] getOneCloneAddress.test.ts
│   │
│   ├── config/
│   │   ├── [+] getOneSiteManifest.ts
│   │   ├── [+] getOneSiteManifest.integration.test.ts
│   │   ├── [+] genSiteManifest.ts
│   │   ├── [+] genSiteManifest.integration.test.ts
│   │   ├── [+] getOneContextCli.ts
│   │   ├── [+] getOneContextCli.integration.test.ts
│   │   ├── [+] getOneRoleSlugByAlias.ts
│   │   ├── [+] getOneRoleSlugByAlias.test.ts
│   │   ├── [+] getOneBrainSlugByAlias.ts
│   │   └── [+] getOneBrainSlugByAlias.test.ts
│   │
│   ├── daemon/
│   │   ├── [+] setZoneDaemon.ts
│   │   ├── [+] setZoneDaemon.integration.test.ts
│   │   ├── [+] getOneDaemonConnection.ts
│   │   ├── [+] getOneDaemonConnection.integration.test.ts
│   │   ├── [+] getOneZoneDaemon.ts
│   │   ├── [+] getOneZoneDaemon.integration.test.ts
│   │   ├── [+] genZoneDaemon.ts
│   │   ├── [+] genZoneDaemon.integration.test.ts
│   │   ├── [+] genCloneViaDaemon.ts
│   │   ├── [+] genCloneViaDaemon.integration.test.ts
│   │   ├── [+] setCloneViaDaemon.ts
│   │   └── [+] setCloneViaDaemon.integration.test.ts
│   │
│   ├── dispatch/
│   │   ├── [+] dispatchTask.ts
│   │   ├── [+] dispatchTask.integration.test.ts
│   │   ├── [+] dispatchSkill.ts
│   │   ├── [+] dispatchSkill.test.ts
│   │   ├── [+] enqueueTask.ts
│   │   ├── [+] enqueueTask.integration.test.ts
│   │   ├── [+] disruptClone.ts
│   │   └── [+] disruptClone.integration.test.ts
│   │
│   ├── observe/
│   │   ├── [+] setTerminalToWatchClone.ts
│   │   ├── [+] setTerminalToWatchClone.integration.test.ts
│   │   ├── [+] setTerminalToTalkWithClone.ts
│   │   ├── [+] setTerminalToTalkWithClone.integration.test.ts
│   │   ├── [+] setTerminalToDetach.ts
│   │   ├── [+] setTerminalToDetach.integration.test.ts
│   │   ├── [+] setTerminalToAwaitTask.ts
│   │   └── [+] setTerminalToAwaitTask.integration.test.ts
│   │
│   ├── orchestrator/
│   │   ├── [+] genOrchestrator.ts
│   │   ├── [+] genOrchestrator.integration.test.ts
│   │   ├── [+] setSite.ts
│   │   ├── [+] setSite.integration.test.ts
│   │   ├── [+] getOneSiteBySlug.ts
│   │   ├── [+] getOneSiteBySlug.integration.test.ts
│   │   ├── [+] getAllSites.ts
│   │   └── [+] getAllSites.integration.test.ts
│   │
│   ├── site/
│   │   ├── [+] getOneSite.ts
│   │   ├── [+] getOneSite.integration.test.ts
│   │   ├── [+] genSite.ts
│   │   ├── [+] genSite.integration.test.ts
│   │   ├── [+] getAllZonesForSite.ts
│   │   └── [+] getAllZonesForSite.integration.test.ts
│   │
│   ├── status/
│   │   ├── [+] getOneStatusZone.ts
│   │   ├── [+] getOneStatusZone.test.ts
│   │   ├── [+] getOneStatusSite.ts
│   │   ├── [+] getOneStatusSite.test.ts
│   │   ├── [+] getOneStatusOrchestrator.ts
│   │   ├── [+] getOneStatusOrchestrator.test.ts
│   │   ├── [+] getOneStatusTask.ts
│   │   ├── [+] getOneStatusTask.test.ts
│   │   ├── [+] getOneStatusClone.ts
│   │   ├── [+] getOneStatusClone.test.ts
│   │   ├── [+] getOneStatusScope.ts
│   │   └── [+] getOneStatusScope.test.ts
│   │
│   ├── task/
│   │   ├── [+] genTask.ts
│   │   ├── [+] genTask.test.ts
│   │   ├── [+] genTaskArtifacts.ts
│   │   ├── [+] genTaskArtifacts.integration.test.ts
│   │   ├── [+] setTaskArtifacts.ts
│   │   ├── [+] setTaskArtifacts.integration.test.ts
│   │   ├── [+] getOneTaskSlug.ts
│   │   ├── [+] getOneTaskSlug.test.ts
│   │   ├── [+] setTaskPriority.ts
│   │   └── [+] setTaskPriority.test.ts
│   │
│   └── zone/
│       ├── [+] setZone.ts
│       ├── [+] setZone.integration.test.ts
│       ├── [+] genZone.ts
│       ├── [+] genZone.integration.test.ts
│       ├── [+] getOneZoneAddress.ts
│       ├── [+] getOneZoneAddress.test.ts
│       ├── [+] getOneZoneByAddress.ts
│       ├── [+] getOneZoneByAddress.integration.test.ts
│       ├── [+] getAllClonesForZone.ts
│       ├── [+] getAllClonesForZone.integration.test.ts
│       ├── [+] getAllTasksForZone.ts
│       └── [+] getAllTasksForZone.integration.test.ts

├── access/
│   └── daos/
│       ├── daoOrchestrator/
│       │   └── [+] index.ts
│       ├── daoSite/
│       │   └── [+] index.ts
│       ├── daoZone/
│       │   └── [+] index.ts
│       ├── daoCrew/
│       │   └── [+] index.ts
│       ├── daoClone/
│       │   └── [+] index.ts
│       ├── daoCloneCheckpoint/
│       │   └── [+] index.ts
│       ├── daoCloneTranscript/
│       │   └── [+] index.ts
│       └── daoTask/
│           └── [+] index.ts

├── infra/
│   ├── pty/
│   │   ├── [+] spawnPty.ts                        # node-pty wrapper: spawn + configure
│   │   ├── [+] spawnPty.integration.test.ts
│   │   ├── [+] attachPty.ts                       # attach terminal to extant pty
│   │   ├── [+] attachPty.integration.test.ts
│   │   ├── [+] detachPty.ts                       # release terminal from pty
│   │   └── [+] detachPty.integration.test.ts
│   │
│   ├── ipc/
│   │   ├── [+] createIpcServer.ts                 # unix socket server for daemon
│   │   ├── [+] createIpcServer.integration.test.ts
│   │   ├── [+] createIpcClient.ts                 # unix socket client for cli
│   │   ├── [+] createIpcClient.integration.test.ts
│   │   ├── [+] IpcMessage.ts                      # typed message protocol
│   │   └── [+] IpcMessage.test.ts
│   │
│   ├── filesystem/
│   │   ├── [+] readJsonFile.ts                    # json read with cast
│   │   ├── [+] readJsonFile.integration.test.ts
│   │   ├── [+] writeJsonFile.ts                   # json write (atomic via tmp+rename)
│   │   ├── [+] writeJsonFile.integration.test.ts
│   │   ├── [+] appendJsonlFile.ts                 # jsonl append
│   │   ├── [+] appendJsonlFile.integration.test.ts
│   │   ├── [+] readJsonlFile.ts                   # jsonl read (parse all lines)
│   │   ├── [+] readJsonlFile.integration.test.ts
│   │   ├── [+] getOneGitroot.ts                   # cwd → gitroot
│   │   ├── [+] getOneGitroot.integration.test.ts
│   │   ├── [+] getOneGitBranch.ts                 # cwd → current branch
│   │   └── [+] getOneGitBranch.integration.test.ts
│   │
│   └── process/
│       ├── [+] spawnDetached.ts                   # detach subprocess (daemon launch)
│       ├── [+] spawnDetached.integration.test.ts
│       ├── [+] isProcessAlive.ts                  # kill(pid, 0) liveness check
│       ├── [+] isProcessAlive.test.ts
│       ├── [+] writePidFile.ts                    # /tmp/khlone-zone-{id}.pid
│       ├── [+] writePidFile.integration.test.ts
│       ├── [+] readPidFile.ts
│       └── [+] readPidFile.integration.test.ts

└── __test_assets__/
    ├── [+] exampleSiteManifest.ts                 # valid khlone.yml parsed
    ├── [+] exampleClone.ts                        # example clone entity
    ├── [+] exampleTask.ts                         # example task entity
    ├── [+] exampleZone.ts                         # example zone entity
    ├── [+] exampleSite.ts                         # example site entity
    └── [+] exampleOrchestrator.ts                 # example orchestrator entity

acceptance/
├── [+] khlone.act.acceptance.test.ts              # usecase.1: instant dispatch (act)
├── [+] khlone.ask.acceptance.test.ts              # usecase.1: instant dispatch (ask)
├── [+] khlone.queue.acceptance.test.ts            # usecase.3: queue stack
├── [+] khlone.watch.acceptance.test.ts            # usecase.4: observation (watch)
├── [+] khlone.talk.acceptance.test.ts             # usecase.4: observation (talk)
├── [+] khlone.await.acceptance.test.ts            # usecase.5: block output
├── [+] khlone.status.acceptance.test.ts           # usecase.6: smart status
├── [+] khlone.list.acceptance.test.ts             # usecase.7: resource enumeration
├── [+] khlone.who.acceptance.test.ts              # usecase.8: clone address
├── [+] khlone.skill.acceptance.test.ts            # usecase.9: skill dispatch
├── [+] khlone.crosszone.acceptance.test.ts        # usecase.10: cross-zone dispatch
├── [+] khlone.crosssite.acceptance.test.ts        # usecase.11: cross-site dispatch
├── [+] khlone.crash.acceptance.test.ts            # usecase.12: crash recovery
├── [+] khlone.artifacts.acceptance.test.ts        # usecase.13: task artifacts
└── [+] khlone.log.acceptance.test.ts              # usecase.14: transcript access
```

### file count

| layer | files (prod) | files (test) | total |
|-------|-------------|-------------|-------|
| contract/cli | 9 | 0 | 9 |
| contract/sdk | 1 | 0 | 1 |
| domain.objects | 16 | 0 | 16 |
| domain.operations | 49 | 49 | 98 |
| access/daos | 8 | 0 | 8 |
| infra | 12 | 12 | 24 |
| __test_assets__ | 6 | 0 | 6 |
| bin | 3 | 0 | 3 |
| acceptance | 0 | 15 | 15 |
| root | 2 | 0 | 2 |
| **total** | **106** | **76** | **182** |

---

## 2. codepaths

**legend:**
- `[+]` create — codepath to create
- `[~]` update — codepath to update
- `[○]` retain — codepath to retain
- `[-]` delete — codepath to delete
- `[←]` reuse — codepath to reuse from elsewhere
- `[→]` eject — codepath to decompose for reuse

### 2.1 cli entry

```
[+] bin/run                                          # bash: detect bun or jit, dispatch
[+] bin/run.jit                                      # node --experimental-strip-types src/contract/cli/invoke.ts
[+] bin/run.bun                                      # bun compiled binary (future)

[+] invoke.ts
  ├── [←] commander                                  # reuse: cli framework (npm)
  ├── [+] program.command('init')   → invokeInit
  ├── [+] program.command('ask')    → invokeAsk
  ├── [+] program.command('act')    → invokeAct
  ├── [+] program.command('list')   → invokeList
  ├── [+] program.command('status') → invokeStatus
  ├── [+] program.command('watch')  → invokeWatch
  ├── [+] program.command('talk')   → invokeTalk
  └── [+] program.command('log')    → invokeLog
```

### 2.2 ask/act dispatch (the core flow)

```
[+] invokeAsk / invokeAct
  ├── [+] parse cli flags: prompt, --who, --zone, --site, --skill, --when, --watch, --talk, --await, --prioritize
  │
  ├── [+] getOneContextCli({ cwd })                  # derive site + zone + config from cwd
  │   ├── [+] getOneGitroot({ cwd })                 # infra: cwd → gitroot
  │   ├── [+] getOneGitBranch({ cwd })               # infra: cwd → current branch
  │   ├── [+] getOneSiteManifest({ path })            # config: parse khlone.yml at gitroot
  │   │   └── [←] yaml                               # reuse: yaml parser (npm)
  │   ├── [+] genOrchestrator({ path? })              # orchestrator: load or init ~/.khlone/
  │   │   └── [+] daoOrchestrator.get.byRef           # access: read orchestrator.json
  │   └── [+] genSite({ path, orchestrator })         # site: find or register in orchestrator
  │       ├── [+] getOneSite({ path })                # site: load from gitroot
  │       ├── [+] getOneSiteBySlug({ orchestrator, slug })
  │       └── [+] setSite({ orchestrator, site })     # orchestrator: register site
  │           └── [+] daoSite.set.upsert              # access: write site.json
  │
  ├── [+] genZone({ site, branch, path })             # zone: find extant or auto-init
  │   ├── [+] daoZone.get.byRef                       # access: read zone.json
  │   └── [+] setZone({ site, branch, path })         # zone: bind worktree
  │       ├── [+] daoZone.set.upsert                  # access: write zone.json
  │       └── [+] genClone(...)                        # zone: enroll hero clone
  │
  ├── [+] getOneCloneAddress({ token })               # clone: parse --who value
  │   └── [+] CloneAddress literal                    # pure parse, no deps
  │
  ├── [+] genClone({ zone, address, config })         # clone: alias lookup + find-or-enroll
  │   ├── [+] getOneRoleSlugByAlias({ alias, config })
  │   ├── [+] getOneBrainSlugByAlias({ alias, config })
  │   ├── [+] getOneClone({ zone, role, brain })      # clone: find extant
  │   │   ├── [+] daoCrew.get.all                     # access: read crew.json
  │   │   └── [+] daoClone.get.byRef                  # access: read clone.json
  │   └── [+] setClone({ zone, role, brain, index? }) # clone: enroll new
  │       ├── [+] getOneCloneNextIndex({ zone, role })
  │       ├── [+] getOneCloneSlug({ role, index })
  │       ├── [←] rhachet.enrollActor                  # reuse: rhachet actor enrollment
  │       ├── [+] daoClone.set.upsert                 # access: write clone.json
  │       └── [+] daoCrew.set.upsert                  # access: write crew.json (ref)
  │
  ├── [+] genZoneDaemon({ zone })                     # daemon: find alive or spawn fresh
  │   ├── [+] getOneZoneDaemon({ zone })              # daemon: discover via pid file
  │   │   ├── [+] readPidFile                         # infra: read /tmp/khlone-zone-*.pid
  │   │   └── [+] isProcessAlive({ pid })             # infra: kill(pid, 0)
  │   └── [+] setZoneDaemon({ zone })                 # daemon: spawn detached process
  │       ├── [+] spawnDetached                        # infra: child_process.spawn({ detached })
  │       ├── [+] writePidFile                         # infra: write pid file
  │       └── [+] createIpcServer                      # infra: bind unix socket
  │
  ├── [+] genTask({ mode, prompt, skill?, clone, zone })  # task: assemble with computed slug
  │   ├── [+] getOneTaskSlug()                        # task: generate task-{short-uuid}
  │   │   └── [←] uuid-fns                            # reuse: short uuid (npm)
  │   └── [+] daoTask.set.upsert                      # access: write task.json
  │
  ├── [+] enqueueTask({ task, clone, priority? })     # dispatch: send to daemon via ipc
  │   ├── [+] getOneDaemonConnection({ zone })        # daemon: connect to unix socket
  │   │   └── [+] createIpcClient                     # infra: connect to unix socket
  │   └── [+] IpcMessage { type: 'enqueue', task }    # infra: typed ipc message
  │
  └── [+] (optional) setTerminalToWatchClone / setTerminalToTalkWithClone / setTerminalToAwaitTask
      └── depends on --watch / --talk / --await flags
```

### 2.3 daemon loop (the supervisor)

```
[+] daemon entry (spawned by setZoneDaemon)
  ├── [+] createIpcServer({ socketPath })             # infra: listen on unix socket
  │   └── [+] route IpcMessage
  │       ├── [+] 'enqueue'              → enqueueTask to clone's queue
  │       ├── [+] 'disrupt'              → pause current, act now
  │       ├── [+] 'status'               → return clone/task state
  │       ├── [+] 'attach'               → pipe brainCli.onData to client (watch)
  │       ├── [+] 'detach'               → stop pipe (watch or talk)
  │       ├── [+] 'talk'                 → brainCli.reboot({ mode: 'interact' }), begin byte relay
  │       ├── [+] 'talk-end'             → sent to client when brain CLI exits or detach
  │       ├── [+] 'input'                → brainCli.write(data) (talk mode input relay)
  │       ├── [+] 'resize'               → brainCli.resize(cols, rows) (SIGWINCH proxy)
  │       └── [+] 'kill'                 → graceful shutdown
  │
  ├── [+] clone process management
  │   ├── [+] brainCli = genBrainCli({ slug, cwd, role, series })  # create handle via rhachet
  │   │   └── [←] rhachet.genBrainCli                 # reuse: rhachet brain slug → BrainCli handle
  │   ├── [+] brainCli.enboot({ mode: 'dispatch' })  # initial boot (headless)
  │   ├── [+] brainCli.onExit → crash handler
  │   │   ├── [+] daoCloneCheckpoint.set.append       # access: save checkpoint
  │   │   └── [+] brainCli.reboot({ mode: 'dispatch' })  # respawn via same handle, series continued
  │   └── [+] brainCli.onData → transcript capture
  │       └── [+] daoCloneTranscript.set.append        # access: append to transcript.jsonl
  │
  ├── [+] task execution loop (per clone)
  │   ├── [+] dequeue next task from clone queue
  │   ├── [+] dispatchTask({ task, clone })           # dispatch via brainCli handle
  │   │   └── [+] brainCli.ask() or brainCli.act()   # mode enforcement by supplier
  │   ├── [+] on task complete → artifacts
  │   │   ├── [+] genTaskArtifacts({ task, hooks })
  │   │   │   └── [+] setTaskArtifacts({ task, hooks })
  │   │   └── [+] daoTask.set.upsert                  # access: update task status + artifacts
  │   └── [+] loop → dequeue next
  │
  └── [+] signal handlers
      ├── [+] SIGCHLD → per-clone crash isolation (process groups)
      ├── [+] SIGTERM → graceful shutdown (kill all clones, close socket)
      └── [+] SIGINT  → same as SIGTERM
```

### 2.4 observation modes

```
[+] invokeWatch
  ├── [+] getOneContextCli({ cwd })                  # (reuse from 2.2)
  ├── [+] getOneDaemonConnection({ zone })
  └── [+] setTerminalToWatchClone({ clone })
      ├── [+] IpcMessage { type: 'attach' }
      ├── [+] pipe daemon stdout → process.stdout     # stream clone output
      ├── [+] on SIGINT → setTerminalToDetach
      └── [+] IpcMessage { type: 'detach' }

[+] invokeTalk
  ├── [+] getOneContextCli({ cwd })
  ├── [+] getOneDaemonConnection({ zone })
  └── [+] setTerminalToTalkWithClone({ clone })
      ├── [+] IpcMessage { type: 'talk', cloneSlug }     # daemon reboots to interact, begins relay
      ├── [+] set process.stdin to raw mode                # no local echo, no line buffer
      ├── [+] relay: process.stdin → IPC { type: 'input' } → daemon → brainCli.write()
      ├── [+] relay: brainCli.onData → daemon → IPC { type: 'output' } → process.stdout
      ├── [+] proxy: process.stdout resize → IPC { type: 'resize' } → brainCli.resize()
      ├── [+] on IpcMessage { type: 'talk-end' } → restore terminal, return to shell
      └── [+] on SIGINT → IpcMessage { type: 'detach' }  # daemon reboots to dispatch

[+] invokeAsk/invokeAct + --await
  └── [+] setTerminalToAwaitTask({ task })
      ├── [+] IpcMessage { type: 'attach' }
      ├── [+] block until IpcMessage { type: 'task-complete', taskSlug }
      ├── [+] emit final output to stdout
      └── [+] setTerminalToDetach
```

### 2.5 status + list

```
[+] invokeStatus
  ├── [+] getOneStatusScope({ cwd })                  # smart default: feature → zone, main → site, no-git → orchestrator
  │   ├── [+] getOneGitroot → success? → getOneGitBranch
  │   └── [+] branch is main/master? → 'site' : 'zone'
  │
  ├── [+] getOneStatusZone({ zone })
  │   ├── [+] getAllClonesForZone({ zone })
  │   │   ├── [+] daoCrew.get.all
  │   │   └── [+] daoClone.get.byRef (per ref)
  │   └── [+] getAllTasksForZone({ zone })
  │       └── [+] daoTask.get.all
  │
  ├── [+] getOneStatusSite({ site })
  │   └── [+] getAllZonesForSite({ site })
  │       └── [+] daoZone per zone dir in ~/.khlone/sites/{slug}/zones/
  │
  └── [+] getOneStatusOrchestrator({ orchestrator })
      └── [+] getAllSites({ orchestrator })
          └── [+] daoSite.get.all

[+] invokeList
  ├── [+] 'sites'  → getAllSites → render
  ├── [+] 'zones'  → getAllZonesForSite → render
  ├── [+] 'crews'  → getAllClonesForZone → render
  └── [+] 'tasks'  → getAllTasksForZone → render
```

### 2.6 skill dispatch

```
[+] dispatchSkill({ skill, zone, config })
  ├── [+] enumerate role aliases from config.crew.roles
  ├── [←] rhachet.getOneRoleSkills({ roleSlug })      # reuse: check if role knows skill
  ├── [+] filter to roles that know the skill
  ├── [+] if 0 matches → BadRequestError
  ├── [+] if 2+ matches → BadRequestError (ambiguous)
  └── [+] if 1 match → genClone({ role }) + genTask({ skill }) + enqueueTask
```

### 2.7 crash recovery

```
[+] brainCli.onExit fires (unexpected exit)
  ├── [+] identify crashed clone by handle ref
  ├── [+] mark clone status → 'idle' (daoClone.set.upsert)
  ├── [+] capture checkpoint (daoCloneCheckpoint.set.append)
  │   └── [+] read brainCli.series from handle (still valid after exit)
  ├── [+] brainCli.reboot({ mode: 'dispatch' })
  │   └── [+] supplier respawns with same series ref — new pid, same handle
  ├── [+] daoClone.set.upsert (new pid from brainCli.pid, same series)
  └── [+] re-dispatch active task from checkpoint
```

**note:** crash recovery and talk-mode exit both use `brainCli.reboot({ mode: 'dispatch' })`. in talk mode, the daemon detects brain CLI exit (or CLI disconnect) and reboots to dispatch — the same `reboot` path as crash recovery. the mechanism is unified.

---

## 3. contracts

### 3.1 external dependencies

| package | version | what for |
|---------|---------|----------|
| `domain-objects` | `0.31.9` | [○] retain — DomainEntity, DomainLiteral, Ref, RefByUnique |
| `helpful-errors` | `1.5.3` | [○] retain — BadRequestError, UnexpectedCodePathError |
| `type-fns` | `1.21.0` | [○] retain — PickOne, HasMetadata, isPresent |
| `commander` | `^13.x` | [+] add — cli framework for invoke.ts |
| `yaml` | `^2.x` | [+] add — parse khlone.yml |
| `uuid-fns` | `^1.x` | [+] add — getUuid for task slugs |
| `node-pty` | `^1.x` | [+] add — pty spawn for clone processes |
| `rhachet` | `1.33.0` | [○] retain (dev) — actor enrollment, brain slug → BrainCli handle (enboot/reboot/ask/act/write/resize/onData/onExit) |

### 3.2 infra contracts

these are domain-free. they have zero awareness of khlone concepts.

#### pty

```ts
/**
 * .what = spawn a pty process
 * .why = clones need pty for brain cli processes
 */
export const spawnPty = (
  input: { command: string; args: string[]; cwd: string; env?: Record<string, string> },
): { pid: number; write: (data: string) => void; onData: (cb: (data: string) => void) => void; onExit: (cb: (code: number) => void) => void; kill: () => void } => { ... };
```

#### ipc

```ts
/**
 * .what = create unix socket server
 * .why = daemon listens for cli commands via ipc
 */
export const createIpcServer = (
  input: { socketPath: string; onMessage: (msg: IpcMessage) => Promise<IpcMessage> },
): { close: () => void } => { ... };

/**
 * .what = create unix socket client
 * .why = cli sends commands to daemon via ipc
 */
export const createIpcClient = (
  input: { socketPath: string },
): { send: (msg: IpcMessage) => Promise<IpcMessage>; close: () => void } => { ... };
```

#### IpcMessage

```ts
type IpcMessage =
  | { type: 'enqueue'; task: Task; priority: number | null }
  | { type: 'disrupt'; task: Task }
  | { type: 'status' }
  | { type: 'status-response'; clones: Clone[]; tasks: Task[] }
  | { type: 'attach'; cloneSlug: string }
  | { type: 'detach'; cloneSlug: string }
  | { type: 'talk'; cloneSlug: string }
  | { type: 'talk-ready' }
  | { type: 'talk-end'; reason: 'brain-exit' | 'detach'; code: number | null }
  | { type: 'input'; cloneSlug: string; data: string }
  | { type: 'output'; cloneSlug: string; data: string }
  | { type: 'resize'; cloneSlug: string; cols: number; rows: number }
  | { type: 'task-complete'; taskSlug: string; output: string }
  | { type: 'kill' }
  | { type: 'ack' }
  | { type: 'error'; message: string };
```

#### filesystem

```ts
export const readJsonFile = <T>(input: { path: string }): Promise<T | null> => { ... };
export const writeJsonFile = <T>(input: { path: string; data: T }): Promise<void> => { ... };
export const appendJsonlFile = <T>(input: { path: string; entry: T }): Promise<void> => { ... };
export const readJsonlFile = <T>(input: { path: string }): Promise<T[]> => { ... };
export const getOneGitroot = (input: { cwd: string }): Promise<string> => { ... };
export const getOneGitBranch = (input: { cwd: string }): Promise<string> => { ... };
```

#### process

```ts
export const spawnDetached = (input: { command: string; args: string[]; cwd: string }): { pid: number } => { ... };
export const isProcessAlive = (input: { pid: number }): boolean => { ... };
export const writePidFile = (input: { path: string; pid: number }): Promise<void> => { ... };
export const readPidFile = (input: { path: string }): Promise<number | null> => { ... };
```

### 3.3 dao contracts

each dao uses internal `castIntoDatabaseSchema` / `castFromDatabaseSchema` for disk ↔ domain translation.

see domain distillation `§3.3` for full dao contracts — 8 daos, all with `get`/`set`/`del` methods that operate on the `~/.khlone/` filesystem hierarchy.

### 3.4 domain operation contracts

see domain distillation `§2.2` for all 49 operations with full signatures.

key contracts:

```ts
// the core dispatch flow — one function per file, (input, context) pattern
export const genClone = async (
  input: { zone: Ref<typeof Zone>; address: CloneAddress; config: SiteManifest },
  context: { daoCrew: typeof daoCrew; daoClone: typeof daoClone; log: LogMethods },
): Promise<Clone> => { ... };

export const enqueueTask = async (
  input: { task: Task; clone: Ref<typeof Clone>; priority: number | null },
  context: { ipc: DaemonConnection; log: LogMethods },
): Promise<Task> => { ... };

export const dispatchTask = async (
  input: { task: Task; clone: Clone },
  context: { brainCli: BrainCli; log: LogMethods },  // brainCli handle — must be in 'dispatch' mode
): Promise<{ dispatched: true }> => { ... };
```

### 3.5 cli contract

```ts
// commander-based: one command per verb
program.command('ask <prompt>')
  .option('--who <address>', 'clone address')
  .option('--zone <address>', 'zone address')
  .option('--site <slug>', 'site slug')
  .option('--skill <name>', 'skill name')
  .option('--when <mode>', 'enqueue | disrupt')
  .option('--watch', 'stream output after dispatch')
  .option('--talk', 'interactive mode after dispatch')
  .option('--await', 'block until done')
  .action(invokeAsk);

program.command('act <prompt>')
  .option('--who <address>', 'clone address')
  .option('--zone <address>', 'zone address')
  .option('--site <slug>', 'site slug')
  .option('--skill <name>', 'skill name')
  .option('--when <mode>', 'enqueue | disrupt')
  .option('--prioritize', 'queue at front')
  .option('--watch', 'stream output after dispatch')
  .option('--talk', 'interactive mode after dispatch')
  .option('--await', 'block until done')
  .action(invokeAct);
```

---

## 4. decomposition and recomposition

### 4.1 how domain objects compose

```
Orchestrator
  .sites → Ref<Site>[]                              # registry of all sites on machine

Site
  .config → SiteManifest                             # parsed khlone.yml (crew, hooks, brains, roles)

Zone
  .site → Ref<Site>                                  # belongs to site
  .address → ZoneAddress                             # parsed address: org/repo@branch
  .daemon → ZoneDaemon | null                        # supervisor (nullable: not yet spawned)

Clone
  .zone → Ref<Zone>                                  # belongs to zone
  .status → CloneStatus                              # idle | active

Task
  .zone → Ref<Zone>                                  # belongs to zone
  .clone → Ref<Clone>                                # assigned to clone
  .mode → TaskMode                                   # ask | act
  .status → TaskStatus                               # queued | active | done | failed
  .artifacts → TaskArtifact[]                        # captured on completion
```

### 4.2 how subdomains compose for each usecase

| usecase | subdomains involved (in order) |
|---------|-------------------------------|
| instant dispatch | config → zone → clone → daemon → task → dispatch |
| task mode enforcement | dispatch (brainCli.ask vs .act) |
| queue stack | dispatch → daemon ipc |
| watch | config → daemon → observe |
| talk | config → daemon → observe |
| block output | config → daemon → observe |
| smart status | config → status → zone → clone → task |
| resource enumeration | config → orchestrator → site → zone → clone → task |
| clone address | clone (getOneCloneAddress) → config (alias lookup) → clone (gen) |
| skill dispatch | dispatch → config → clone → task |
| cross-zone dispatch | config → orchestrator → zone |
| cross-site dispatch | config → orchestrator → site → zone |
| crash recovery | daemon → clone → task |
| task artifacts | task → daemon → dispatch |

### 4.3 the three layers

```
contract/cli     thin delegation layer — parse args, call domain.operations, render output
                 zero business logic. all logic in domain.operations.

domain           business logic lives here — all get/set/gen operations
                 depends on: domain.objects (shapes), access/daos (persistence), infra (pty/ipc/fs)

access/daos      persistence layer — json/jsonl file i/o under ~/.khlone/
                 depends on: domain.objects (shapes), infra/filesystem (read/write)

infra            domain-free utilities — pty, ipc, filesystem, process
                 depends on: no other layers (leaf layer)
```

---

## 5. test coverage

### 5.1 unit tests (`.test.ts`)

pure logic, no i/o. inject fakes for any external dependency.

| subdomain | operations | what to test |
|-----------|-----------|--------------|
| clone/ | getOneCloneSlug, getOneCloneNextIndex, getOneCloneAddress | slug computation, index computation, --who grammar parse |
| config/ | getOneRoleSlugByAlias, getOneBrainSlugByAlias | alias lookup from SiteManifest, error on unknown alias |
| dispatch/ | dispatchSkill | skill route logic: 0 match, 1 match, 2+ match |
| status/ | all 6 operations | status assembly, smart scope selection |
| task/ | genTask, getOneTaskSlug, setTaskPriority | task assembly, slug format, queue reorder |
| zone/ | getOneZoneAddress | zone address parse: @branch, repo@branch, org/repo@branch |
| infra/ | isProcessAlive, IpcMessage | process liveness, message serialization |

**test pattern:**

```ts
import { given, when, then } from 'test-fns';

const TEST_CASES = [
  { description: 'hero defaults', given: { token: '' }, expect: { role: null, index: null, brain: null } },
  { description: 'role only', given: { token: 'mechanic' }, expect: { role: 'mechanic', index: null, brain: null } },
  { description: 'role.index', given: { token: 'mechanic.1' }, expect: { role: 'mechanic', index: 1, brain: null } },
  { description: 'force-enroll', given: { token: 'researcher++' }, expect: { role: 'researcher', index: '++', brain: null } },
  { description: 'brain only', given: { token: '@grok' }, expect: { role: null, index: null, brain: 'grok' } },
  { description: 'role@brain++', given: { token: 'researcher@kimi++' }, expect: { role: 'researcher', index: '++', brain: 'kimi' } },
];

describe('getOneCloneAddress', () => {
  TEST_CASES.map((thisCase) =>
    test(thisCase.description, () => {
      const result = getOneCloneAddress({ token: thisCase.given.token });
      expect(result).toEqual(new CloneAddress(thisCase.expect));
    }),
  );
});
```

### 5.2 integration tests (`.integration.test.ts`)

real filesystem, real processes, real ipc. no mocks. test across access boundaries.

| layer | what to test |
|-------|-------------|
| access/daos | read/write/append to real json/jsonl files under a temp ~/.khlone/ |
| config/ | parse real khlone.yml files, detect real gitroot |
| daemon/ | spawn real daemon process, connect via real unix socket, verify ipc round-trip |
| dispatch/ | enqueue task via real ipc, verify daemon receives |
| zone/ | genZone creates real state files, getAllClonesForZone reads from them |
| orchestrator/ | genOrchestrator creates real ~/.khlone/, setSite persists |
| site/ | genSite reads real gitroot, registers in orchestrator |
| observe/ | setTerminalToWatchClone receives real pty output stream |
| infra/pty | spawnPty spawns real process, send/receive data via pty |
| infra/ipc | createIpcServer + createIpcClient bidirectional message exchange |
| infra/filesystem | readJsonFile/writeJsonFile/appendJsonlFile/readJsonlFile on real files |
| infra/process | spawnDetached spawns real background process, pidFile round-trip |

**test pattern:**

```ts
import { given, when, then, useBeforeAll, useThen } from 'test-fns';
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs/promises';

describe('daoClone', () => {
  const tempDir = useBeforeAll(async () => {
    const dir = path.join(os.tmpdir(), `khlone-test-${Date.now()}`);
    await fs.mkdir(dir, { recursive: true });
    return dir;
  });
  afterAll(async () => fs.rm(tempDir, { recursive: true, force: true }));

  given('[case1] clone does not exist', () => {
    when('[t0] before any changes', () => {
      then('get returns null', async () => {
        const result = await daoClone.get.byRef({ clonePath: path.join(tempDir, 'mechanic.1') });
        expect(result).toBeNull();
      });
    });

    when('[t1] clone is upserted', () => {
      const cloneSaved = useThen('it succeeds', async () =>
        daoClone.set.upsert({ clone: exampleClone, clonePath: path.join(tempDir, 'mechanic.1') }),
      );

      then('saved clone has correct slug', () => {
        expect(cloneSaved.slug).toEqual('mechanic.1');
      });

      then('clone can be read back', async () => {
        const cloneRead = await daoClone.get.byRef({ clonePath: path.join(tempDir, 'mechanic.1') });
        expect(cloneRead).toEqual(cloneSaved);
      });
    });
  });
});
```

### 5.3 acceptance tests (`acceptance/*.acceptance.test.ts`)

blackbox. interact only via `khlone` cli binary. one test file per usecase from blackbox criteria.

| test file | usecase | what to verify |
|-----------|---------|---------------|
| `khlone.act.acceptance.test.ts` | usecase.1 | `khlone act "task"` returns immediately, shows task + clone + zone |
| `khlone.ask.acceptance.test.ts` | usecase.1 | `khlone ask "question"` returns immediately, task mode is ask |
| `khlone.queue.acceptance.test.ts` | usecase.3 | stack multiple tasks, verify queue order, --prioritize |
| `khlone.watch.acceptance.test.ts` | usecase.4 | `khlone watch` streams output, ctrl+c returns |
| `khlone.talk.acceptance.test.ts` | usecase.4 | `khlone talk` enters interactive, /exit returns |
| `khlone.await.acceptance.test.ts` | usecase.5 | `--await` blocks, emits output, pipe to file works |
| `khlone.status.acceptance.test.ts` | usecase.6 | smart defaults: feature → zone, main → site |
| `khlone.list.acceptance.test.ts` | usecase.7 | list sites/zones/crews/tasks renders correct tree |
| `khlone.who.acceptance.test.ts` | usecase.8 | --who grammar: role.n, @brain, role@brain++, error on mismatch |
| `khlone.skill.acceptance.test.ts` | usecase.9 | --skill routes to correct role, error on ambiguous |
| `khlone.crosszone.acceptance.test.ts` | usecase.10 | --zone dispatches to different branch |
| `khlone.crosssite.acceptance.test.ts` | usecase.11 | --site dispatches to different repo |
| `khlone.crash.acceptance.test.ts` | usecase.12 | clone crash → daemon restarts clone, task resumes |
| `khlone.artifacts.acceptance.test.ts` | usecase.13 | onStop hooks capture summary + complete + tokens |
| `khlone.log.acceptance.test.ts` | usecase.14 | `khlone log` shows transcript |

**test pattern:**

```ts
import { given, when, then, useBeforeAll, useThen } from 'test-fns';
import { execSync } from 'child_process';

describe('khlone act', () => {
  const tempRepo = useBeforeAll(async () => {
    // setup: create temp git repo with khlone.yml
    const dir = await setupTempRepo();
    return dir;
  });
  afterAll(async () => cleanupTempRepo(tempRepo));

  given('[case1] repo with khlone.yml, no prior init', () => {
    when('[t0] user runs khlone act "implement auth"', () => {
      const output = useThen('command completes', () => {
        return execSync('khlone act "implement auth"', { cwd: tempRepo, encoding: 'utf-8' });
      });

      then('output contains task slug', () => {
        expect(output).toMatch(/task-[a-z0-9]+/);
      });

      then('output shows zone context', () => {
        expect(output).toContain('@');
      });

      then('output shows hero clone', () => {
        expect(output).toContain('foreman.1');
      });
    });

    when('[t1] user runs khlone status', () => {
      const statusOutput = useThen('command completes', () => {
        return execSync('khlone status', { cwd: tempRepo, encoding: 'utf-8' });
      });

      then('shows zone-level status', () => {
        expect(statusOutput).toContain('zone');
      });

      then('shows active clone', () => {
        expect(statusOutput).toMatch(/foreman\.1/);
      });
    });
  });
});
```

### 5.4 coverage summary

| scope | test type | count | what |
|-------|-----------|-------|------|
| domain.operations (pure) | unit | ~18 | slug compute, address parse, alias lookup, status assembly, scope selection, skill route, task assembly |
| domain.operations (i/o) | integration | ~31 | clone enroll, zone init, daemon spawn/connect, dispatch via ipc, observe via pty, orchestrator persistence |
| access/daos | integration | ~8 | json/jsonl read/write/append round-trip per dao |
| infra | integration | ~12 | pty spawn/data, ipc server/client, filesystem json/jsonl, process spawn/pid/alive, gitroot/branch |
| blackbox | acceptance | ~15 | one per usecase from blackbox criteria, via cli binary |
| **total** | | **~84** | |

---

## 6. execution phases

### phase 0: foundation

establish the leaf layers that all else depends on.

1. domain.objects — all 16 files (entities + literals)
2. infra/filesystem — json/jsonl read/write, gitroot, gitBranch
3. infra/process — spawnDetached, isProcessAlive, pidFile
4. access/daos — all 8 daos (they depend on infra/filesystem + domain.objects)
5. __test_assets__ — example entities for test fixtures

### phase 1: config + orchestrator + site + zone

the "where am i?" layer — before any clone or task can exist.

1. config/ — getOneSiteManifest, genSiteManifest, getOneContextCli, alias lookups
2. orchestrator/ — genOrchestrator, setSite, getOneSiteBySlug, getAllSites
3. site/ — getOneSite, genSite, getAllZonesForSite
4. zone/ — setZone, genZone, getOneZoneAddress, getOneZoneByAddress, getAllClonesForZone, getAllTasksForZone

### phase 2: clone + task

the "who does it and what do they do?" layer.

1. clone/ — setClone, getOneClone, genClone, getOneCloneSlug, getOneCloneNextIndex, getOneCloneAddress
2. task/ — genTask, getOneTaskSlug, setTaskPriority, genTaskArtifacts, setTaskArtifacts

### phase 3: daemon + dispatch

the "make it happen" layer — this is the hardest phase.

1. infra/pty — spawnPty, attachPty, detachPty
2. infra/ipc — createIpcServer, createIpcClient, IpcMessage
3. daemon/ — setZoneDaemon, getOneZoneDaemon, genZoneDaemon, getOneDaemonConnection
4. daemon/ — genCloneViaDaemon, setCloneViaDaemon (crash recovery)
5. dispatch/ — dispatchTask, enqueueTask, disruptClone, dispatchSkill

### phase 4: observe + status

the "see what's up" layer.

1. observe/ — setTerminalToWatchClone, setTerminalToTalkWithClone, setTerminalToDetach, setTerminalToAwaitTask
2. status/ — all 6 status operations

### phase 5: cli + acceptance

the "ship it" layer.

1. bin/run, bin/run.jit
2. contract/cli — invoke.ts + all invoke*.ts handlers
3. contract/sdk.ts
4. acceptance tests — all 15 blackbox tests

---

## 7. hazards and mitigations

| hazard | probability | impact | mitigation |
|--------|------------|--------|-----------|
| node-pty platform issues (linux/mac/windows) | medium | high | test on both linux and mac in ci; document platform support |
| unix socket cleanup on crash | medium | medium | daemon writes socket to known path; cli checks staleness via pid liveness |
| brain cli headless api changes | low | high | rhachet BrainCli contract absorbs changes; khlone never calls cli directly |
| pty output parse complexity | medium | medium | daemon streams raw output; transcript captures as-is; no parse required for v0 |
| concurrent json file writes | low | medium | atomic writes (tmp + rename) in writeJsonFile; jsonl is append-only |
| daemon memory over time | low | medium | daemon is thin supervisor; brain clis are the heavy processes |

---

## summary

khlone v0 is a greenfield implementation of **182 files** across 5 layers:

- **infra** (leaf) — pty, ipc, filesystem, process utilities
- **access/daos** (leaf) — 8 json/jsonl file-based daos under `~/.khlone/`
- **domain.objects** — 6 entities + 10 literals
- **domain.operations** — 49 operations across 10 subdomains
- **contract/cli** — 9 commander-based cli handlers

the execution flows bottom-up across 6 phases, with each phase testable in isolation before the next begins. the daemon (phase 3) is the most complex subsystem — it holds BrainCli handles per clone, dispatches tasks via `.ask()`/`.act()`, and uses `.reboot()` for crash recovery and talk mode. talk mode uses a byte relay model: the daemon reboots the brain CLI to interact mode via `brainCli.reboot({ mode: 'interact' })` and relays raw PTY bytes between the IPC client (khlone CLI) and the brain CLI. any brain CLI exit or CLI disconnect triggers `brainCli.reboot({ mode: 'dispatch' })`.

all brain interaction flows through rhachet's BrainCli contract (`enboot`/`reboot`/`ask`/`act`/`write`/`resize`/`onData`/`onExit`). khlone never spawns CLI processes directly — the daemon owns all brain CLI processes in both dispatch and interact modes, and the khlone CLI is always a thin relay. all persistence lives under `~/.khlone/` as json/jsonl files — no database required for v0.
