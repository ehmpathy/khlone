# khlone v0: zoomin — OAuth token refresh mechanics

> how claude code tokens expire, why copied credentials fail to refresh, and how khlone could relay fresh tokens to cloud zones

> **builds on:** z3 (`3.3.blueprint.z3.braincli-auth.v1.i1.md`) — established the v0 auth strategy (zero auth work, reuse extant credentials). this doc zooms into the refresh mechanics for the cloud dispatch future.

---

## the question

z3 noted that refresh tokens "don't work on copied credentials" [^1]. but *why*? is there device-level lock? could khlone run the refresh locally (where it works) and push the fresh token to a cloud zone on demand?

---

## findings

### token lifetimes

two token types with very different TTLs:

| token source | method | TTL | prefix |
|-------------|--------|-----|--------|
| `claude login` | browser OAuth + PKCE | ~8 hours | `sk-ant-oat01-` |
| `claude setup-token` | generates a long-lived OAuth token | ~1 year | `sk-ant-oat01-` |

the `expiresAt` field in `.credentials.json` is a Unix timestamp in milliseconds. when claude code sees an expired `accessToken`, it *should* attempt a refresh via the `refreshToken`. the default fallback TTL (when the server omits `expires_in`) is 3600 seconds (1 hour) [^2].

### the refresh flow

standard OAuth 2.0 `refresh_token` grant:

```
POST https://console.anthropic.com/api/oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
&refresh_token=sk-ant-ort01-...
&client_id=9d1c250a-e61b-44d9-88ed-5944d1962f5e
```

the server returns:
- a **new access token** (replaces the old one)
- a **new refresh token** (the old one is invalidated — single-use rotation)

both are written back to `~/.claude/.credentials.json` (linux) or the macOS Keychain.

**the token endpoint works.** the anthropic maintainer confirmed: "I've verified our refresh token flow is functional" [^1]. the server-side refresh is a standard, operational OAuth endpoint.

### why copied credentials fail to refresh

**it is NOT device-level lock.** no evidence of machine fingerprints, device IDs, or IP-based token validation. the refresh token is a standard bearer token — any HTTP client can use it.

the actual cause is **client-side**: claude code's client does not reliably invoke the refresh flow in all code paths [^1]. on the original machine, this is masked because the human can re-authenticate via browser when prompted. on a headless/remote machine, there is no browser fallback — the 401 is fatal.

**secondary cause — single-use rotation race:** refresh tokens are single-use. once consumed, the old token is dead server-side. if two processes (local + remote, or two clones) try to refresh with the same token, only the first succeeds. the second gets a 401 with no recovery path [^3].

| suspected cause | actual? | evidence |
|----------------|---------|----------|
| device fingerprint / machine ID | **no** | zero references in source or issues |
| PKCE code_verifier needed for refresh | **no** | PKCE is only for initial auth code exchange per OAuth 2.0 spec |
| IP-based validation | **no** | no evidence; standard bearer token |
| client-side refresh not invoked | **yes** | maintainer confirmed in #21765 [^1] |
| single-use rotation race condition | **yes** | documented in #24317 [^3] |
| macOS Keychain ACL after auto-update | **yes (macOS only)** | new binary loses Keychain access [^4] |

### could khlone refresh locally and push to cloud?

**yes — the refresh endpoint is a plain HTTP call.** any process that holds a valid refresh token can call it. khlone could:

1. call the refresh endpoint on the local machine (where the original credentials live)
2. receive a new `accessToken` + `refreshToken`
3. update local `.credentials.json` with the new pair
4. push the new `accessToken` to the remote machine

**but there's a simpler path: `setup-token`.**

`claude setup-token` produces a token valid for ~1 year. inject it on the remote via `CLAUDE_CODE_OAUTH_TOKEN` env var:

```sh
# on the local machine
claude setup-token
# → outputs a long-lived token

# on the remote machine
export CLAUDE_CODE_OAUTH_TOKEN="sk-ant-oat01-..."
```

no refresh needed for ~1 year. when it expires, generate a new one and re-inject.

---

## three paths for cloud auth

### path 1: `ANTHROPIC_API_KEY` via vault

the cleanest path for production cloud dispatch:

```
remote daemon env:
  ANTHROPIC_API_KEY=sk-ant-... (from vault/SSM/secrets manager)
```

- API keys don't expire unless revoked
- no refresh needed
- pay-as-you-go API rates (not subscription)
- zero credential file management

### path 2: `setup-token` + `CLAUDE_CODE_OAUTH_TOKEN`

uses the subscription (Max/Teams/Enterprise) without API key charges:

```
local machine:
  claude setup-token → sk-ant-oat01-...

remote daemon env:
  CLAUDE_CODE_OAUTH_TOKEN=sk-ant-oat01-...
```

- ~1 year TTL — low-frequency rotation
- uses subscription quota, not pay-as-you-go
- requires a setup-completion flag (`true`) in `~/.claude.json` on the remote [^5]
- no refresh flow needed within the TTL window

### path 3: programmatic local refresh + push

the most complex path — for when subscription auth is required AND setup-token is not viable:

```
khlone orchestrator (local):
  1. detect: remote zone's token will expire within threshold
  2. call: POST console.anthropic.com/api/oauth/token (refresh_token grant)
  3. receive: new accessToken + new refreshToken
  4. update: local ~/.claude/.credentials.json (new refresh token — old one is dead)
  5. push: new accessToken to remote zone via secure channel

remote daemon:
  6. receive: fresh accessToken
  7. set: CLAUDE_CODE_OAUTH_TOKEN=<fresh token> on next executor.boot()
```

**hazards:**
- refresh token is single-use — the local `claude` process must not race with khlone's refresh call
- requires khlone to know the client ID and token endpoint (a dependency on anthropic's OAuth implementation)
- adds auth management complexity to khlone's orchestrator

**verdict:** path 3 is the escape hatch, not the default. path 1 (API key) or path 2 (setup-token) cover the vast majority of cloud dispatch needs without any refresh logic in khlone.

---

## what this means for khlone

### v0 (local only): no change

z3's strategy holds — zero auth work, reuse extant credentials from the same machine.

### v1+ (cloud dispatch): pick path 1 or 2

| path | when to use | complexity |
|------|------------|------------|
| `ANTHROPIC_API_KEY` | CI/CD, pay-as-you-go, enterprise vault | zero — env var injection |
| `setup-token` | subscription users, low-frequency rotation | low — generate token, inject env var |
| programmatic refresh | subscription users who need automated rotation | high — HTTP client, race guards, token relay |

**recommendation:** support path 1 and path 2 at v1 launch. defer path 3 until a real user needs it — the complexity is not justified until the simpler paths prove insufficient.

### the BrainCli contract remains auth-free

none of this changes the BrainCli interface. auth is the supplier's concern:

- v0: supplier checks that `~/.claude/.credentials.json` or `ANTHROPIC_API_KEY` exists before `executor.boot()`
- v1+: supplier reads `CLAUDE_CODE_OAUTH_TOKEN` or `ANTHROPIC_API_KEY` from the daemon's env

khlone's orchestrator may inject env vars into the daemon's environment (path 1 or 2), but the BrainCli handle never sees tokens.

---

## citations

1. [^1]: [GitHub issue #21765](https://github.com/anthropics/claude-code/issues/21765) — maintainer confirms refresh endpoint works, but client does not reliably invoke it; copied credentials fail on remote machines
2. [^2]: [GitHub issue #9017](https://github.com/anthropics/claude-code/issues/9017) — default 3600s fallback when server omits `expires_in`
3. [^3]: [GitHub issue #24317](https://github.com/anthropics/claude-code/issues/24317) — refresh token race condition with concurrent sessions; single-use rotation means only one consumer wins
4. [^4]: [GitHub issue #19456](https://github.com/anthropics/claude-code/issues/19456) — macOS Keychain permission errors after auto-update; new binary signature loses access to stored tokens
5. [^5]: [GitHub issue #8938](https://github.com/anthropics/claude-code/issues/8938) — `CLAUDE_CODE_OAUTH_TOKEN` requires setup-completion flag in `~/.claude.json` to skip setup prompt
6. [^6]: [GitHub issue #12447](https://github.com/anthropics/claude-code/issues/12447) — setup-token produces ~1 year TTL; OAuth token expiry disrupts autonomous workflows
7. [Claude Code authentication docs](https://code.claude.com/docs/en/authentication) — official auth flow: OAuth, API key, Bedrock, Vertex
8. [Claude Code headless mode docs](https://code.claude.com/docs/en/headless) — `-p` mode auth behavior: inherits credentials from `~/.claude/` or env vars

---

## summary

| question | answer |
|----------|--------|
| how long do access tokens last? | ~8 hours (`claude login`) or ~1 year (`claude setup-token`) |
| why don't copied credentials refresh? | client-side: claude code doesn't reliably invoke the refresh flow; NOT device-bound |
| is the refresh endpoint functional? | yes — standard OAuth 2.0 `refresh_token` grant at `console.anthropic.com/api/oauth/token` |
| could khlone refresh locally and push? | yes — it's a plain HTTP call; but `setup-token` is simpler for most cases |
| what's the best cloud auth path? | `ANTHROPIC_API_KEY` (vault) or `setup-token` + `CLAUDE_CODE_OAUTH_TOKEN` (subscription) |
| does this change the BrainCli contract? | no — auth remains the supplier's internal concern |
