# block 0: BrainCli — access research

> remote access required to fulfill the BrainCli contract + claude supplier

---

## lesson.1 = claude code CLI dispatch mode (`-p` with structured i/o)

the claude supplier spawns `claude -p` with nd-JSON structured i/o for headless dispatch. this is the core access pattern for ask/act.

### spawn args

```sh
claude -p \
  --output-format stream-json \
  --input-format stream-json \
  --verbose \
  --allowedTools "Read,Grep,Glob"
```

**key flags:**
- `-p` / `--print` — headless mode: process prompt, emit output, no TUI [1]
- `--output-format stream-json` — nd-JSON event stream on stdout [1][2]
- `--input-format stream-json` — nd-JSON message protocol on stdin [1][2]
- `--verbose` — emit full event detail in stream mode [2]
- `--allowedTools` — auto-approve listed tools without prompt [1][3]
- `--resume <session-id>` — continue a prior session [1][4]
- `--continue` / `-c` — continue most recent conversation [1]

**citation [1]:** claude code CLI reference (https://code.claude.com/docs/en/cli-reference):
> "claude -p, --print: print response without interactive mode"
> "--output-format: output format for non-interactive mode (text, json, stream-json)"
> "--input-format: input format (text, stream-json)"

**citation [2]:** claude code headless docs (https://code.claude.com/docs/en/headless):
> "run claude code programmatically with -p and --output-format stream-json"
> "use --input-format stream-json to send nd-JSON messages on stdin for multi-turn"

---

## lesson.2 = nd-JSON output event stream

`--output-format stream-json` emits newline-delimited JSON events on stdout. the claude supplier must parse these to produce `BrainOutput`.

### event types

| event type | what it carries | relevance to BrainCli |
|---|---|---|
| `message_start` | message metadata, initial `usage.input_tokens` | capture input token count |
| `content_block_start` | new content block (text or tool_use) | detect response start |
| `content_block_delta` | incremental text or tool input | stream to terminal.onData |
| `content_block_stop` | end of content block | — |
| `message_delta` | `stop_reason`, cumulative `usage` (output_tokens, cache tokens) | capture final metrics |
| `message_stop` | stream complete | signal dispatch complete |
| `keepalive` | heartbeat | ignore |
| `error` | error detail | surface to caller |

### metrics extraction from events

the `message_start` event carries initial input tokens:
```json
{
  "type": "message_start",
  "message": {
    "usage": { "input_tokens": 1500, "output_tokens": 0 }
  }
}
```

the `message_delta` event carries cumulative output tokens and cache data:
```json
{
  "type": "message_delta",
  "usage": {
    "input_tokens": 1500,
    "cache_creation_input_tokens": 100,
    "cache_read_input_tokens": 500,
    "output_tokens": 150
  }
}
```

**note:** token counts in `message_delta` are cumulative per-turn, not incremental [5].

**citation [3]:** claude code allowed tools docs (https://www.instructa.ai/blog/claude-code/how-to-use-allowed-tools-in-claude-code):
> "--allowedTools auto-approves specific tools without permission prompts"
> "supports pattern match with prefix wildcards: Bash(git diff *)"

---

## lesson.3 = nd-JSON input protocol (`--input-format stream-json`)

stdin accepts nd-JSON messages for multi-turn dispatch on a live process.

### message shape

```json
{
  "type": "user",
  "message": {
    "role": "user",
    "content": "what files changed?"
  },
  "session_id": "abc-123"
}
```

each line on stdin is a complete JSON object. the process reads it, executes, and emits the response event stream on stdout [2].

**key property:** multi-turn over a single process — send a message, get the response stream, send another message. no respawn needed between ask/act calls on the same handle [2].

**citation [4]:** claude code session management (https://stevekinney.com/courses/ai-development/claude-code-session-management):
> "session_id from JSON output can be captured and passed back via --resume"
> "conversations stored in ~/.claude/projects/<project-name>/<session-id>.jsonl"

---

## lesson.4 = session continuation via `--resume`

claude code stores sessions on disk. the `--resume <session-id>` flag loads prior context into a new process.

### how it works

1. dispatch a task via `-p --output-format json` — the response includes `session_id`
2. the session transcript persists at `~/.claude/projects/<project>/<session-id>.jsonl`
3. on respawn (crash recovery or mode switch), pass `--resume <session-id>` to load prior context

```sh
# capture session_id from first dispatch
session_id=$(claude -p "initial task" --output-format json | jq -r '.session_id')

# resume that session in a new process
claude -p --resume "$session_id" "follow-up task"
```

**this is the series ref for the BrainCli contract.** the handle stores the session_id and passes it on reboot.

**citation [5]:** anthropic stream protocol docs (https://platform.claude.com/docs/en/build-with-claude/streaming):
> "message_delta usage fields are cumulative, not incremental"
> "token counts include cache_creation_input_tokens and cache_read_input_tokens"

---

## lesson.5 = ask vs act enforcement via `--allowedTools`

task mode is enforced at the CLI arg level via `--allowedTools` and `--disallowedTools`.

### ask mode (read-only)

```sh
claude -p --allowedTools "Read,Grep,Glob,WebSearch,WebFetch" \
  --output-format stream-json \
  --input-format stream-json
```

these tools are already auto-allowed by default (no prompt needed): `Read`, `Grep`, `Glob`, `WebSearch`, `WebFetch` [3].

### act mode (full tool use)

```sh
claude -p --allowedTools "Read,Grep,Glob,Edit,Write,Bash,WebSearch,WebFetch" \
  --output-format stream-json \
  --input-format stream-json
```

**note:** never use `--dangerously-skip-permissions`. use explicit `--allowedTools` to whitelist permitted tools [1][3].

### pattern match syntax

`--allowedTools` supports prefix wildcards:
```sh
--allowedTools "Bash(git diff *)" "Bash(git log *)" "Read"
```

the space before `*` matters — `Bash(git diff *)` matches `git diff HEAD` but not `git diff-index` [3].

---

## lesson.6 = auth: zero work for v0

auth is not part of the BrainCli contract. the claude supplier spawns the CLI process; the CLI process authenticates itself via its own credential chain.

### auth chain (in priority order)

1. `ANTHROPIC_API_KEY` env var — overrides all else [6]
2. `~/.claude/.credentials.json` — OAuth tokens from `claude login` [6]
3. `~/.claude/config.json` — console API key via `primaryApiKey` [6]
4. `apiKeyHelper` in `~/.claude/settings.json` — external credential command [6]

### v0 strategy

the daemon runs as the same user on the same machine where the human authenticated. the subprocess inherits `$HOME` and reads the same credentials file. no env var relay, no credential management, no token refresh by khlone.

**precondition check only:** before first boot, verify credentials exist or `ANTHROPIC_API_KEY` is set. fail fast with clear error if neither found.

**citation [6]:** prior research: auth strategy (`.behavior/v2026_02_15.khlone-v0/3.3.blueprint.z3.braincli-auth.v1.i1.md`):
> "on linux, claude -p reads ~/.claude/.credentials.json from the filesystem"
> "any process that runs as the same user and inherits the same $HOME will use the same tokens"

---

## lesson.7 = process spawn via node child_process

the claude supplier spawns the CLI via `child_process.spawn()` with pipe stdio for structured i/o.

### dispatch mode spawn

```ts
import { spawn } from 'child_process';

const child = spawn('claude', [
  '-p',
  '--output-format', 'stream-json',
  '--input-format', 'stream-json',
  '--verbose',
  '--allowedTools', 'Read,Grep,Glob',  // ask mode
], {
  cwd: '/path/to/worktree',
  env: { ...process.env },
  stdio: ['pipe', 'pipe', 'pipe'],
});
```

### interact mode spawn

```ts
const child = spawn('claude', [
  '--resume', sessionId,
], {
  cwd: '/path/to/worktree',
  env: { ...process.env },
  stdio: 'inherit',  // raw PTY pass-through
});
```

**key difference:** dispatch mode uses `stdio: ['pipe', 'pipe', 'pipe']` for structured i/o. interact mode uses `stdio: 'inherit'` (or PTY via node-pty) for raw terminal relay.

**citation [7]:** node.js child_process docs (https://nodejs.org/api/child_process.html):
> "child_process.spawn() launches a new process with a given command"
> "by default, pipes for stdin, stdout, and stderr are established"

---

## lesson.8 = PTY via node-pty for interact mode

interact mode needs PTY for full terminal emulation (escape codes, window resize, raw input). `node-pty` provides this.

```ts
import { spawn as ptySpawn } from 'node-pty';

const pty = ptySpawn('claude', ['--resume', sessionId], {
  name: 'xterm-256color',
  cols: 120,
  rows: 40,
  cwd: '/path/to/worktree',
  env: process.env,
});

// terminal.onData
pty.onData((data) => { /* raw PTY bytes */ });

// terminal.onExit
pty.onExit(({ exitCode, signal }) => { /* process terminated */ });

// terminal.write
pty.write('user input\n');

// terminal.resize
pty.resize(cols, rows);
```

**why PTY for interact mode (not plain pipes):**

| feature | stdin/stdout pipes | PTY |
|---|---|---|
| terminal emulation | no | yes |
| ANSI escape codes | breaks | works |
| interactive prompts | breaks | works |
| window resize (SIGWINCH) | no | yes |

**citation [8]:** node-pty npm package (https://www.npmjs.com/package/node-pty):
> "node-pty forks processes with pseudoterminal file descriptors"

---

## lesson.9 = cost data is derived, not directly emitted

claude code does not emit per-call cost in USD as a structured field. the supplier must derive cost from token counts and model-specific rates.

### what the stream provides

- `input_tokens` — from `message_start` and `message_delta`
- `output_tokens` — from `message_delta`
- `cache_creation_input_tokens` — from `message_delta`
- `cache_read_input_tokens` — from `message_delta`

### what the supplier must compute

```
cost.input  = input_tokens * rate.input
cost.output = output_tokens * rate.output
cost.cache  = cache_creation * rate.cache_write + cache_read * rate.cache_read
cost.total  = cost.input + cost.output + cost.cache
```

**alternative:** claude code exposes `claude_code.cost.usage` via OpenTelemetry for session-level cost [9]. but for per-call metrics, the supplier computes from tokens.

**citation [9]:** claude code observability docs (https://code.claude.com/docs/en/monitoring-usage):
> "claude_code.cost.usage metric via OpenTelemetry tracks session cost in USD"
> "ccusage, goccc, and claudelytics parse session JSONL files for usage analysis"

---

## lesson.10 = known edge cases in stream-json mode

### hang after completion

claude code CLI may hang after the final `message_stop` event in stream-json mode instead of clean exit [10]. the supplier must detect `message_stop` and treat it as dispatch complete — not wait for process exit.

### partial JSON in tool_use deltas

`content_block_delta` events with `type: "input_json_delta"` emit partial JSON. the supplier must accumulate `partial_json` chunks until `content_block_stop` before parse [5].

### duplicate session entries

multi-turn conversations with `--input-format stream-json` may cause duplicate session history entries [10]. not a blocker for v0 — the session_id ref remains valid.

**citation [10]:** claude code community issues:
> "claude code CLI may hang indefinitely after final result event in stream-json mode" (github issue #25629)
> "multi-turn with --input-format stream-json may cause duplicate session history entries" (github issue #5034)

---

## access summary

### remote repositories accessed by block 0

| repository | type | interface | purpose |
|---|---|---|---|
| claude code CLI | process | `child_process.spawn()` + pipe stdio | dispatch mode (ask/act) |
| claude code CLI | process | `node-pty` spawn + PTY | interact mode (talk) |
| `~/.claude/.credentials.json` | filesystem | node `fs` | auth precondition check |
| `~/.claude/projects/` | filesystem | (claude-internal) | session persistence (managed by CLI, not by supplier) |

### best practices

1. **`--output-format stream-json` + `--input-format stream-json`** for structured multi-turn dispatch on a single process [1][2]
2. **`--allowedTools`** for mode enforcement — never `--dangerously-skip-permissions` [3]
3. **`--resume <session-id>`** for series continuation across boots [4]
4. **detect `message_stop`** to signal dispatch complete — do not rely on process exit (may hang) [10]
5. **accumulate `partial_json`** in tool_use deltas until `content_block_stop` [5]
6. **derive cost from tokens** — no direct USD field in stream events [9]
7. **PTY for interact mode, pipes for dispatch mode** — different spawn strategies per mode [7][8]
8. **zero auth work** — the CLI authenticates itself; supplier only checks precondition [6]

---

## citations

| # | source | type |
|---|--------|------|
| [1] | claude code CLI reference (https://code.claude.com/docs/en/cli-reference) | primary |
| [2] | claude code headless docs (https://code.claude.com/docs/en/headless) | primary |
| [3] | claude code allowed tools guide (https://www.instructa.ai/blog/claude-code/how-to-use-allowed-tools-in-claude-code) | primary |
| [4] | claude code session management (https://stevekinney.com/courses/ai-development/claude-code-session-management) | primary |
| [5] | anthropic stream protocol docs (https://platform.claude.com/docs/en/build-with-claude/streaming) | primary |
| [6] | prior research: auth strategy (`.behavior/v2026_02_15.khlone-v0/3.3.blueprint.z3.braincli-auth.v1.i1.md`) | prior |
| [7] | node.js child_process docs (https://nodejs.org/api/child_process.html) | primary |
| [8] | node-pty npm package (https://www.npmjs.com/package/node-pty) | primary |
| [9] | claude code observability docs (https://code.claude.com/docs/en/monitoring-usage) | primary |
| [10] | claude code community issues (#25629, #5034) | primary |
