# block 0: BrainCli contract + claude supplier — blackbox criteria

> what experience must be delivered, from the caller's perspective

---

## usecase.1 = spawn a brain handle from a slug

```
given a valid claude brain slug and a cwd
  when genBrainCli is called with { slug } and { cwd }
    then it returns a BrainCli handle
      sothat the caller has a stable ref to drive a brain CLI process
    then the handle has not yet spawned a process (pid is null, mode is null)
      sothat boot is explicit — no hidden side effects on construction

given an unrecognized brain slug
  when genBrainCli is called
    then it throws a BadRequestError with the invalid slug in the message
      sothat the caller fails fast with a clear explanation
```

---

## usecase.2 = boot a handle into dispatch mode

```
given a BrainCli handle that has not been booted
  when executor.boot({ mode: 'dispatch' }) is called
    then the handle spawns a headless CLI process
    then pid is updated to a live process id
    then mode is 'dispatch'
      sothat the handle is ready to accept ask/act calls

given a BrainCli handle already in dispatch mode
  when executor.boot({ mode: 'dispatch' }) is called again
    then the prior process is killed
    then a new process is spawned in dispatch mode
    then series is preserved across the reboot
      sothat double-boot is safe and idempotent
```

---

## usecase.3 = dispatch a read-only task via ask

```
given a BrainCli handle booted in dispatch mode
  when ask({ prompt: 'what files are in this repo?' }) is called
    then it returns a BrainOutput with a text output
    then BrainOutput.metrics.size.tokens.input is > 0
    then BrainOutput.metrics.size.tokens.output is > 0
    then BrainOutput.episode is a non-empty text ref
    then BrainOutput.series is a non-empty text ref
      sothat the caller receives structured results with metrics from a live brain

given a BrainCli handle booted in dispatch mode
  when ask({ prompt }) is called
    then the brain CLI process is restricted to read-only tools
    then no files are mutated by the brain
      sothat ask mode enforces zero side effects

given a BrainCli handle that has not been booted
  when ask({ prompt }) is called
    then it throws an error
      sothat the caller cannot dispatch without a live process

given a BrainCli handle booted in interact mode
  when ask({ prompt }) is called
    then it throws an error
      sothat ask is only valid in dispatch mode
```

---

## usecase.4 = dispatch a full-tool task via act

```
given a BrainCli handle booted in dispatch mode
  when act({ prompt: 'create a file called hello.txt with "hello"' }) is called
    then it returns a BrainOutput with a text output
    then BrainOutput.metrics.size.tokens.input is > 0
    then BrainOutput.metrics.size.tokens.output is > 0
    then BrainOutput.episode is a non-empty text ref
    then BrainOutput.series is a non-empty text ref
      sothat the caller receives structured results from a live brain with full tool access

given a BrainCli handle booted in dispatch mode
  when act({ prompt }) is called
    then the brain CLI process has access to mutation tools (file edit, bash, etc)
      sothat act mode permits full tool use

given a BrainCli handle that has not been booted
  when act({ prompt }) is called
    then it throws an error
      sothat the caller cannot dispatch without a live process

given a BrainCli handle booted in interact mode
  when act({ prompt }) is called
    then it throws an error
      sothat act is only valid in dispatch mode
```

---

## usecase.5 = stream raw output from the process

```
given a BrainCli handle booted in dispatch mode
  when a task is dispatched via ask or act
    then terminal.onData fires with output chunks as the brain produces them
    then the chunks contain the brain's response data
      sothat the caller can stream output in real time (for watch mode, transcript capture)

given a BrainCli handle booted in interact mode
  when the brain CLI emits terminal output
    then terminal.onData fires with raw PTY bytes
      sothat the caller can relay the byte stream to a user terminal
```

---

## usecase.6 = detect process exit

```
given a BrainCli handle with a live process
  when the process exits cleanly (exit code 0)
    then terminal.onExit fires with the exit code
      sothat the caller knows the process terminated

given a BrainCli handle with a live process
  when the process crashes (non-zero exit code or signal)
    then terminal.onExit fires with the exit code and/or signal
      sothat the caller can trigger crash recovery

given a BrainCli handle with a live process
  when the process is killed externally
    then terminal.onExit fires exactly once
      sothat the caller is notified without duplicate signals
```

---

## usecase.7 = kill the process

```
given a BrainCli handle with a live process
  when kill() is called
    then the process is terminated
    then terminal.onExit fires
      sothat the caller can cleanly shut down a clone

given a BrainCli handle with no live process (not booted, or already exited)
  when kill() is called
    then it is a no-op (no error thrown)
      sothat kill is safe to call regardless of state
```

---

## usecase.8 = crash recovery via reboot with series preservation

```
given a BrainCli handle that has completed at least one ask or act call (series is non-null)
  when the process crashes (terminal.onExit fires unexpectedly)
  and the caller calls executor.boot({ mode: 'dispatch' })
    then a new process is spawned that resumes the prior session
    then handle.series is the same ref as before the crash
    then the new process has access to prior conversation context
      sothat crash recovery preserves session continuity

given a BrainCli handle with series from a prior boot
  when executor.boot({ mode: 'dispatch' }) is called after a crash
    then the caller can immediately dispatch a new task via ask or act
      sothat crash recovery is transparent to the caller's workflow
```

---

## usecase.9 = switch between dispatch and interact mode

```
given a BrainCli handle booted in dispatch mode with a non-null series
  when executor.boot({ mode: 'interact' }) is called
    then the dispatch process is killed
    then a new process is spawned in interact mode (raw PTY)
    then mode is updated to 'interact'
    then series is preserved
      sothat the caller can switch a clone to interactive terminal mode

given a BrainCli handle booted in interact mode
  when executor.boot({ mode: 'dispatch' }) is called
    then the interact process is killed
    then a new process is spawned in dispatch mode (structured i/o)
    then mode is updated to 'dispatch'
    then series is preserved
      sothat the caller can switch back to headless dispatch after a talk session
```

---

## usecase.10 = write raw input to the process

```
given a BrainCli handle booted in interact mode
  when terminal.write(data) is called with text
    then the text is written to the process stdin
      sothat the caller can relay user keystrokes to the brain (talk mode)

given a BrainCli handle booted in dispatch mode
  when terminal.write(data) is called
    then the data is written to the structured stdin
      sothat the caller can send raw protocol data if needed
```

---

## usecase.11 = structured metrics per dispatch call

```
given a BrainCli handle booted in dispatch mode
  when ask or act returns a BrainOutput
    then metrics.size.tokens has input and output counts (both > 0)
    then metrics.cost.time is a duration value
    then metrics.cost.cash is either a cost object or null (if supplier cannot provide cost)
      sothat the caller has per-call token and cost data without vendor output parse

given two sequential ask calls on the same handle
  when both return BrainOutput
    then each BrainOutput has independent metrics (per-call, not cumulative)
      sothat the caller can attribute cost to individual tasks
```
