# block 0: BrainCli — domain research

> extant domain objects, operations, and relationships relevant to the BrainCli contract + claude supplier

---

## domain objects

### 1. extant from rhachet (published package, not re-declared)

#### 1.1 BrainOutput

**classification:** domain literal (immutable, identity by all properties)

**source:** `rhachet` package → `domain.objects/BrainOutput`

**shape:**
```ts
interface BrainOutput<TOutput = string, TBrainGrain extends BrainGrain = BrainGrain> {
  output: TOutput;
  metrics: BrainOutputMetrics;
  episode: BrainEpisode;
  series: AsBrainOutputSeriesFor<TBrainGrain>;
}
```

**conditional type:** `AsBrainOutputSeriesFor<T>` returns `null` for `'atom'`, `BrainSeries` for `'repl'`. BrainCli operates at the `'repl'` grain — series is always `BrainSeries`, never null at the type level.

**relevance to block 0:** the return type of `ask()` and `act()`. the claude supplier constructs this from nd-JSON stream events.

---

#### 1.2 BrainOutputMetrics

**classification:** domain literal

**source:** `rhachet` package → `domain.objects/BrainOutputMetrics`

**shape:**
```ts
interface BrainOutputMetrics {
  size: {
    tokens: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
    chars: {
      input: number;
      output: number;
      cache: { get: number; set: number };
    };
  };
  cost: {
    time: IsoDuration;
    cash: {
      total: IsoPrice;
      deets: { input: IsoPrice; output: IsoPrice; cache: IsoPrice };
    } | null;
  };
}
```

**relevance to block 0:** populated by the claude supplier from `message_start` and `message_delta` stream events. token counts come from the event stream; cost is derived from tokens × model rates. `cost.cash` may be null if the supplier cannot compute cost.

---

#### 1.3 BrainEpisode

**classification:** domain literal

**source:** `rhachet` package → `domain.objects/BrainEpisode`

**shape:**
```ts
interface BrainEpisode {
  hash: string;
  exid: string | null;
  exchanges: BrainExchange[];
}
```

**relevance to block 0:** each `ask()` or `act()` call returns a BrainEpisode that captures the current context window. the claude supplier can derive this from the stream events or construct a minimal episode ref.

---

#### 1.4 BrainSeries

**classification:** domain literal

**source:** `rhachet` package → `domain.objects/BrainSeries`

**shape:**
```ts
interface BrainSeries {
  hash: string;
  exid: string | null;
  episodes: BrainEpisode[];
}
```

**relevance to block 0:** the cross-boot continuation ref. maps to claude's `session_id`. the handle stores the current series and passes it via `--resume` on reboot. khlone persists the series ref for crash recovery.

---

#### 1.5 BrainExchange

**classification:** domain literal

**source:** `rhachet` package → `domain.objects/BrainExchange`

**shape:**
```ts
interface BrainExchange {
  hash: string;
  input: string;
  output: string;
  exid: string | null;
}
```

**relevance to block 0:** atomic request-response pair. each `ask()` / `act()` dispatch produces one exchange within the episode. the claude supplier captures the prompt as input and the collected output text as output.

---

#### 1.6 BrainGrain

**classification:** type literal (union)

**source:** `rhachet` package → `domain.objects/BrainGrain`

**shape:**
```ts
type BrainGrain = 'atom' | 'repl';
```

**relevance to block 0:** BrainCli operates at the `'repl'` grain — it has multi-turn capability with tool use. this discriminant controls whether `BrainOutput.series` is `BrainSeries` or `null`.

---

#### 1.7 BrainSpec

**classification:** domain literal

**source:** `rhachet` package → `domain.objects/BrainSpec`

**shape (abbreviated):**
```ts
interface BrainSpec {
  cost: {
    time: { speed: number };
    cash: { cache: { read: IsoPrice; write: IsoPrice }; input: IsoPrice; output: IsoPrice };
  };
  gain: {
    size: { context: number; output: number };
    grades: { swe: number; mmlu: number; humaneval: number; gpqa: number };
    cutoff: string;
    domain: string[];
    skills: string[];
  };
}
```

**relevance to block 0:** the claude supplier config maps slug → BrainSpec. the `cost.cash` rates are used to derive `BrainOutputMetrics.cost.cash` from token counts. `gain.size.context` informs episode capacity.

---

#### 1.8 BrainSupplierSlug

**classification:** branded type (literal)

**source:** `rhachet` package → `domain.objects/BrainSupplierSlug`

**shape:**
```ts
type BrainSupplierSlug = string & { __brand: 'BrainSupplierSlug' };
```

**pattern:** suffix after `rhachet-brains-` in the package name. examples: `'anthropic'`, `'opencode'`, `'xai'`.

**factory:** `toBrainSupplierSlug(packageName: string): BrainSupplierSlug`

**relevance to block 0:** the factory `genBrainCli` uses the supplier slug prefix from the brain slug to route to the correct supplier. for block 0, only `'anthropic'` is supported.

---

#### 1.9 ContextCli

**classification:** domain literal (context object)

**source:** `rhachet` package → `domain.objects/ContextCli`

**shape:**
```ts
interface ContextCli {
  cwd: string;
  gitroot: string;
}
```

**factory:** `genContextCli(input: { cwd: string }): Promise<ContextCli>`

**relevance to block 0:** the `cwd` context passed to `genBrainCli` may use or compose with ContextCli for path validation. the claude CLI process is spawned with `cwd` as its work directory.

---

### 2. new to block 0 (declared in `_topublish/`)

#### 2.1 BrainCli (interface)

**classification:** domain interface (not a domain object — it's a contract, not a data shape)

**target location:** `_topublish/rhachet/BrainCli.ts`

**shape (revised from handoff contract):**
```ts
interface BrainCli {
  ask(input: { prompt: string }): Promise<BrainOutput>;
  act(input: { prompt: string }): Promise<BrainOutput>;

  memory: { series: BrainSeries | null };

  executor: {
    instance: { pid: number; mode: BrainCliMode } | null;
    boot(input: { mode: BrainCliMode }): Promise<void>;
    kill(): void;
  };

  terminal: {
    write(data: string): void;
    resize(input: { cols: number; rows: number }): void;
    onData(cb: (chunk: string) => void): void;
    onExit(cb: (info: { code: number; signal: string | null }) => void): void;
  };
}
```

**surfaces:**
- `ask` / `act` — dispatch methods that return BrainOutput. the primary interface.
- `memory` — durable state that persists across process churn: series starts null, populated after first dispatch, preserved through crashes. always an object (never null itself) — the handle always has memory
- `executor` — process lifecycle: instance state + boot/kill methods. `executor.instance` is null before boot, `{ pid, mode }` while alive, null after exit/kill
- `terminal` — raw i/o: onData, onExit, write, resize

**note:** this is the handle — the process behind it may churn. `instance` tracks the live process; `memory` tracks what survives across reboots.

---

#### 2.2 BrainCliMode (type literal)

**classification:** type literal (union)

**target location:** inline on BrainCli or co-declared

**shape:**
```ts
type BrainCliMode = 'dispatch' | 'interact';
```

**relevance:** discriminant for boot target and current handle state. dispatch = headless nd-JSON structured i/o. interact = raw PTY byte relay.

---

#### 2.3 AnthropicBrainCliSlug (branded type)

**classification:** branded type (literal)

**target location:** `_topublish/rhachet-brains-anthropic/BrainCli.config.ts`

**shape:**
```ts
type AnthropicBrainCliSlug = 'claude@anthropic/claude/opus/v4.5' | /* other claude variants */;
```

**relevance:** the set of valid slug values for the anthropic supplier. the config map uses this as the key type.

---

#### 2.4 AnthropicBrainCliConfig (config literal)

**classification:** domain literal (static config)

**target location:** `_topublish/rhachet-brains-anthropic/BrainCli.config.ts`

**shape (inferred from vision + access research):**
```ts
interface AnthropicBrainCliConfig {
  slug: AnthropicBrainCliSlug;
  binary: string;           // e.g., 'claude'
  spec: BrainSpec;          // model capabilities + rates
  tools: {
    ask: string[];          // read-only tools for --allowedTools
    act: string[];          // full tools for --allowedTools
  };
}
```

**relevance:** maps a slug to the concrete CLI invocation parameters. `getOneDispatchArgs` and `getOneInteractArgs` consume this config.

---

## domain operations

### 3.1 operations in `_topublish/rhachet/` (contract layer)

| operation | verb | type | input | output | purpose |
|---|---|---|---|---|---|
| `genBrainCli` | gen | factory | `{ slug }`, context: `{ cwd }` | `BrainCli` | route slug to supplier, return handle |

**note:** `genBrainCli` has gen (findsert) semantics in name only — it always constructs a fresh handle. the "gen" prefix is appropriate because it encapsulates the slug → supplier lookup + handle construction. the handle itself is not persisted.

---

### 3.2 operations in `_topublish/rhachet-brains-anthropic/` (supplier layer)

| operation | verb | type | input | output | purpose |
|---|---|---|---|---|---|
| `genBrainCli` | gen | factory | `{ slug }`, context: `{ cwd }` | `BrainCli` | construct claude-specific handle with terminal + executor + ask/act |
| `getOneBrainOutputFromStreamJson` | getOne | parser | `{ stream: ReadableStream }` | `BrainOutput` | parse nd-JSON event stream into typed BrainOutput with metrics |
| `getOneDispatchArgs` | getOne | compute | `{ config, mode, series }` | `string[]` | compute CLI args for dispatch boot: `-p --input-format stream-json ...` |
| `getOneInteractArgs` | getOne | compute | `{ config, series }` | `string[]` | compute CLI args for interact boot: `--resume <session-id>` |

**operation detail:**

**`getOneBrainOutputFromStreamJson`** — the core parse operation. consumes nd-JSON events from stdout:
- extracts `input_tokens` from `message_start`
- accumulates text from `content_block_delta`
- extracts cumulative `output_tokens`, cache tokens from `message_delta`
- detects `message_stop` as completion signal (not process exit — CLI may hang)
- derives `cost.cash` from tokens × `BrainSpec.cost.cash` rates
- constructs `BrainEpisode` and updates `BrainSeries` from `session_id`

**`getOneDispatchArgs`** — deterministic arg assembly:
- always includes: `-p`, `--output-format stream-json`, `--input-format stream-json`, `--verbose`
- ask mode: `--allowedTools Read,Grep,Glob,WebSearch,WebFetch`
- act mode: `--allowedTools Read,Grep,Glob,Edit,Write,Bash,WebSearch,WebFetch`
- if series: `--resume <session_id>`

**`getOneInteractArgs`** — deterministic arg assembly:
- if series: `--resume <session_id>`
- no `-p` flag (interactive TUI mode)
- no `--allowedTools` (interactive mode uses its own permission model)

---

### 3.3 operations on the BrainCli handle (instance methods)

| operation | surface | mode constraint | input | output | purpose |
|---|---|---|---|---|---|
| `executor.boot` | executor | any | `{ mode: BrainCliMode }` | `void` | spawn or respawn process in target mode. updates `instance` and may update `memory.series` |
| `executor.kill` | executor | any (no-op if not booted) | none | `void` | terminate live process. sets `instance` to null |
| `ask` | dispatch | dispatch only | `{ prompt: string }` | `BrainOutput` | dispatch read-only task |
| `act` | dispatch | dispatch only | `{ prompt: string }` | `BrainOutput` | dispatch full-tool task |
| `terminal.write` | terminal | any | `data: string` | `void` | write raw data to process stdin |
| `terminal.resize` | terminal | any | `{ cols, rows }` | `void` | relay terminal dimensions |
| `terminal.onData` | terminal | any | `cb: (chunk) => void` | `void` | subscribe to output chunks |
| `terminal.onExit` | terminal | any | `cb: (info: { code, signal }) => void` | `void` | subscribe to process exit |

---

## domain object relationships

### 4.1 treestruct: decoration (composition hierarchy)

```
BrainOutput
├── .output: string (the text response)
├── .metrics: BrainOutputMetrics
│   ├── .size.tokens: { input, output, cache: { get, set } }
│   ├── .size.chars: { input, output, cache: { get, set } }
│   └── .cost: { time: IsoDuration, cash: { total, deets } | null }
├── .episode: BrainEpisode
│   ├── .hash: string
│   ├── .exid: string | null
│   └── .exchanges: BrainExchange[]
│       ├── .hash: string
│       ├── .input: string
│       ├── .output: string
│       └── .exid: string | null
└── .series: BrainSeries
    ├── .hash: string
    ├── .exid: string | null
    └── .episodes: BrainEpisode[]
```

**note:** BrainOutput is the root composite. every `ask()` / `act()` call returns one. BrainEpisode is nested inside BrainSeries (series contains the chain of episodes).

---

### 4.2 treestruct: BrainCli handle (interface surfaces)

```
BrainCli
├── .ask({ prompt }) → BrainOutput
├── .act({ prompt }) → BrainOutput
├── .memory: { series: BrainSeries | null }  # durable — survives reboots
├── .executor
│   ├── .instance: { pid, mode } | null      # ephemeral — the live process
│   ├── .boot({ mode }) → void
│   └── .kill() → void
└── .terminal
    ├── .write(data) → void
    ├── .resize({ cols, rows }) → void
    ├── .onData(cb) → void
    └── .onExit(cb: (info: { code, signal }) => void) → void
```

---

### 4.3 treestruct: supplier config (static data)

```
CONFIG_BY_CLI_SLUG: Record<AnthropicBrainCliSlug, AnthropicBrainCliConfig>
├── 'claude@anthropic/claude/opus/v4.5'
│   ├── .slug
│   ├── .binary: 'claude'
│   ├── .spec: BrainSpec
│   └── .tools: { ask: string[], act: string[] }
└── (other claude variants)
```

---

### 4.4 dependency graph: operations → domain objects

```
genBrainCli (contract)
└── genBrainCli (anthropic supplier)
    ├── reads: AnthropicBrainCliConfig (from CONFIG_BY_CLI_SLUG)
    ├── constructs: BrainCli handle
    │   ├── executor.boot
    │   │   ├── calls: getOneDispatchArgs | getOneInteractArgs
    │   │   ├── reads: AnthropicBrainCliConfig
    │   │   ├── reads: handle.memory.series (for --resume)
    │   │   └── writes: handle.executor.instance = { pid, mode }
    │   ├── ask / act
    │   │   ├── calls: getOneBrainOutputFromStreamJson
    │   │   └── produces: BrainOutput
    │   │       ├── contains: BrainOutputMetrics
    │   │       ├── contains: BrainEpisode
    │   │       │   └── contains: BrainExchange[]
    │   │       └── contains: BrainSeries
    │   └── terminal (onData, onExit, write, resize)
    │       └── wraps: child_process stdout/stdin or node-pty handle
    └── validates: slug against CONFIG_BY_CLI_SLUG keys
```

---

### 4.5 dependency direction

```
contract layer (_topublish/rhachet/)
├── BrainCli interface type
│   ├── depends on: BrainOutput (from rhachet)
│   ├── depends on: BrainSeries (from rhachet)
│   └── depends on: BrainEpisode (from rhachet)
└── genBrainCli factory
    └── depends on: BrainCli interface

supplier layer (_topublish/rhachet-brains-anthropic/)
├── genBrainCli factory
│   ├── depends on: BrainCli interface (from contract)
│   ├── depends on: AnthropicBrainCliConfig (local)
│   └── depends on: BrainOutput, BrainSeries, BrainEpisode (from rhachet)
├── getOneBrainOutputFromStreamJson
│   ├── depends on: BrainOutput (from rhachet)
│   ├── depends on: BrainOutputMetrics (from rhachet)
│   ├── depends on: BrainEpisode (from rhachet)
│   ├── depends on: BrainExchange (from rhachet)
│   ├── depends on: BrainSeries (from rhachet)
│   └── depends on: BrainSpec (from rhachet) — for cost derivation
├── getOneDispatchArgs
│   └── depends on: AnthropicBrainCliConfig (local)
└── getOneInteractArgs
    └── depends on: AnthropicBrainCliConfig (local)
```

**direction:** contract layer → rhachet domain objects. supplier layer → contract layer + rhachet domain objects. no upward deps. no circular deps.

---

## composition: how domain objects and operations support the wish

### 5.1 spawn flow

```
caller → genBrainCli({ slug }, { cwd })
  → contract genBrainCli validates slug prefix
  → routes to anthropic genBrainCli
  → looks up AnthropicBrainCliConfig from CONFIG_BY_CLI_SLUG
  → constructs BrainCli handle (instance=null, memory={ series: null })
  → returns handle to caller
```

**domain objects touched:** AnthropicBrainCliSlug, AnthropicBrainCliConfig, BrainCli

---

### 5.2 boot + dispatch flow

```
caller → handle.executor.boot({ mode: 'dispatch' })
  → if live process: kill it
  → getOneDispatchArgs({ config, mode: 'ask'|'act', series })
  → spawn child_process with computed args
  → update handle: executor.instance={ pid, mode }, wire terminal hooks

caller → handle.ask({ prompt })
  → write nd-JSON message to stdin
  → getOneBrainOutputFromStreamJson({ stream: stdout })
    → parse message_start → extract input_tokens
    → accumulate content_block_delta → collect text
    → parse message_delta → extract output_tokens, cache tokens
    → detect message_stop → signal complete
    → derive cost from tokens × BrainSpec rates
    → construct BrainExchange (prompt → output text)
    → construct BrainEpisode (with exchange)
    → construct or update BrainSeries (with session_id from events)
    → construct BrainOutputMetrics
    → construct BrainOutput
  → update handle.memory.series
  → return BrainOutput to caller
```

**domain objects touched:** AnthropicBrainCliConfig, BrainOutput, BrainOutputMetrics, BrainEpisode, BrainExchange, BrainSeries, BrainSpec

---

### 5.3 crash recovery flow

```
process dies → terminal.onExit fires → handle.executor.instance = null
caller → handle.executor.boot({ mode: 'dispatch' })
  → handle.memory.series is non-null (preserved from prior dispatch)
  → getOneDispatchArgs includes --resume <series.exid>
  → spawn new process with prior session context
  → update handle: executor.instance={ pid, mode='dispatch' }
  → memory.series preserved — same ref
```

**domain objects touched:** BrainSeries (preserved across boot), AnthropicBrainCliConfig

---

### 5.4 mode switch flow

```
caller → handle.executor.boot({ mode: 'interact' })
  → kill current dispatch process → handle.executor.instance = null
  → getOneInteractArgs({ config, series: handle.memory.series })
  → spawn via node-pty with --resume <series.exid>
  → update handle: executor.instance={ pid, mode='interact' }
  → memory.series preserved
  → terminal.onData now emits raw PTY bytes
  → terminal.write now accepts raw keystrokes
```

**domain objects touched:** BrainSeries (for --resume), AnthropicBrainCliConfig

---

## summary: domain inventory for block 0

### domain objects (9 total)

| object | classification | source | role in block 0 |
|---|---|---|---|
| BrainOutput | literal | rhachet (extant) | return type of ask/act |
| BrainOutputMetrics | literal | rhachet (extant) | metrics within BrainOutput |
| BrainEpisode | literal | rhachet (extant) | context window ref within BrainOutput |
| BrainSeries | literal | rhachet (extant) | cross-boot continuation ref |
| BrainExchange | literal | rhachet (extant) | atomic request-response pair |
| BrainGrain | type union | rhachet (extant) | discriminant ('atom' vs 'repl') |
| BrainSpec | literal | rhachet (extant) | model capabilities + cost rates |
| BrainSupplierSlug | branded type | rhachet (extant) | supplier discriminant |
| ContextCli | literal | rhachet (extant) | cwd + gitroot context |

### new types (4 total)

| type | classification | target location | role in block 0 |
|---|---|---|---|
| BrainCli | interface | `_topublish/rhachet/` | the handle contract |
| BrainCliMode | type union | `_topublish/rhachet/` | 'dispatch' or 'interact' |
| AnthropicBrainCliSlug | branded type | `_topublish/rhachet-brains-anthropic/` | valid claude slug values |
| AnthropicBrainCliConfig | literal | `_topublish/rhachet-brains-anthropic/` | slug → CLI invocation config |

### domain operations (5 total)

| operation | verb | layer | purpose |
|---|---|---|---|
| genBrainCli (contract) | gen | contract | slug → supplier route → handle |
| genBrainCli (supplier) | gen | supplier | construct claude-specific handle |
| getOneBrainOutputFromStreamJson | getOne | supplier | parse nd-JSON → BrainOutput |
| getOneDispatchArgs | getOne | supplier | compute dispatch CLI args |
| getOneInteractArgs | getOne | supplier | compute interact CLI args |

---

## citations

| # | source | type |
|---|---|---|
| [1] | rhachet package types (`dist/domain.objects/`) in khlone `node_modules` | primary |
| [2] | BrainCli contract handoff (`.behavior/v2026_02_15.khlone-v0/3.4.blueprint.handoff.contract.braincli.v1.i1.md`) | prior |
| [3] | block 0 handoff (`.behavior/v2026_02_15.khlone-v0/3.5.decomposition.handoff.block_0.v1.i1.md`) | prior |
| [4] | block 0 vision (`.behavior/v2026_02_20.v0p0-bhrain-cli/1.vision.md`) | prior |
| [5] | block 0 blackbox criteria (`.behavior/v2026_02_20.v0p0-bhrain-cli/2.1.criteria.blackbox.md`) | prior |
| [6] | block 0 access research (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.access._.v1.i1.md`) | prior |
| [7] | khlone-v0 domain distill (`.behavior/v2026_02_15.khlone-v0/3.2.distill.domain._.v1.i1.md`) | prior |
| [8] | rhachet sdk exports (`dist/contract/sdk.brains.d.ts`) | primary |
