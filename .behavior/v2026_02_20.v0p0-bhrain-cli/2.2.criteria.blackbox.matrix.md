# block 0: BrainCli — blackbox coverage matrix

> distilled from `2.1.criteria.blackbox.md` — all dimension combinations with expected outcomes

---

## matrix 1: genBrainCli (usecase.1)

| ind: slug validity | dep: returns | dep: error |
|---|---|---|
| valid claude slug | BrainCli handle (pid=null, mode=null) | — |
| unrecognized slug | — | BadRequestError with slug in message |

**dimensions:** 1 independent, 2 dependent. complete — no gaps.

---

## matrix 2: executor.boot (usecases 2, 8, 9)

| ind: handle state before boot | ind: target mode | dep: process action | dep: pid | dep: mode after | dep: series |
|---|---|---|---|---|---|
| not booted (fresh handle) | dispatch | spawn new | live pid | dispatch | null (no prior series) |
| not booted (fresh handle) | interact | spawn new | live pid | interact | null (no prior series) |
| booted dispatch (no series) | dispatch | kill + respawn | new live pid | dispatch | null |
| booted dispatch (with series) | dispatch | kill + respawn | new live pid | dispatch | preserved |
| booted dispatch (with series) | interact | kill + respawn | new live pid | interact | preserved |
| booted interact | dispatch | kill + respawn | new live pid | dispatch | preserved |
| booted interact | interact | kill + respawn | new live pid | interact | preserved |
| crashed (process dead, series extant) | dispatch | spawn new (resume) | new live pid | dispatch | preserved |
| crashed (process dead, series extant) | interact | spawn new (resume) | new live pid | interact | preserved |

**dimensions:** 2 independent (handle state × target mode), 4 dependent. 9 combinations.

**gap flag:** "not booted + interact" — the blackbox criteria don't explicitly address fresh-handle boot to interact mode. however, it follows the same pattern as fresh-handle boot to dispatch. no behavioral gap — the contract should support it.

---

## matrix 3: dispatch methods — ask and act (usecases 3, 4)

| ind: handle state | ind: method | dep: returns | dep: tool access | dep: error |
|---|---|---|---|---|
| booted dispatch | ask | BrainOutput (output + metrics + episode + series) | read-only tools | — |
| booted dispatch | act | BrainOutput (output + metrics + episode + series) | all tools (read + write) | — |
| not booted | ask | — | — | throws (no live process) |
| not booted | act | — | — | throws (no live process) |
| booted interact | ask | — | — | throws (wrong mode) |
| booted interact | act | — | — | throws (wrong mode) |

**dimensions:** 2 independent (handle state × method), 3 dependent. 6 combinations. complete — no gaps.

**note:** ask and act share identical guard behavior (not-booted → error, interact → error). the only difference is tool access scope. this symmetry is clean — no decomposition needed.

---

## matrix 4: terminal.onData (usecase.5)

| ind: mode | ind: event source | dep: onData fires | dep: data format |
|---|---|---|---|
| dispatch | ask/act response stream | yes | structured output chunks |
| interact | brain CLI terminal output | yes | raw PTY bytes |
| not booted | — | no (no process) | — |

**dimensions:** 2 independent (mode × event source), 2 dependent. 3 combinations. complete.

---

## matrix 5: terminal.onExit (usecase.6)

| ind: exit cause | dep: onExit fires | dep: payload | dep: fire count |
|---|---|---|---|
| clean exit (code 0) | yes | exit code | exactly once |
| crash (non-zero code) | yes | exit code | exactly once |
| signal (SIGTERM, SIGKILL, etc) | yes | signal name | exactly once |
| external kill | yes | exit code and/or signal | exactly once |

**dimensions:** 1 independent (exit cause), 3 dependent. 4 combinations. complete.

---

## matrix 6: kill (usecase.7)

| ind: handle state | dep: process action | dep: onExit fires | dep: error |
|---|---|---|---|
| live process | terminate | yes | — |
| not booted | no-op | no | — (no error) |
| already exited | no-op | no | — (no error) |

**dimensions:** 1 independent, 3 dependent. 3 combinations. complete.

---

## matrix 7: terminal.write (usecase.10)

| ind: mode | dep: write target | dep: data format |
|---|---|---|
| dispatch | structured stdin | protocol data |
| interact | process stdin | raw text (user keystrokes) |

**dimensions:** 1 independent, 2 dependent. 2 combinations. complete.

**gap flag:** what happens if terminal.write is called when not booted? the blackbox criteria don't specify. expected: throw or no-op. recommend: throw (consistent with ask/act guard pattern).

---

## matrix 8: BrainOutput metrics (usecase.11)

| ind: call sequence | dep: tokens.input | dep: tokens.output | dep: cost.time | dep: cost.cash | dep: scope |
|---|---|---|---|---|---|
| first ask/act call | > 0 | > 0 | duration value | cost object or null | per-call |
| second ask/act call (same handle) | > 0 | > 0 | duration value | cost object or null | per-call (independent of first) |

**dimensions:** 1 independent, 5 dependent. 2 combinations. complete.

---

## gap summary

| # | gap | source | recommendation |
|---|---|---|---|
| 1 | fresh handle boot to interact (no prior series) | matrix 2 | no behavioral gap — same pattern as dispatch. confirm in criteria if desired |
| 2 | terminal.write when not booted | matrix 7 | add guard: throw error (consistent with ask/act guards) |

---

## decomposition health

all matrices have 1-2 independent dimensions. no matrix exceeds 9 combinations. the behavioral boundaries are well-scoped — no decomposition needed.

the usecases cluster into three clean groups:
1. **lifecycle** (matrices 1, 2, 6): spawn → boot → kill
2. **dispatch** (matrices 3, 8): ask/act → BrainOutput with metrics
3. **terminal i/o** (matrices 4, 5, 7): onData, onExit, write
