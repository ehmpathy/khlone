# block 0: BrainCli contract + claude supplier — blueprint

> how to implement the BrainCli interface and its first supplier (claude code CLI), tested live

---

## 1. contract layer: `src/_topublish/rhachet/`

### 1.1 BrainCli.ts — the interface type

```ts
import { BrainOutput, BrainSeries } from 'rhachet';

/**
 * .what = the handle contract for a headless brain CLI process
 * .why = stable ref that survives process churn — the daemon codes against this
 */
export type BrainCliMode = 'dispatch' | 'interact';

export interface BrainCli {
  ask(input: { prompt: string }): Promise<BrainOutput>;
  act(input: { prompt: string }): Promise<BrainOutput>;

  memory: { series: BrainSeries | null };

  executor: {
    instance: { pid: number; mode: BrainCliMode } | null;
    boot(input: { mode: BrainCliMode }): Promise<void>;
    kill(): void;
  };

  terminal: {
    write(data: string): void;
    resize(input: { cols: number; rows: number }): void;
    onData(cb: (chunk: string) => void): void;
    onExit(cb: (info: { code: number; signal: string | null }) => void): void;
  };
}
```

**design notes:**
- `ask` / `act` first — the primary interface
- `memory` — durable state. always an object (never null). `series` starts null, populated after first dispatch, preserved across reboots
- `executor.instance` — ephemeral. `{ pid, mode }` while alive, null otherwise
- `executor.boot` / `executor.kill` — pure lifecycle methods
- `terminal` — raw i/o surface for both modes
- `terminal.resize` uses `(input: { cols, rows })` not positional args
- `terminal.onExit` uses `(info: { code, signal })` not positional args

### 1.2 genBrainCli.ts — the contract factory

```ts
import { BadRequestError } from 'helpful-errors';

/**
 * .what = route a brain slug to the correct supplier and return a BrainCli handle
 * .why = dependency inversion — khlone never touches vendor CLI args
 */
export const genBrainCli = async (
  input: { slug: string },
  context: { cwd: string },
): Promise<BrainCli> => {
  // extract supplier prefix from slug (e.g., 'claude@anthropic/...' -> 'anthropic')
  const supplierSlug = getOneSupplierSlugFromBrainSlug({ slug: input.slug });

  // route to supplier
  if (supplierSlug === 'anthropic') {
    const { genBrainCli: genAnthropicBrainCli } = await import(
      '../rhachet-brains-anthropic/genBrainCli'
    );
    return genAnthropicBrainCli(input, context);
  }

  // fail fast for unsupported suppliers
  throw new BadRequestError(
    `unsupported brain supplier: '${supplierSlug}' (from slug '${input.slug}')`,
    { slug: input.slug, supplierSlug },
  );
};
```

**note:** `getOneSupplierSlugFromBrainSlug` is a pure text parse — extract the part between `@` and the next `/`. for `claude@anthropic/claude/opus/v4.5`, it returns `anthropic`.

### 1.3 getOneSupplierSlugFromBrainSlug.ts — pure text parse

```ts
/**
 * .what = extract the supplier slug from a brain slug
 * .why = the contract factory needs to route to the correct supplier without knowledge of slug internals
 */
export const getOneSupplierSlugFromBrainSlug = (
  input: { slug: string },
): string => {
  // slug format: '<name>@<supplier>/<path...>'
  // e.g., 'claude@anthropic/claude/opus/v4.5' → 'anthropic'
  const atIndex = input.slug.indexOf('@');
  if (atIndex === -1)
    throw new BadRequestError('invalid brain slug: no @ separator', { slug: input.slug });

  const afterAt = input.slug.slice(atIndex + 1);
  const slashIndex = afterAt.indexOf('/');
  if (slashIndex === -1)
    throw new BadRequestError('invalid brain slug: no / after supplier', { slug: input.slug });

  return afterAt.slice(0, slashIndex);
};
```

### 1.4 index.ts — re-exports

```ts
export { BrainCli, BrainCliMode } from './BrainCli';
export { genBrainCli } from './genBrainCli';
```

---

## 2. supplier layer: `src/_topublish/rhachet-brains-anthropic/`

### 2.1 BrainCli.config.ts — slug-to-config map

**slug format**: `<binary>@<supplier>/<atom-slug>`

the CLI slug references the **atom** (model) directly — not the repl. the CLI replaces the repl: it supplies its own tool-use loop. so the slug portion after `<binary>@<supplier>/` maps 1:1 to `AnthropicBrainAtomSlug` from `CONFIG_BY_ATOM_SLUG`.

examples:
- `claude@anthropic/claude/opus/v4.5` — atom slug = `claude/opus/v4.5`
- `claude@anthropic/claude/haiku` — atom slug = `claude/haiku` (family alias, latest version)

```ts
import { BrainSpec } from 'rhachet';
import { type AnthropicBrainAtomSlug, CONFIG_BY_ATOM_SLUG } from 'rhachet-brains-anthropic/...';

export type AnthropicBrainCliSlug =
  | 'claude@anthropic/claude/haiku'
  | 'claude@anthropic/claude/haiku/v4.5'
  | 'claude@anthropic/claude/sonnet'
  | 'claude@anthropic/claude/sonnet/v4'
  | 'claude@anthropic/claude/sonnet/v4.5'
  | 'claude@anthropic/claude/opus'
  | 'claude@anthropic/claude/opus/v4.5';

export interface AnthropicBrainCliConfig {
  slug: AnthropicBrainCliSlug;
  binary: string;
  spec: BrainSpec;
  tools: {
    ask: string[];
    act: string[];
  };
}

export const CONFIG_BY_CLI_SLUG: Record<AnthropicBrainCliSlug, AnthropicBrainCliConfig> = {
  'claude@anthropic/claude/opus/v4.5': {
    slug: 'claude@anthropic/claude/opus/v4.5',
    binary: 'claude',
    spec: { /* BrainSpec for opus 4.5 — cost rates, context size, grades */ },
    tools: {
      ask: ['Read', 'Grep', 'Glob', 'WebSearch', 'WebFetch'],
      act: ['Read', 'Grep', 'Glob', 'Edit', 'Write', 'Bash', 'WebSearch', 'WebFetch'],
    },
  },
  'claude@anthropic/claude/sonnet/v4.5': {
    slug: 'claude@anthropic/claude/sonnet/v4.5',
    binary: 'claude',
    spec: { /* BrainSpec for sonnet 4.5 */ },
    tools: {
      ask: ['Read', 'Grep', 'Glob', 'WebSearch', 'WebFetch'],
      act: ['Read', 'Grep', 'Glob', 'Edit', 'Write', 'Bash', 'WebSearch', 'WebFetch'],
    },
  },
};
```

### 2.2 getOneDispatchArgs.ts — compute dispatch CLI args

```ts
import { BrainSeries } from 'rhachet';

/**
 * .what = compute CLI args for dispatch mode boot
 * .why = deterministic arg assembly — tested in isolation
 */
export const getOneDispatchArgs = (
  input: {
    config: AnthropicBrainCliConfig;
    taskMode: 'ask' | 'act';
    series: BrainSeries | null;
  },
): string[] => {
  const args: string[] = [
    '-p',
    '--output-format', 'stream-json',
    '--input-format', 'stream-json',
    '--verbose',
    '--allowedTools', input.config.tools[input.taskMode].join(','),
  ];

  // resume prior series if extant
  if (input.series?.exid) {
    args.push('--resume', input.series.exid);
  }

  return args;
};
```

**note:** `taskMode` is passed per-dispatch, not per-boot. the boot spawns the process; each ask/act call writes nd-JSON to stdin with the appropriate `--allowedTools`. however, since `--allowedTools` is a spawn-time arg (not per-message), the process must be respawned if task mode changes. this is handled by the handle internals — if the prior boot used `ask` tools and the caller now calls `act`, the handle kills and respawns with `act` tools.

**revision consideration:** the simpler approach is to boot with the full `act` tool set and have `ask` enforce read-only at the prompt level (instruct the brain to not mutate). however, this is less safe. the current design — respawn on mode switch — is safer. the handle tracks the last-booted task mode and respawns only if it changes.

### 2.3 getOneInteractArgs.ts — compute interact CLI args

```ts
/**
 * .what = compute CLI args for interact mode boot
 * .why = deterministic arg assembly — tested in isolation
 */
export const getOneInteractArgs = (
  input: {
    config: AnthropicBrainCliConfig;
    series: BrainSeries | null;
  },
): string[] => {
  const args: string[] = [];

  // resume prior series if extant
  if (input.series?.exid) {
    args.push('--resume', input.series.exid);
  }

  return args;
};
```

### 2.4 getOneBrainOutputFromStreamJson.ts — parse nd-JSON stream

```ts
import {
  BrainOutput,
  BrainOutputMetrics,
  BrainEpisode,
  BrainExchange,
  BrainSeries,
  BrainSpec,
} from 'rhachet';

/**
 * .what = parse nd-JSON event stream from claude `-p` into a typed BrainOutput
 * .why = the core transform — turns raw vendor stream into the contract's return type
 */
export const getOneBrainOutputFromStreamJson = async (
  input: {
    prompt: string;
    stdout: NodeJS.ReadableStream;
    spec: BrainSpec;
    seriesPrior: BrainSeries | null;
  },
): Promise<BrainOutput> => {
  // ... implementation:
  //
  // 1. line-buffer stdout into complete JSON lines
  // 2. for each line, parse as JSON and dispatch by event type:
  //    - message_start → extract initial input_tokens, capture session_id
  //    - content_block_start → note new block
  //    - content_block_delta → accumulate text (type: 'text_delta')
  //                          → accumulate partial json (type: 'input_json_delta')
  //    - content_block_stop → finalize block
  //    - message_delta → extract cumulative usage (output_tokens, cache tokens), stop_reason
  //    - message_stop → signal completion (do NOT wait for process exit — CLI may hang)
  //    - error → throw with context
  // 3. derive cost from tokens x spec rates
  // 4. construct BrainExchange, BrainEpisode, BrainSeries
  // 5. construct BrainOutputMetrics
  // 6. return BrainOutput
};
```

**key edge cases (from claims research):**
- detect `message_stop` as completion — do not rely on process exit (claim: CLI may hang after final event)
- accumulate `partial_json` in `input_json_delta` chunks until `content_block_stop` before parse
- token counts in `message_delta` are cumulative per-turn, not incremental
- `session_id` comes from the response JSON — capture it for series construction

### 2.5 genBrainCli.ts — the supplier factory

this is the core file. it constructs the BrainCli handle with all surfaces wired.

```ts
import { spawn } from 'child_process';
import { BadRequestError, UnexpectedCodePathError } from 'helpful-errors';
import { BrainSeries } from 'rhachet';

import { BrainCli, BrainCliMode } from '../rhachet/BrainCli';
import { CONFIG_BY_CLI_SLUG, AnthropicBrainCliSlug } from './BrainCli.config';
import { getOneDispatchArgs } from './getOneDispatchArgs';
import { getOneInteractArgs } from './getOneInteractArgs';
import { getOneBrainOutputFromStreamJson } from './getOneBrainOutputFromStreamJson';

/**
 * .what = construct a BrainCli handle for a claude code CLI process
 * .why = the anthropic supplier — wires spawn, dispatch, terminal, and series management
 */
export const genBrainCli = async (
  input: { slug: string },
  context: { cwd: string },
): Promise<BrainCli> => {
  // validate slug
  const config = CONFIG_BY_CLI_SLUG[input.slug as AnthropicBrainCliSlug];
  if (!config)
    throw new BadRequestError('unrecognized anthropic brain CLI slug', {
      slug: input.slug,
      valid: Object.keys(CONFIG_BY_CLI_SLUG),
    });

  // mutable handle state
  let instance: BrainCli['executor']['instance'] = null;
  let series: BrainSeries | null = null;
  let lastTaskMode: 'ask' | 'act' | null = null;
  let childProcess: ReturnType<typeof spawn> | null = null;
  let ptyProcess: /* @lydell/node-pty IPty */ | null = null;

  // event callback registries
  const dataListeners: Array<(chunk: string) => void> = [];
  const exitListeners: Array<(info: { code: number; signal: string | null }) => void> = [];

  // helper: wire child process events to terminal callbacks
  const wireTerminalHooks = (/* process handle */) => {
    // stdout.on('data') → fire all dataListeners
    // on('exit') → set instance to null, fire all exitListeners
  };

  // the handle
  const handle: BrainCli = {
    // dispatch methods
    ask: async (askInput) => {
      // guard: must be in dispatch mode
      if (!instance)
        throw new UnexpectedCodePathError('cannot ask: no live process. call executor.boot first');
      if (instance.mode !== 'dispatch')
        throw new UnexpectedCodePathError('cannot ask: handle is in interact mode. boot dispatch first');

      // if prior boot used act tools, respawn with ask tools
      if (lastTaskMode !== 'ask') {
        await handle.executor.boot({ mode: 'dispatch' });
        lastTaskMode = 'ask';
      }

      // write nd-JSON message to stdin
      // collect BrainOutput from stream
      // update series
      // return BrainOutput
    },

    act: async (actInput) => {
      // guard: same as ask but for act mode
      // if prior boot used ask tools, respawn with act tools
      // write nd-JSON message to stdin
      // collect BrainOutput from stream
      // update series
      // return BrainOutput
    },

    // durable state
    memory: {
      get series() { return series; },
      set series(v) { series = v; },
    },

    // process lifecycle
    executor: {
      get instance() { return instance; },

      boot: async (bootInput) => {
        // kill extant process if alive
        if (instance) handle.executor.kill();

        if (bootInput.mode === 'dispatch') {
          // spawn via child_process.spawn with pipe stdio
          const args = getOneDispatchArgs({
            config,
            taskMode: lastTaskMode ?? 'ask',
            series,
          });
          childProcess = spawn(config.binary, args, {
            cwd: context.cwd,
            env: { ...process.env },
            stdio: ['pipe', 'pipe', 'pipe'],
          });
          instance = { pid: childProcess.pid!, mode: 'dispatch' };
          wireTerminalHooks(/* childProcess */);
        }

        if (bootInput.mode === 'interact') {
          // spawn via @lydell/node-pty for raw PTY
          const args = getOneInteractArgs({ config, series });
          // ptyProcess = ptySpawn(config.binary, args, { ... })
          instance = { pid: ptyProcess!.pid, mode: 'interact' };
          wireTerminalHooks(/* ptyProcess */);
        }
      },

      kill: () => {
        if (!instance) return; // no-op if not booted
        // SIGTERM the process
        // cleanup: set instance to null
        // note: onExit will fire from the process exit handler
      },
    },

    // terminal i/o
    terminal: {
      write: (data) => {
        if (!instance)
          throw new UnexpectedCodePathError('cannot write: no live process');
        // dispatch mode: write to childProcess.stdin
        // interact mode: write to ptyProcess
      },
      resize: (resizeInput) => {
        // interact mode: ptyProcess.resize(cols, rows)
        // dispatch mode: no-op (no terminal to resize)
      },
      onData: (cb) => { dataListeners.push(cb); },
      onExit: (cb) => { exitListeners.push(cb); },
    },
  };

  return handle;
};
```

**key implementation details:**

1. **ask/act tool mode respawn** — `--allowedTools` is a spawn-time arg. the handle tracks `lastTaskMode`. if a caller calls `.ask()` after a prior `.act()` (or vice versa), the handle internally kills and respawns with the correct tool set. this is invisible to the caller.

2. **nd-JSON multi-turn on live process** — in dispatch mode, each ask/act writes a nd-JSON message to stdin and reads the response stream from stdout. the process stays alive between calls. no respawn per task.

3. **series capture** — `session_id` comes from the first `message_start` event. the handle captures it and constructs/updates `BrainSeries`. on subsequent boots, `--resume <series.exid>` continues the prior session.

4. **PTY for interact only** — dispatch uses `child_process.spawn` with `stdio: ['pipe', 'pipe', 'pipe']`. interact uses `@lydell/node-pty` for full terminal emulation. different spawn strategies, same terminal surface.

5. **event listener registry** — `onData` and `onExit` register callbacks that persist across process reboots. when boot kills and respawns, the new process is wired to the same listener registry. callers register once, survive reboots.

### 2.6 index.ts — exports

```ts
export { genBrainCli } from './genBrainCli';
export { CONFIG_BY_CLI_SLUG, AnthropicBrainCliSlug, AnthropicBrainCliConfig } from './BrainCli.config';
```

---

## 3. test coverage

### 3.1 unit tests

| file | what it tests |
|---|---|
| `getOneSupplierSlugFromBrainSlug.test.ts` | pure text parse: valid slugs, absent `@`, absent `/` after supplier |
| `getOneDispatchArgs.test.ts` | deterministic arg assembly for ask/act modes, with/without series |
| `getOneInteractArgs.test.ts` | deterministic arg assembly with/without series |
| `getOneBrainOutputFromStreamJson.test.ts` | parse nd-JSON event stream into BrainOutput. test with synthetic stream data — message_start, content_block_delta, message_delta, message_stop events |

**unit test strategy:**
- `getOneSupplierSlugFromBrainSlug` — data-driven caselist: valid slugs extract correct supplier, absent `@` throws, absent `/` throws
- `getOneDispatchArgs` and `getOneInteractArgs` are pure compute — data-driven caselist tests with expected arg arrays
- `getOneBrainOutputFromStreamJson` — feed synthetic nd-JSON lines into a readable stream, assert BrainOutput shape. covers: token extraction, cost derivation, series construction, text accumulation, error event

### 3.2 integration tests

| file | what it tests |
|---|---|
| `genBrainCli.integration.test.ts` | all usecases against a live claude code CLI process |

**integration test plan** (maps to blackbox criteria usecases 1-11):

```
given a valid claude slug and cwd
  when genBrainCli is called
    then it returns a BrainCli handle with instance=null and memory.series=null

given an invalid slug
  when genBrainCli is called
    then it throws BadRequestError

given a fresh BrainCli handle
  when executor.boot({ mode: 'dispatch' }) is called
    then executor.instance is { pid: <number>, mode: 'dispatch' }

given a booted dispatch handle
  when ask({ prompt: 'what is 2+2?' }) is called
    then it returns BrainOutput
    then output is a non-empty text
    then metrics.size.tokens.input > 0
    then metrics.size.tokens.output > 0
    then metrics.cost.time is a duration
    then memory.series is non-null

given a booted dispatch handle
  when act({ prompt: 'list files in cwd' }) is called
    then it returns BrainOutput with non-zero tokens

given a booted dispatch handle with series
  when executor.kill() is called then executor.boot({ mode: 'dispatch' })
    then executor.instance has a new pid
    then memory.series is preserved (same exid)

given a booted dispatch handle with series
  when executor.boot({ mode: 'interact' }) is called
    then executor.instance.mode is 'interact'
    then memory.series is preserved

given a booted dispatch handle
  when terminal.onData is registered and ask is called
    then the callback fires with output chunks

given a booted handle
  when the process is killed externally
    then terminal.onExit fires exactly once

given a handle that is not booted
  when ask({ prompt }) is called
    then it throws

given a handle booted in interact mode
  when ask({ prompt }) is called
    then it throws

given two sequential ask calls on the same handle
  when both return BrainOutput
    then each BrainOutput has independent metrics (per-call, not cumulative)
    then metrics.size.tokens.input and output are both > 0 for each

given a booted dispatch handle
  when terminal.write is called with raw data
    then the data is written to the process stdin without error

given a handle booted in interact mode
  when the brain CLI emits terminal output
    then terminal.onData fires with raw PTY bytes
```

**integration test notes:**
- tests run against a live `claude` binary — requires valid credentials on the machine
- use `genTempDir({ slug: 'braincli' })` from `test-fns` for the cwd — auto-cleanup of stale dirs, repo-local `.temp/` path, no os-specific temp dir deps
- use cheap prompts (`'what is 2+2?'`, `'respond with ok'`) to minimize token cost
- the mode switch test (dispatch → interact → dispatch) validates series preservation across all transitions
- `terminal.onData` test: register callback before ask, assert it fired at least once
- `terminal.onExit` test: boot, then kill, assert callback fired with code

### 3.3 acceptance tests

no acceptance tests for this block — block 0 is a library, not a CLI. acceptance tests apply at the khlone command level (blocks A+).

---

## 4. filediff treestruct

```
src/
└── _topublish/
    ├── rhachet/                                                  # contract layer
    │   ├── [+] BrainCli.ts                                      # interface type + BrainCliMode
    │   ├── [+] genBrainCli.ts                                   # factory: slug -> supplier -> handle
    │   ├── [+] getOneSupplierSlugFromBrainSlug.ts                # pure text parse: slug -> supplier prefix
    │   ├── [+] index.ts                                          # re-exports
    │   └── __test__/
    │       └── [+] getOneSupplierSlugFromBrainSlug.test.ts       # unit: slug parse caselist
    └── rhachet-brains-anthropic/                                 # supplier layer
        ├── [+] BrainCli.config.ts                                # CONFIG_BY_CLI_SLUG + types
        ├── [+] genBrainCli.ts                                    # factory: slug -> claude handle
        ├── [+] getOneBrainOutputFromStreamJson.ts                # nd-JSON stream -> BrainOutput
        ├── [+] getOneDispatchArgs.ts                             # compute dispatch CLI args
        ├── [+] getOneInteractArgs.ts                             # compute interact CLI args
        ├── [~] index.ts                                          # add BrainCli exports alongside extant hooks
        └── __test__/
            ├── [+] genBrainCli.integration.test.ts               # live CLI integration tests
            ├── [+] getOneBrainOutputFromStreamJson.test.ts       # unit: synthetic stream parse
            ├── [+] getOneDispatchArgs.test.ts                    # unit: arg assembly
            └── [+] getOneInteractArgs.test.ts                    # unit: arg assembly
```

**totals:** 10 prod files (+1 updated), 5 test files. 16 total.

---

## 5. codepath treestruct

```
genBrainCli (contract)                                            [+] create
├── getOneSupplierSlugFromBrainSlug                               [+] create
│   ├── parse: extract supplier between '@' and first '/'         [+] create
│   └── guard: throw BadRequestError if absent '@' or '/'         [+] create
└── genBrainCli (anthropic supplier)                              [+] create
    ├── validates: slug against CONFIG_BY_CLI_SLUG                [+] create
    ├── constructs: BrainCli handle                               [+] create
    │   ├── handle.ask                                            [+] create
    │   │   ├── guard: instance must be dispatch mode             [+] create
    │   │   ├── respawn if lastTaskMode changed                   [+] create
    │   │   ├── write nd-JSON to stdin                            [+] create
    │   │   └── getOneBrainOutputFromStreamJson                   [+] create
    │   │       ├── line-buffer stdout                            [+] create
    │   │       ├── parse event types                             [+] create
    │   │       ├── derive cost from tokens x spec                [+] create
    │   │       └── construct BrainOutput                         [+] create
    │   ├── handle.act                                            [+] create
    │   │   └── (same as ask, different tool set)                 [+] create
    │   ├── handle.executor.boot                                  [+] create
    │   │   ├── kill extant process                               [+] create
    │   │   ├── dispatch mode: spawn via child_process            [+] create
    │   │   │   └── getOneDispatchArgs                            [+] create
    │   │   ├── interact mode: spawn via @lydell/node-pty         [+] create
    │   │   │   └── getOneInteractArgs                            [+] create
    │   │   └── wire terminal hooks to new process                [+] create
    │   ├── handle.executor.kill                                  [+] create
    │   ├── handle.terminal.write                                 [+] create
    │   ├── handle.terminal.resize                                [+] create
    │   ├── handle.terminal.onData                                [+] create
    │   └── handle.terminal.onExit                                [+] create
    └── CONFIG_BY_CLI_SLUG                                        [+] create
        └── BrainSpec per slug                                    [←] reuse from rhachet

BrainOutput / BrainOutputMetrics / BrainEpisode / etc             [←] reuse from rhachet
BrainSpec                                                         [←] reuse from rhachet
BadRequestError / UnexpectedCodePathError                         [←] reuse from helpful-errors
```

---

## 6. dependencies

### 6.1 new dev dependencies to install

| package | version | purpose |
|---|---|---|
| `@lydell/node-pty` | latest | PTY spawn for interact mode |

### 6.2 extant dependencies (no change)

| package | source | used for |
|---|---|---|
| `rhachet` | devDeps | BrainOutput, BrainSeries, BrainSpec, BrainEpisode, BrainExchange types |
| `helpful-errors` | deps | BadRequestError, UnexpectedCodePathError |
| `domain-objects` | deps | DomainLiteral for config objects |
| `test-fns` | devDeps | given/when/then test structure |

---

## 7. open design questions for implementation

| # | question | recommendation | impact |
|---|---|---|---|
| 1 | ask/act tool mode: respawn per mode switch or boot with act tools always? | respawn per mode switch (safer — claim 35 notes allowedTools is the enforcement mechanism) | handle complexity |
| 2 | nd-JSON line buffer: use a library (e.g., `split2`) or roll custom? | roll custom — it's ~10 lines, avoids a dep | simplicity |
| 3 | should `getOneDispatchArgs` accept `taskMode` (per-dispatch) or should boot accept it? | boot accepts it — `--allowedTools` is a spawn-time arg, not a per-message arg | architecture |
| 4 | should `terminal.onExit` fire on kill? | yes — consistent with node child_process behavior. callers should not distinguish kill from crash at the terminal level | contract clarity |
| 5 | how to handle `--allowedTools` task mode enforcement since it is a spawn-time arg? | track `lastTaskMode` on the handle. if ask/act caller requests a different mode than the last boot, silently kill+respawn. the caller never knows. | transparency |

---

## 8. risk awareness (from claims research)

| risk | mitigation in this block | ref |
|---|---|---|
| CLI may hang after `message_stop` | detect `message_stop` as completion, do not wait for process exit | claim z2.3 |
| `--allowedTools` bypass (claim 35) | open question — enforce at CLI level, trust the vendor | claim 35 |
| session file growth over time | not addressed in v0 — future todo (claim z2.29) | z2 zoomin |
| multi-clone contention | not addressed — not-yet-a-problem at 10+ parallel (claim z1.30) | z1 zoomin |
| `@lydell/node-pty` platform support | prebuilt binaries for current platform only — matches khlone's single-machine model | claim 22 |

---

## citations

| # | source | type |
|---|---|---|
| [1] | block 0 handoff (`.behavior/v2026_02_15.khlone-v0/3.5.decomposition.handoff.block_0.v1.i1.md`) | prior |
| [2] | BrainCli contract handoff (`.behavior/v2026_02_15.khlone-v0/3.4.blueprint.handoff.contract.braincli.v1.i1.md`) | prior |
| [3] | block 0 vision (`.behavior/v2026_02_20.v0p0-bhrain-cli/1.vision.md`) | prior |
| [4] | blackbox criteria (`.behavior/v2026_02_20.v0p0-bhrain-cli/2.1.criteria.blackbox.md`) | prior |
| [5] | blackbox matrix (`.behavior/v2026_02_20.v0p0-bhrain-cli/2.2.criteria.blackbox.matrix.md`) | prior |
| [6] | domain research (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.domain._.v1.i1.md`) | prior |
| [7] | access research (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.access._.v1.i1.md`) | prior |
| [8] | claims research (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.claims._.v1.i1.md`) | prior |
| [9] | z1 zoomin: multi-clone contention (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.claims.z1.multi-clone-contention.v1.i1.md`) | prior |
| [10] | z2 zoomin: session file RAM (`.behavior/v2026_02_20.v0p0-bhrain-cli/3.1.research.claims.z2.session-file-ram.v1.i1.md`) | prior |
