# block 0: BrainCli contract + claude supplier — vision

> a clean handle that lets you spawn, dispatch, stream, and recover a headless claude code process — tested live, ready for khlone's daemon to consume

---

## the outcome world

### before

```ts
// you want to drive claude code headless? good luck.
import { spawn } from 'child_process';

const proc = spawn('claude', ['-p', '--output-format', 'stream-json', ...]);
proc.stdout.on('data', (chunk) => {
  // raw bytes — partial JSON lines, split across chunks
  // you parse it yourself. you handle backpressure. you track session_id.
  // you figure out --allowedTools for ask vs act.
  // you build your own crash recovery.
  // you build your own metrics extraction.
  // you do this again for codex. and opencode. and gemini.
});
```

every consumer reimplements the same boilerplate: spawn args, stream parse, session continuation, crash recovery, mode enforcement. the vendor CLI is a subprocess — not a contract.

### after

```ts
const brainCli = await genBrainCli(
  { slug: 'claude@anthropic/claude/opus/v4.5' },
  { cwd: '/home/vlad/git/ehmpathy/myrepo' },
);

// boot headless
await brainCli.executor.boot({ mode: 'dispatch' });

// ask — read-only, no side effects
const answer = await brainCli.ask({ prompt: 'what files changed?' });
// → BrainOutput { output, metrics: { tokens, cost, time }, episode, series }

// act — full tool use
const result = await brainCli.act({ prompt: 'implement jwt validation' });

// stream raw output
brainCli.terminal.onData((chunk) => console.log(chunk));

// crash? the handle survives. reboot, series preserved.
brainCli.terminal.onExit(() => {
  brainCli.executor.boot({ mode: 'dispatch' }); // same series, new episode
});

// switch to interactive for talk mode
await brainCli.executor.boot({ mode: 'interact' });
// → same handle, new process, raw PTY byte relay
```

one handle. two modes. structured metrics. crash recovery. session continuation. the vendor CLI details are invisible.

### the "aha" moment

you call `brainCli.ask({ prompt })` and get back a typed `BrainOutput` with token counts, cost, and a series ref — from a live claude code process. no stream parse code. no arg assembly. no session ID bookkeep. the contract did it all.

then the process crashes. you call `brainCli.executor.boot({ mode: 'dispatch' })` and the handle comes back alive with the same series. the crash was a non-event.

the handle is the abstraction that makes clones possible.

---

## what this block delivers

this is a library block — no CLI, no daemon, no khlone domain objects. pure contract + first supplier.

### the contract (`_topublish/rhachet/`)

the `BrainCli` interface type: the shape that every brain supplier must implement.

- **`terminal`** — raw i/o surface: `onData`, `onExit`, `write`, `resize`
- **`executor`** — process lifecycle: `boot({ mode })`, `kill()`, `pid`, `series`
- **`ask({ prompt })`** — dispatch read-only task, returns `BrainOutput`
- **`act({ prompt })`** — dispatch full-tool task, returns `BrainOutput`

plus `genBrainCli` — the factory that routes a brain slug to the correct supplier.

### the claude supplier (`_topublish/rhachet-brains-anthropic/`)

the first implementation of the contract, for claude code CLI:

- **dispatch mode**: spawns `claude -p --input-format stream-json --output-format stream-json --allowedTools ...`
- **interact mode**: spawns `claude --resume <session-id>` in raw PTY mode
- **ask vs act**: enforced via `--allowedTools` — ask restricts to read-only tools, act permits all
- **nd-JSON stream parse**: turns claude's stream events into typed `BrainOutput` with metrics
- **series preservation**: captures `session_id` from output, passes via `--resume` on reboot

### the tests (integration, against live claude CLI)

every capability proven against a real claude code process:

| what | how |
|---|---|
| boot dispatch | spawn `-p` with structured i/o, capture session_id |
| boot interact | kill dispatch process, spawn `--resume` in raw terminal mode |
| ask | send nd-JSON input, collect `BrainOutput` with metrics (tokens > 0) |
| act | same as ask, verify different `--allowedTools` set |
| terminal.onData | raw byte stream fires with output |
| terminal.onExit | exit signal fires on process death |
| kill | clean termination |
| crash → boot | series preserved, new episode, same series ref |

---

## mental model

### how you'd describe it to a friend

> "it's a typed handle around a headless CLI process. you spawn it, send it tasks via `.ask()` and `.act()`, get back structured results with token counts, and if the process dies you reboot the handle and it picks up where it left off. the same interface works for claude, codex, opencode — swap the slug, same contract."

### the analogy

a database connection pool gives you a `Connection` handle — you don't care if the TCP socket reconnects behind it. `BrainCli` is the same pattern for brain CLI processes. the handle is stable; the process behind it may churn.

### terms

| our term | what it means |
|---|---|
| `BrainCli` | the handle type — a live brain CLI process you can drive |
| `genBrainCli` | the factory — `(input: { slug }, context: { cwd })` → live handle |
| `brain slug` | format: `<binary>@<supplier>/<atom-slug>` — the CLI references the atom (model) directly, not the repl. the CLI replaces the repl (supplies its own tool-use loop) |
| `dispatch mode` | headless nd-JSON structured i/o (for ask/act) |
| `interact mode` | raw PTY byte relay (for talk mode) |
| `BrainOutput` | structured result from ask/act — output + metrics + series ref |
| `series` | cross-boot continuation ref (claude's `session_id`) |
| `episode` | single context window within a series |
| `supplier` | vendor-specific implementation of the BrainCli contract |

---

## evaluation

### how well does it solve the goals?

this block delivers the critical external dependency for khlone v0. without it, no clone can spawn, no task can dispatch, no output can stream, no crash can recover. with it, every khlone feature that touches a brain process has a clean contract to code against.

### pros

- **clean separation** — khlone never touches vendor CLI args, stream formats, or session mechanics
- **testable in isolation** — the handle works without a daemon, without khlone domain objects, without persistence
- **crash recovery built in** — the handle manages its own series ref; reboot is a single method call
- **mode enforcement at the contract level** — ask vs act is a supplier concern, not a khlone concern
- **structured metrics from day one** — tokens, cost, and time are part of every `BrainOutput`

### cons

- **live CLI dependency for tests** — integration tests need a real claude code binary with valid credentials on the machine
- **process churn on mode switch** — dispatch ↔ interact kills and respawns (no live mode switch on any CLI today). acceptable — the handle hides it, and mode switches are rare (only for talk mode)
- **claude-only for v0** — other suppliers (codex, opencode, gemini) follow the same pattern but aren't built yet. the contract is designed for them, but unproven until they ship

### edge cases and pit of success

| edge case | how the contract handles it |
|---|---|
| ask in interact mode | throws — ask/act only valid in dispatch mode. caller must boot dispatch first |
| act with no boot | throws — process not alive. caller must boot before dispatch |
| crash mid-task | `terminal.onExit` fires → caller reboots → series preserved → re-dispatch |
| double boot | second boot kills current process, respawns in new mode — idempotent-safe |
| supplier can't provide cost | `metrics.cost.cash` is null — not an error. degraded but functional |
| supplier doesn't support series | `series` is null — crash recovery starts fresh context. degraded but functional |
| invalid brain slug | `genBrainCli` throws `BadRequestError` — fail fast with clear message |

---

## file inventory

```
src/_topublish/
├── rhachet/                              # contract (3 prod files)
│   ├── BrainCli.ts                       # interface type
│   ├── genBrainCli.ts                    # factory: slug → handle
│   └── index.ts                          # re-exports
└── rhachet-brains-anthropic/             # claude supplier (6 prod, 4 test)
    ├── BrainCli.config.ts                # slug → config map
    ├── genBrainCli.ts                    # factory: slug → claude handle
    ├── getOneBrainOutputFromStreamJson.ts # nd-JSON → BrainOutput
    ├── getOneDispatchArgs.ts             # CLI args for dispatch mode
    ├── getOneInteractArgs.ts             # CLI args for interact mode
    ├── index.ts                          # exports
    └── __test__/
        ├── genBrainCli.integration.test.ts
        ├── getOneBrainOutputFromStreamJson.test.ts
        ├── getOneDispatchArgs.test.ts
        └── getOneInteractArgs.test.ts
```

9 prod files. 4 test files. 13 total.
